/* TextPlain.js https://github.com/textplainly/textplain.js ©Vas Sudanagunta 2023 @license TBD */
/* version 0.0.0  build: 2023-10-28 12:14:32 GMT−4 */
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/json5/dist/index.js
var require_dist = __commonJS({
  "node_modules/json5/dist/index.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.JSON5 = factory();
    })(exports, function() {
      "use strict";
      function createCommonjsModule(fn, module2) {
        return module2 = { exports: {} }, fn(module2, module2.exports), module2.exports;
      }
      var _global = createCommonjsModule(function(module2) {
        var global = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
        if (typeof __g == "number") {
          __g = global;
        }
      });
      var _core = createCommonjsModule(function(module2) {
        var core = module2.exports = { version: "2.6.5" };
        if (typeof __e == "number") {
          __e = core;
        }
      });
      var _core_1 = _core.version;
      var _isObject = function(it) {
        return typeof it === "object" ? it !== null : typeof it === "function";
      };
      var _anObject = function(it) {
        if (!_isObject(it)) {
          throw TypeError(it + " is not an object!");
        }
        return it;
      };
      var _fails = function(exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };
      var _descriptors = !_fails(function() {
        return Object.defineProperty({}, "a", { get: function() {
          return 7;
        } }).a != 7;
      });
      var document = _global.document;
      var is = _isObject(document) && _isObject(document.createElement);
      var _domCreate = function(it) {
        return is ? document.createElement(it) : {};
      };
      var _ie8DomDefine = !_descriptors && !_fails(function() {
        return Object.defineProperty(_domCreate("div"), "a", { get: function() {
          return 7;
        } }).a != 7;
      });
      var _toPrimitive = function(it, S) {
        if (!_isObject(it)) {
          return it;
        }
        var fn, val;
        if (S && typeof (fn = it.toString) == "function" && !_isObject(val = fn.call(it))) {
          return val;
        }
        if (typeof (fn = it.valueOf) == "function" && !_isObject(val = fn.call(it))) {
          return val;
        }
        if (!S && typeof (fn = it.toString) == "function" && !_isObject(val = fn.call(it))) {
          return val;
        }
        throw TypeError("Can't convert object to primitive value");
      };
      var dP = Object.defineProperty;
      var f = _descriptors ? Object.defineProperty : function defineProperty(O, P, Attributes) {
        _anObject(O);
        P = _toPrimitive(P, true);
        _anObject(Attributes);
        if (_ie8DomDefine) {
          try {
            return dP(O, P, Attributes);
          } catch (e) {
          }
        }
        if ("get" in Attributes || "set" in Attributes) {
          throw TypeError("Accessors not supported!");
        }
        if ("value" in Attributes) {
          O[P] = Attributes.value;
        }
        return O;
      };
      var _objectDp = {
        f
      };
      var _propertyDesc = function(bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value
        };
      };
      var _hide = _descriptors ? function(object, key2, value) {
        return _objectDp.f(object, key2, _propertyDesc(1, value));
      } : function(object, key2, value) {
        object[key2] = value;
        return object;
      };
      var hasOwnProperty = {}.hasOwnProperty;
      var _has = function(it, key2) {
        return hasOwnProperty.call(it, key2);
      };
      var id = 0;
      var px = Math.random();
      var _uid = function(key2) {
        return "Symbol(".concat(key2 === void 0 ? "" : key2, ")_", (++id + px).toString(36));
      };
      var _library = false;
      var _shared = createCommonjsModule(function(module2) {
        var SHARED = "__core-js_shared__";
        var store = _global[SHARED] || (_global[SHARED] = {});
        (module2.exports = function(key2, value) {
          return store[key2] || (store[key2] = value !== void 0 ? value : {});
        })("versions", []).push({
          version: _core.version,
          mode: _library ? "pure" : "global",
          copyright: "\xA9 2019 Denis Pushkarev (zloirock.ru)"
        });
      });
      var _functionToString = _shared("native-function-to-string", Function.toString);
      var _redefine = createCommonjsModule(function(module2) {
        var SRC = _uid("src");
        var TO_STRING = "toString";
        var TPL = ("" + _functionToString).split(TO_STRING);
        _core.inspectSource = function(it) {
          return _functionToString.call(it);
        };
        (module2.exports = function(O, key2, val, safe) {
          var isFunction = typeof val == "function";
          if (isFunction) {
            _has(val, "name") || _hide(val, "name", key2);
          }
          if (O[key2] === val) {
            return;
          }
          if (isFunction) {
            _has(val, SRC) || _hide(val, SRC, O[key2] ? "" + O[key2] : TPL.join(String(key2)));
          }
          if (O === _global) {
            O[key2] = val;
          } else if (!safe) {
            delete O[key2];
            _hide(O, key2, val);
          } else if (O[key2]) {
            O[key2] = val;
          } else {
            _hide(O, key2, val);
          }
        })(Function.prototype, TO_STRING, function toString() {
          return typeof this == "function" && this[SRC] || _functionToString.call(this);
        });
      });
      var _aFunction = function(it) {
        if (typeof it != "function") {
          throw TypeError(it + " is not a function!");
        }
        return it;
      };
      var _ctx = function(fn, that, length) {
        _aFunction(fn);
        if (that === void 0) {
          return fn;
        }
        switch (length) {
          case 1:
            return function(a) {
              return fn.call(that, a);
            };
          case 2:
            return function(a, b) {
              return fn.call(that, a, b);
            };
          case 3:
            return function(a, b, c2) {
              return fn.call(that, a, b, c2);
            };
        }
        return function() {
          return fn.apply(that, arguments);
        };
      };
      var PROTOTYPE = "prototype";
      var $export = function(type, name, source2) {
        var IS_FORCED = type & $export.F;
        var IS_GLOBAL = type & $export.G;
        var IS_STATIC = type & $export.S;
        var IS_PROTO = type & $export.P;
        var IS_BIND = type & $export.B;
        var target = IS_GLOBAL ? _global : IS_STATIC ? _global[name] || (_global[name] = {}) : (_global[name] || {})[PROTOTYPE];
        var exports2 = IS_GLOBAL ? _core : _core[name] || (_core[name] = {});
        var expProto = exports2[PROTOTYPE] || (exports2[PROTOTYPE] = {});
        var key2, own, out, exp;
        if (IS_GLOBAL) {
          source2 = name;
        }
        for (key2 in source2) {
          own = !IS_FORCED && target && target[key2] !== void 0;
          out = (own ? target : source2)[key2];
          exp = IS_BIND && own ? _ctx(out, _global) : IS_PROTO && typeof out == "function" ? _ctx(Function.call, out) : out;
          if (target) {
            _redefine(target, key2, out, type & $export.U);
          }
          if (exports2[key2] != out) {
            _hide(exports2, key2, exp);
          }
          if (IS_PROTO && expProto[key2] != out) {
            expProto[key2] = out;
          }
        }
      };
      _global.core = _core;
      $export.F = 1;
      $export.G = 2;
      $export.S = 4;
      $export.P = 8;
      $export.B = 16;
      $export.W = 32;
      $export.U = 64;
      $export.R = 128;
      var _export = $export;
      var ceil = Math.ceil;
      var floor = Math.floor;
      var _toInteger = function(it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
      };
      var _defined = function(it) {
        if (it == void 0) {
          throw TypeError("Can't call method on  " + it);
        }
        return it;
      };
      var _stringAt = function(TO_STRING) {
        return function(that, pos2) {
          var s = String(_defined(that));
          var i = _toInteger(pos2);
          var l = s.length;
          var a, b;
          if (i < 0 || i >= l) {
            return TO_STRING ? "" : void 0;
          }
          a = s.charCodeAt(i);
          return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
        };
      };
      var $at = _stringAt(false);
      _export(_export.P, "String", {
        // 21.1.3.3 String.prototype.codePointAt(pos)
        codePointAt: function codePointAt2(pos2) {
          return $at(this, pos2);
        }
      });
      var codePointAt = _core.String.codePointAt;
      var max = Math.max;
      var min = Math.min;
      var _toAbsoluteIndex = function(index, length) {
        index = _toInteger(index);
        return index < 0 ? max(index + length, 0) : min(index, length);
      };
      var fromCharCode = String.fromCharCode;
      var $fromCodePoint = String.fromCodePoint;
      _export(_export.S + _export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), "String", {
        // 21.1.2.2 String.fromCodePoint(...codePoints)
        fromCodePoint: function fromCodePoint4(x) {
          var arguments$1 = arguments;
          var res = [];
          var aLen = arguments.length;
          var i = 0;
          var code;
          while (aLen > i) {
            code = +arguments$1[i++];
            if (_toAbsoluteIndex(code, 1114111) !== code) {
              throw RangeError(code + " is not a valid code point");
            }
            res.push(
              code < 65536 ? fromCharCode(code) : fromCharCode(((code -= 65536) >> 10) + 55296, code % 1024 + 56320)
            );
          }
          return res.join("");
        }
      });
      var fromCodePoint3 = _core.String.fromCodePoint;
      var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
      var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
      var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
      var unicode = {
        Space_Separator,
        ID_Start,
        ID_Continue
      };
      var util = {
        isSpaceSeparator: function isSpaceSeparator(c2) {
          return typeof c2 === "string" && unicode.Space_Separator.test(c2);
        },
        isIdStartChar: function isIdStartChar(c2) {
          return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 === "$" || c2 === "_" || unicode.ID_Start.test(c2));
        },
        isIdContinueChar: function isIdContinueChar(c2) {
          return typeof c2 === "string" && (c2 >= "a" && c2 <= "z" || c2 >= "A" && c2 <= "Z" || c2 >= "0" && c2 <= "9" || c2 === "$" || c2 === "_" || c2 === "\u200C" || c2 === "\u200D" || unicode.ID_Continue.test(c2));
        },
        isDigit: function isDigit(c2) {
          return typeof c2 === "string" && /[0-9]/.test(c2);
        },
        isHexDigit: function isHexDigit(c2) {
          return typeof c2 === "string" && /[0-9A-Fa-f]/.test(c2);
        }
      };
      var source;
      var parseState;
      var stack;
      var pos;
      var line;
      var column;
      var token;
      var key;
      var root;
      var parse = function parse2(text, reviver) {
        source = String(text);
        parseState = "start";
        stack = [];
        pos = 0;
        line = 1;
        column = 0;
        token = void 0;
        key = void 0;
        root = void 0;
        do {
          token = lex();
          parseStates[parseState]();
        } while (token.type !== "eof");
        if (typeof reviver === "function") {
          return internalize({ "": root }, "", reviver);
        }
        return root;
      };
      function internalize(holder, name, reviver) {
        var value = holder[name];
        if (value != null && typeof value === "object") {
          if (Array.isArray(value)) {
            for (var i = 0; i < value.length; i++) {
              var key2 = String(i);
              var replacement = internalize(value, key2, reviver);
              if (replacement === void 0) {
                delete value[key2];
              } else {
                Object.defineProperty(value, key2, {
                  value: replacement,
                  writable: true,
                  enumerable: true,
                  configurable: true
                });
              }
            }
          } else {
            for (var key$1 in value) {
              var replacement$1 = internalize(value, key$1, reviver);
              if (replacement$1 === void 0) {
                delete value[key$1];
              } else {
                Object.defineProperty(value, key$1, {
                  value: replacement$1,
                  writable: true,
                  enumerable: true,
                  configurable: true
                });
              }
            }
          }
        }
        return reviver.call(holder, name, value);
      }
      var lexState;
      var buffer;
      var doubleQuote;
      var sign;
      var c;
      function lex() {
        lexState = "default";
        buffer = "";
        doubleQuote = false;
        sign = 1;
        for (; ; ) {
          c = peek();
          var token2 = lexStates[lexState]();
          if (token2) {
            return token2;
          }
        }
      }
      function peek() {
        if (source[pos]) {
          return String.fromCodePoint(source.codePointAt(pos));
        }
      }
      function read() {
        var c2 = peek();
        if (c2 === "\n") {
          line++;
          column = 0;
        } else if (c2) {
          column += c2.length;
        } else {
          column++;
        }
        if (c2) {
          pos += c2.length;
        }
        return c2;
      }
      var lexStates = {
        default: function default$1() {
          switch (c) {
            case "	":
            case "\v":
            case "\f":
            case " ":
            case "\xA0":
            case "\uFEFF":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              read();
              return;
            case "/":
              read();
              lexState = "comment";
              return;
            case void 0:
              read();
              return newToken("eof");
          }
          if (util.isSpaceSeparator(c)) {
            read();
            return;
          }
          return lexStates[parseState]();
        },
        comment: function comment() {
          switch (c) {
            case "*":
              read();
              lexState = "multiLineComment";
              return;
            case "/":
              read();
              lexState = "singleLineComment";
              return;
          }
          throw invalidChar(read());
        },
        multiLineComment: function multiLineComment() {
          switch (c) {
            case "*":
              read();
              lexState = "multiLineCommentAsterisk";
              return;
            case void 0:
              throw invalidChar(read());
          }
          read();
        },
        multiLineCommentAsterisk: function multiLineCommentAsterisk() {
          switch (c) {
            case "*":
              read();
              return;
            case "/":
              read();
              lexState = "default";
              return;
            case void 0:
              throw invalidChar(read());
          }
          read();
          lexState = "multiLineComment";
        },
        singleLineComment: function singleLineComment() {
          switch (c) {
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
              read();
              lexState = "default";
              return;
            case void 0:
              read();
              return newToken("eof");
          }
          read();
        },
        value: function value() {
          switch (c) {
            case "{":
            case "[":
              return newToken("punctuator", read());
            case "n":
              read();
              literal("ull");
              return newToken("null", null);
            case "t":
              read();
              literal("rue");
              return newToken("boolean", true);
            case "f":
              read();
              literal("alse");
              return newToken("boolean", false);
            case "-":
            case "+":
              if (read() === "-") {
                sign = -1;
              }
              lexState = "sign";
              return;
            case ".":
              buffer = read();
              lexState = "decimalPointLeading";
              return;
            case "0":
              buffer = read();
              lexState = "zero";
              return;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              buffer = read();
              lexState = "decimalInteger";
              return;
            case "I":
              read();
              literal("nfinity");
              return newToken("numeric", Infinity);
            case "N":
              read();
              literal("aN");
              return newToken("numeric", NaN);
            case '"':
            case "'":
              doubleQuote = read() === '"';
              buffer = "";
              lexState = "string";
              return;
          }
          throw invalidChar(read());
        },
        identifierNameStartEscape: function identifierNameStartEscape() {
          if (c !== "u") {
            throw invalidChar(read());
          }
          read();
          var u = unicodeEscape();
          switch (u) {
            case "$":
            case "_":
              break;
            default:
              if (!util.isIdStartChar(u)) {
                throw invalidIdentifier();
              }
              break;
          }
          buffer += u;
          lexState = "identifierName";
        },
        identifierName: function identifierName() {
          switch (c) {
            case "$":
            case "_":
            case "\u200C":
            case "\u200D":
              buffer += read();
              return;
            case "\\":
              read();
              lexState = "identifierNameEscape";
              return;
          }
          if (util.isIdContinueChar(c)) {
            buffer += read();
            return;
          }
          return newToken("identifier", buffer);
        },
        identifierNameEscape: function identifierNameEscape() {
          if (c !== "u") {
            throw invalidChar(read());
          }
          read();
          var u = unicodeEscape();
          switch (u) {
            case "$":
            case "_":
            case "\u200C":
            case "\u200D":
              break;
            default:
              if (!util.isIdContinueChar(u)) {
                throw invalidIdentifier();
              }
              break;
          }
          buffer += u;
          lexState = "identifierName";
        },
        sign: function sign$1() {
          switch (c) {
            case ".":
              buffer = read();
              lexState = "decimalPointLeading";
              return;
            case "0":
              buffer = read();
              lexState = "zero";
              return;
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
              buffer = read();
              lexState = "decimalInteger";
              return;
            case "I":
              read();
              literal("nfinity");
              return newToken("numeric", sign * Infinity);
            case "N":
              read();
              literal("aN");
              return newToken("numeric", NaN);
          }
          throw invalidChar(read());
        },
        zero: function zero() {
          switch (c) {
            case ".":
              buffer += read();
              lexState = "decimalPoint";
              return;
            case "e":
            case "E":
              buffer += read();
              lexState = "decimalExponent";
              return;
            case "x":
            case "X":
              buffer += read();
              lexState = "hexadecimal";
              return;
          }
          return newToken("numeric", sign * 0);
        },
        decimalInteger: function decimalInteger() {
          switch (c) {
            case ".":
              buffer += read();
              lexState = "decimalPoint";
              return;
            case "e":
            case "E":
              buffer += read();
              lexState = "decimalExponent";
              return;
          }
          if (util.isDigit(c)) {
            buffer += read();
            return;
          }
          return newToken("numeric", sign * Number(buffer));
        },
        decimalPointLeading: function decimalPointLeading() {
          if (util.isDigit(c)) {
            buffer += read();
            lexState = "decimalFraction";
            return;
          }
          throw invalidChar(read());
        },
        decimalPoint: function decimalPoint() {
          switch (c) {
            case "e":
            case "E":
              buffer += read();
              lexState = "decimalExponent";
              return;
          }
          if (util.isDigit(c)) {
            buffer += read();
            lexState = "decimalFraction";
            return;
          }
          return newToken("numeric", sign * Number(buffer));
        },
        decimalFraction: function decimalFraction() {
          switch (c) {
            case "e":
            case "E":
              buffer += read();
              lexState = "decimalExponent";
              return;
          }
          if (util.isDigit(c)) {
            buffer += read();
            return;
          }
          return newToken("numeric", sign * Number(buffer));
        },
        decimalExponent: function decimalExponent() {
          switch (c) {
            case "+":
            case "-":
              buffer += read();
              lexState = "decimalExponentSign";
              return;
          }
          if (util.isDigit(c)) {
            buffer += read();
            lexState = "decimalExponentInteger";
            return;
          }
          throw invalidChar(read());
        },
        decimalExponentSign: function decimalExponentSign() {
          if (util.isDigit(c)) {
            buffer += read();
            lexState = "decimalExponentInteger";
            return;
          }
          throw invalidChar(read());
        },
        decimalExponentInteger: function decimalExponentInteger() {
          if (util.isDigit(c)) {
            buffer += read();
            return;
          }
          return newToken("numeric", sign * Number(buffer));
        },
        hexadecimal: function hexadecimal() {
          if (util.isHexDigit(c)) {
            buffer += read();
            lexState = "hexadecimalInteger";
            return;
          }
          throw invalidChar(read());
        },
        hexadecimalInteger: function hexadecimalInteger() {
          if (util.isHexDigit(c)) {
            buffer += read();
            return;
          }
          return newToken("numeric", sign * Number(buffer));
        },
        string: function string() {
          switch (c) {
            case "\\":
              read();
              buffer += escape();
              return;
            case '"':
              if (doubleQuote) {
                read();
                return newToken("string", buffer);
              }
              buffer += read();
              return;
            case "'":
              if (!doubleQuote) {
                read();
                return newToken("string", buffer);
              }
              buffer += read();
              return;
            case "\n":
            case "\r":
              throw invalidChar(read());
            case "\u2028":
            case "\u2029":
              separatorChar(c);
              break;
            case void 0:
              throw invalidChar(read());
          }
          buffer += read();
        },
        start: function start() {
          switch (c) {
            case "{":
            case "[":
              return newToken("punctuator", read());
          }
          lexState = "value";
        },
        beforePropertyName: function beforePropertyName() {
          switch (c) {
            case "$":
            case "_":
              buffer = read();
              lexState = "identifierName";
              return;
            case "\\":
              read();
              lexState = "identifierNameStartEscape";
              return;
            case "}":
              return newToken("punctuator", read());
            case '"':
            case "'":
              doubleQuote = read() === '"';
              lexState = "string";
              return;
          }
          if (util.isIdStartChar(c)) {
            buffer += read();
            lexState = "identifierName";
            return;
          }
          throw invalidChar(read());
        },
        afterPropertyName: function afterPropertyName() {
          if (c === ":") {
            return newToken("punctuator", read());
          }
          throw invalidChar(read());
        },
        beforePropertyValue: function beforePropertyValue() {
          lexState = "value";
        },
        afterPropertyValue: function afterPropertyValue() {
          switch (c) {
            case ",":
            case "}":
              return newToken("punctuator", read());
          }
          throw invalidChar(read());
        },
        beforeArrayValue: function beforeArrayValue() {
          if (c === "]") {
            return newToken("punctuator", read());
          }
          lexState = "value";
        },
        afterArrayValue: function afterArrayValue() {
          switch (c) {
            case ",":
            case "]":
              return newToken("punctuator", read());
          }
          throw invalidChar(read());
        },
        end: function end() {
          throw invalidChar(read());
        }
      };
      function newToken(type, value) {
        return {
          type,
          value,
          line,
          column
        };
      }
      function literal(s) {
        for (var i = 0, list = s; i < list.length; i += 1) {
          var c2 = list[i];
          var p = peek();
          if (p !== c2) {
            throw invalidChar(read());
          }
          read();
        }
      }
      function escape() {
        var c2 = peek();
        switch (c2) {
          case "b":
            read();
            return "\b";
          case "f":
            read();
            return "\f";
          case "n":
            read();
            return "\n";
          case "r":
            read();
            return "\r";
          case "t":
            read();
            return "	";
          case "v":
            read();
            return "\v";
          case "0":
            read();
            if (util.isDigit(peek())) {
              throw invalidChar(read());
            }
            return "\0";
          case "x":
            read();
            return hexEscape();
          case "u":
            read();
            return unicodeEscape();
          case "\n":
          case "\u2028":
          case "\u2029":
            read();
            return "";
          case "\r":
            read();
            if (peek() === "\n") {
              read();
            }
            return "";
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            throw invalidChar(read());
          case void 0:
            throw invalidChar(read());
        }
        return read();
      }
      function hexEscape() {
        var buffer2 = "";
        var c2 = peek();
        if (!util.isHexDigit(c2)) {
          throw invalidChar(read());
        }
        buffer2 += read();
        c2 = peek();
        if (!util.isHexDigit(c2)) {
          throw invalidChar(read());
        }
        buffer2 += read();
        return String.fromCodePoint(parseInt(buffer2, 16));
      }
      function unicodeEscape() {
        var buffer2 = "";
        var count = 4;
        while (count-- > 0) {
          var c2 = peek();
          if (!util.isHexDigit(c2)) {
            throw invalidChar(read());
          }
          buffer2 += read();
        }
        return String.fromCodePoint(parseInt(buffer2, 16));
      }
      var parseStates = {
        start: function start() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          push();
        },
        beforePropertyName: function beforePropertyName() {
          switch (token.type) {
            case "identifier":
            case "string":
              key = token.value;
              parseState = "afterPropertyName";
              return;
            case "punctuator":
              pop();
              return;
            case "eof":
              throw invalidEOF();
          }
        },
        afterPropertyName: function afterPropertyName() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          parseState = "beforePropertyValue";
        },
        beforePropertyValue: function beforePropertyValue() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          push();
        },
        beforeArrayValue: function beforeArrayValue() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          if (token.type === "punctuator" && token.value === "]") {
            pop();
            return;
          }
          push();
        },
        afterPropertyValue: function afterPropertyValue() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          switch (token.value) {
            case ",":
              parseState = "beforePropertyName";
              return;
            case "}":
              pop();
          }
        },
        afterArrayValue: function afterArrayValue() {
          if (token.type === "eof") {
            throw invalidEOF();
          }
          switch (token.value) {
            case ",":
              parseState = "beforeArrayValue";
              return;
            case "]":
              pop();
          }
        },
        end: function end() {
        }
      };
      function push() {
        var value;
        switch (token.type) {
          case "punctuator":
            switch (token.value) {
              case "{":
                value = {};
                break;
              case "[":
                value = [];
                break;
            }
            break;
          case "null":
          case "boolean":
          case "numeric":
          case "string":
            value = token.value;
            break;
        }
        if (root === void 0) {
          root = value;
        } else {
          var parent = stack[stack.length - 1];
          if (Array.isArray(parent)) {
            parent.push(value);
          } else {
            Object.defineProperty(parent, key, {
              value,
              writable: true,
              enumerable: true,
              configurable: true
            });
          }
        }
        if (value !== null && typeof value === "object") {
          stack.push(value);
          if (Array.isArray(value)) {
            parseState = "beforeArrayValue";
          } else {
            parseState = "beforePropertyName";
          }
        } else {
          var current = stack[stack.length - 1];
          if (current == null) {
            parseState = "end";
          } else if (Array.isArray(current)) {
            parseState = "afterArrayValue";
          } else {
            parseState = "afterPropertyValue";
          }
        }
      }
      function pop() {
        stack.pop();
        var current = stack[stack.length - 1];
        if (current == null) {
          parseState = "end";
        } else if (Array.isArray(current)) {
          parseState = "afterArrayValue";
        } else {
          parseState = "afterPropertyValue";
        }
      }
      function invalidChar(c2) {
        if (c2 === void 0) {
          return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
        }
        return syntaxError("JSON5: invalid character '" + formatChar(c2) + "' at " + line + ":" + column);
      }
      function invalidEOF() {
        return syntaxError("JSON5: invalid end of input at " + line + ":" + column);
      }
      function invalidIdentifier() {
        column -= 5;
        return syntaxError("JSON5: invalid identifier character at " + line + ":" + column);
      }
      function separatorChar(c2) {
      }
      function formatChar(c2) {
        var replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        };
        if (replacements[c2]) {
          return replacements[c2];
        }
        if (c2 < " ") {
          var hexString = c2.charCodeAt(0).toString(16);
          return "\\x" + ("00" + hexString).substring(hexString.length);
        }
        return c2;
      }
      function syntaxError(message) {
        var err = new SyntaxError(message);
        err.lineNumber = line;
        err.columnNumber = column;
        return err;
      }
      var stringify = function stringify2(value, replacer, space) {
        var stack2 = [];
        var indent = "";
        var propertyList;
        var replacerFunc;
        var gap = "";
        var quote;
        if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
          space = replacer.space;
          quote = replacer.quote;
          replacer = replacer.replacer;
        }
        if (typeof replacer === "function") {
          replacerFunc = replacer;
        } else if (Array.isArray(replacer)) {
          propertyList = [];
          for (var i = 0, list = replacer; i < list.length; i += 1) {
            var v = list[i];
            var item = void 0;
            if (typeof v === "string") {
              item = v;
            } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
              item = String(v);
            }
            if (item !== void 0 && propertyList.indexOf(item) < 0) {
              propertyList.push(item);
            }
          }
        }
        if (space instanceof Number) {
          space = Number(space);
        } else if (space instanceof String) {
          space = String(space);
        }
        if (typeof space === "number") {
          if (space > 0) {
            space = Math.min(10, Math.floor(space));
            gap = "          ".substr(0, space);
          }
        } else if (typeof space === "string") {
          gap = space.substr(0, 10);
        }
        return serializeProperty("", { "": value });
        function serializeProperty(key2, holder) {
          var value2 = holder[key2];
          if (value2 != null) {
            if (typeof value2.toJSON5 === "function") {
              value2 = value2.toJSON5(key2);
            } else if (typeof value2.toJSON === "function") {
              value2 = value2.toJSON(key2);
            }
          }
          if (replacerFunc) {
            value2 = replacerFunc.call(holder, key2, value2);
          }
          if (value2 instanceof Number) {
            value2 = Number(value2);
          } else if (value2 instanceof String) {
            value2 = String(value2);
          } else if (value2 instanceof Boolean) {
            value2 = value2.valueOf();
          }
          switch (value2) {
            case null:
              return "null";
            case true:
              return "true";
            case false:
              return "false";
          }
          if (typeof value2 === "string") {
            return quoteString(value2, false);
          }
          if (typeof value2 === "number") {
            return String(value2);
          }
          if (typeof value2 === "object") {
            return Array.isArray(value2) ? serializeArray(value2) : serializeObject(value2);
          }
          return void 0;
        }
        function quoteString(value2) {
          var quotes = {
            "'": 0.1,
            '"': 0.2
          };
          var replacements = {
            "'": "\\'",
            '"': '\\"',
            "\\": "\\\\",
            "\b": "\\b",
            "\f": "\\f",
            "\n": "\\n",
            "\r": "\\r",
            "	": "\\t",
            "\v": "\\v",
            "\0": "\\0",
            "\u2028": "\\u2028",
            "\u2029": "\\u2029"
          };
          var product = "";
          for (var i2 = 0; i2 < value2.length; i2++) {
            var c2 = value2[i2];
            switch (c2) {
              case "'":
              case '"':
                quotes[c2]++;
                product += c2;
                continue;
              case "\0":
                if (util.isDigit(value2[i2 + 1])) {
                  product += "\\x00";
                  continue;
                }
            }
            if (replacements[c2]) {
              product += replacements[c2];
              continue;
            }
            if (c2 < " ") {
              var hexString = c2.charCodeAt(0).toString(16);
              product += "\\x" + ("00" + hexString).substring(hexString.length);
              continue;
            }
            product += c2;
          }
          var quoteChar = quote || Object.keys(quotes).reduce(function(a, b) {
            return quotes[a] < quotes[b] ? a : b;
          });
          product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
          return quoteChar + product + quoteChar;
        }
        function serializeObject(value2) {
          if (stack2.indexOf(value2) >= 0) {
            throw TypeError("Converting circular structure to JSON5");
          }
          stack2.push(value2);
          var stepback = indent;
          indent = indent + gap;
          var keys = propertyList || Object.keys(value2);
          var partial = [];
          for (var i2 = 0, list2 = keys; i2 < list2.length; i2 += 1) {
            var key2 = list2[i2];
            var propertyString = serializeProperty(key2, value2);
            if (propertyString !== void 0) {
              var member = serializeKey(key2) + ":";
              if (gap !== "") {
                member += " ";
              }
              member += propertyString;
              partial.push(member);
            }
          }
          var final;
          if (partial.length === 0) {
            final = "{}";
          } else {
            var properties;
            if (gap === "") {
              properties = partial.join(",");
              final = "{" + properties + "}";
            } else {
              var separator = ",\n" + indent;
              properties = partial.join(separator);
              final = "{\n" + indent + properties + ",\n" + stepback + "}";
            }
          }
          stack2.pop();
          indent = stepback;
          return final;
        }
        function serializeKey(key2) {
          if (key2.length === 0) {
            return quoteString(key2, true);
          }
          var firstChar = String.fromCodePoint(key2.codePointAt(0));
          if (!util.isIdStartChar(firstChar)) {
            return quoteString(key2, true);
          }
          for (var i2 = firstChar.length; i2 < key2.length; i2++) {
            if (!util.isIdContinueChar(String.fromCodePoint(key2.codePointAt(i2)))) {
              return quoteString(key2, true);
            }
          }
          return key2;
        }
        function serializeArray(value2) {
          if (stack2.indexOf(value2) >= 0) {
            throw TypeError("Converting circular structure to JSON5");
          }
          stack2.push(value2);
          var stepback = indent;
          indent = indent + gap;
          var partial = [];
          for (var i2 = 0; i2 < value2.length; i2++) {
            var propertyString = serializeProperty(String(i2), value2);
            partial.push(propertyString !== void 0 ? propertyString : "null");
          }
          var final;
          if (partial.length === 0) {
            final = "[]";
          } else {
            if (gap === "") {
              var properties = partial.join(",");
              final = "[" + properties + "]";
            } else {
              var separator = ",\n" + indent;
              var properties$1 = partial.join(separator);
              final = "[\n" + indent + properties$1 + ",\n" + stepback + "]";
            }
          }
          stack2.pop();
          indent = stepback;
          return final;
        }
      };
      var JSON54 = {
        parse,
        stringify
      };
      var lib = JSON54;
      var es5 = lib;
      return es5;
    });
  }
});

// node_modules/markdown-it/node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/markdown-it/node_modules/entities/lib/maps/entities.json"(exports, module) {
    module.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// node_modules/markdown-it/lib/common/entities.js
var require_entities2 = __commonJS({
  "node_modules/markdown-it/lib/common/entities.js"(exports, module) {
    "use strict";
    module.exports = require_entities();
  }
});

// node_modules/uc.micro/categories/P/regex.js
var require_regex = __commonJS({
  "node_modules/uc.micro/categories/P/regex.js"(exports, module) {
    module.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});

// node_modules/mdurl/encode.js
var require_encode = __commonJS({
  "node_modules/mdurl/encode.js"(exports, module) {
    "use strict";
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i, ch, cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i = 0; i < exclude.length; i++) {
        cache[exclude.charCodeAt(i)] = exclude[i];
      }
      return cache;
    }
    function encode3(string, exclude, keepEscaped) {
      var i, l, code, nextCode, cache, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode3.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache(exclude);
      for (i = 0, l = string.length; i < l; i++) {
        code = string.charCodeAt(i);
        if (keepEscaped && code === 37 && i + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
            result += string.slice(i, i + 3);
            i += 2;
            continue;
          }
        }
        if (code < 128) {
          result += cache[code];
          continue;
        }
        if (code >= 55296 && code <= 57343) {
          if (code >= 55296 && code <= 56319 && i + 1 < l) {
            nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i] + string[i + 1]);
              i++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i]);
      }
      return result;
    }
    encode3.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode3.componentChars = "-_.!~*'()";
    module.exports = encode3;
  }
});

// node_modules/mdurl/decode.js
var require_decode = __commonJS({
  "node_modules/mdurl/decode.js"(exports, module) {
    "use strict";
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i, ch, cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        cache.push(ch);
      }
      for (i = 0; i < exclude.length; i++) {
        ch = exclude.charCodeAt(i);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode(string, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode.defaultChars;
      }
      cache = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i, l, b1, b2, b3, b4, chr, result = "";
        for (i = 0, l = seq.length; i < l; i += 3) {
          b1 = parseInt(seq.slice(i + 1, i + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i + 3 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i + 6 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "\uFFFD\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i + 9 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            b4 = parseInt(seq.slice(i + 10, i + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "\uFFFD\uFFFD\uFFFD\uFFFD";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i += 9;
              continue;
            }
          }
          result += "\uFFFD";
        }
        return result;
      });
    }
    decode.defaultChars = ";/?:@&=+$,#";
    decode.componentChars = "";
    module.exports = decode;
  }
});

// node_modules/mdurl/format.js
var require_format = __commonJS({
  "node_modules/mdurl/format.js"(exports, module) {
    "use strict";
    module.exports = function format(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
  }
});

// node_modules/mdurl/parse.js
var require_parse = __commonJS({
  "node_modules/mdurl/parse.js"(exports, module) {
    "use strict";
    function Url2() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url2) {
        return url;
      }
      var u = new Url2();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url2.prototype.parse = function(url, slashesDenoteHost) {
      var i, l, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i = 0; i < hostEndingChars.length; i++) {
          hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i = 0; i < nonHostChars.length; i++) {
          hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url2.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module.exports = urlParse;
  }
});

// node_modules/mdurl/index.js
var require_mdurl = __commonJS({
  "node_modules/mdurl/index.js"(exports, module) {
    "use strict";
    module.exports.encode = require_encode();
    module.exports.decode = require_decode();
    module.exports.format = require_format();
    module.exports.parse = require_parse();
  }
});

// node_modules/uc.micro/properties/Any/regex.js
var require_regex2 = __commonJS({
  "node_modules/uc.micro/properties/Any/regex.js"(exports, module) {
    module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});

// node_modules/uc.micro/categories/Cc/regex.js
var require_regex3 = __commonJS({
  "node_modules/uc.micro/categories/Cc/regex.js"(exports, module) {
    module.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});

// node_modules/uc.micro/categories/Cf/regex.js
var require_regex4 = __commonJS({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports, module) {
    module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});

// node_modules/uc.micro/categories/Z/regex.js
var require_regex5 = __commonJS({
  "node_modules/uc.micro/categories/Z/regex.js"(exports, module) {
    module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});

// node_modules/uc.micro/index.js
var require_uc = __commonJS({
  "node_modules/uc.micro/index.js"(exports) {
    "use strict";
    exports.Any = require_regex2();
    exports.Cc = require_regex3();
    exports.Cf = require_regex4();
    exports.P = require_regex();
    exports.Z = require_regex5();
  }
});

// node_modules/markdown-it/lib/common/utils.js
var require_utils = __commonJS({
  "node_modules/markdown-it/lib/common/utils.js"(exports) {
    "use strict";
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    }
    function assign2(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode2(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint3(c) {
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE2 = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))$/i;
    var entities2 = require_entities2();
    function replaceEntityPattern2(match, name) {
      var code;
      if (has(entities2, name)) {
        return entities2[name];
      }
      if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE2.test(name)) {
        code = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
        if (isValidEntityCode2(code)) {
          return fromCodePoint3(code);
        }
      }
      return match;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern2(match, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace3(code) {
      switch (code) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code) {
      if (code >= 8192 && code <= 8202) {
        return true;
      }
      switch (code) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("\u1E9E".toLowerCase() === "\u1E7E") {
        str = str.replace(/ẞ/g, "\xDF");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign2;
    exports.isString = isString;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode2;
    exports.fromCodePoint = fromCodePoint3;
    exports.escapeHtml = escapeHtml;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace3;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module) {
    "use strict";
    module.exports = function parseLinkLabel(state, start, disableNested) {
      var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkDestination(str, start, max) {
      var code, level, pos = start, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code = str.charCodeAt(pos);
          if (code === 10) {
            return result;
          }
          if (code === 60) {
            return result;
          }
          if (code === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 32) {
          break;
        }
        if (code < 32 || code === 127) {
          break;
        }
        if (code === 92 && pos + 1 < max) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str.slice(start, pos));
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module) {
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkTitle(str, start, max) {
      var code, marker, lines = 0, pos = start, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max) {
        return result;
      }
      marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code === 40 && marker === 41) {
          return result;
        } else if (code === 10) {
          lines++;
        } else if (code === 92 && pos + 1 < max) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/markdown-it/lib/helpers/index.js"(exports) {
    "use strict";
    exports.parseLinkLabel = require_parse_link_label();
    exports.parseLinkDestination = require_parse_link_destination();
    exports.parseLinkTitle = require_parse_link_title();
  }
});

// node_modules/markdown-it/lib/renderer.js
var require_renderer = __commonJS({
  "node_modules/markdown-it/lib/renderer.js"(exports, module) {
    "use strict";
    var assign2 = require_utils().assign;
    var unescapeAll = require_utils().unescapeAll;
    var escapeHtml = require_utils().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(token.content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options.highlight) {
        highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
      } else {
        highlighted = escapeHtml(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i] = tmpAttrs[i].slice();
          tmpAttrs[i][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign2({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i, l, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i = 0, l = token.attrs.length; i < l; i++) {
        result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken, result = "", needLf = false, token = tokens[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens, options, env) {
      var type, result = "", rules = this.rules;
      for (var i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
      var result = "";
      for (var i = 0, len = tokens.length; i < len; i++) {
        if (tokens[i].type === "text") {
          result += tokens[i].content;
        } else if (tokens[i].type === "image") {
          result += this.renderInlineAsText(tokens[i].children, options, env);
        } else if (tokens[i].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens, options, env) {
      var i, len, type, result = "", rules = this.rules;
      for (i = 0, len = tokens.length; i < len; i++) {
        type = tokens[i].type;
        if (type === "inline") {
          result += this.renderInline(tokens[i].children, options, env);
        } else if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options, env);
        }
      }
      return result;
    };
    module.exports = Renderer;
  }
});

// node_modules/markdown-it/lib/ruler.js
var require_ruler = __commonJS({
  "node_modules/markdown-it/lib/ruler.js"(exports, module) {
    "use strict";
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name) {
      for (var i = 0; i < this.__rules__.length; i++) {
        if (this.__rules__[i].name === name) {
          return i;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name, fn, options) {
      var index = this.__find__(name);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
      var index = this.__find__(beforeName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn, options) {
      var index = this.__find__(afterName);
      var opt = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn, options) {
      var opt = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list, ignoreInvalid) {
      if (!Array.isArray(list)) {
        list = [list];
      }
      var result = [];
      list.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module.exports = Ruler;
  }
});

// node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize = __commonJS({
  "node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module) {
    "use strict";
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module.exports = function normalize(state) {
      var str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "\uFFFD");
      state.src = str;
    };
  }
});

// node_modules/markdown-it/lib/rules_core/block.js
var require_block = __commonJS({
  "node_modules/markdown-it/lib/rules_core/block.js"(exports, module) {
    "use strict";
    module.exports = function block(state) {
      var token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/inline.js
var require_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_core/inline.js"(exports, module) {
    "use strict";
    module.exports = function inline(state) {
      var tokens = state.tokens, tok, i, l;
      for (i = 0, l = tokens.length; i < l; i++) {
        tok = tokens[i];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify = __commonJS({
  "node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module) {
    "use strict";
    var arrayReplaceAt = require_utils().arrayReplaceAt;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    module.exports = function linkify(state) {
      var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i = tokens.length - 1; i >= 0; i--) {
          currentToken = tokens[i];
          if (currentToken.type === "link_close") {
            i--;
            while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
              i--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text = currentToken.content;
            links = state.md.linkify.match(text);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === "text_special") {
              links = links.slice(1);
            }
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token = new state.Token("text", "", 0);
                token.content = text.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              token = new state.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state.Token("text", "", 0);
              token.content = urlText;
              token.level = level;
              nodes.push(token);
              token = new state.Token("link_close", "a", -1);
              token.level = --level;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text.length) {
              token = new state.Token("text", "", 0);
              token.content = text.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
          }
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements = __commonJS({
  "node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module) {
    "use strict";
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
    var SCOPED_ABBR = {
      c: "\xA9",
      r: "\xAE",
      tm: "\u2122"
    };
    function replaceFn(match, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module.exports = function replace(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes = __commonJS({
  "node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module) {
    "use strict";
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE2 = "\u2019";
    function replaceAt(str, index, ch) {
      return str.slice(0, index) + ch + str.slice(index + 1);
    }
    function process_inlines(tokens, state) {
      var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        thisLevel = tokens[i].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text = token.content;
        pos = 0;
        max = text.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE.lastIndex = pos;
            t = QUOTE_RE.exec(text);
            if (!t) {
              break;
            }
            canOpen = canClose = true;
            pos = t.index + 1;
            isSingle = t[0] === "'";
            lastChar = 32;
            if (t.index - 1 >= 0) {
              lastChar = text.charCodeAt(t.index - 1);
            } else {
              for (j = i - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max) {
              nextChar = text.charCodeAt(pos);
            } else {
              for (j = i + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt(token.content, t.index, APOSTROPHE2);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack[j].level === thisLevel) {
                  item = stack[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token.content = replaceAt(token.content, t.index, closeQuote);
                  tokens[item.token].content = replaceAt(
                    tokens[item.token].content,
                    item.pos,
                    openQuote
                  );
                  pos += closeQuote.length - 1;
                  if (item.token === i) {
                    pos += openQuote.length - 1;
                  }
                  text = token.content;
                  max = text.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i,
                pos: t.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt(token.content, t.index, APOSTROPHE2);
            }
          }
      }
    }
    module.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/text_join.js
var require_text_join = __commonJS({
  "node_modules/markdown-it/lib/rules_core/text_join.js"(exports, module) {
    "use strict";
    module.exports = function text_join(state) {
      var j, l, tokens, curr, max, last2, blockTokens = state.tokens;
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline")
          continue;
        tokens = blockTokens[j].children;
        max = tokens.length;
        for (curr = 0; curr < max; curr++) {
          if (tokens[curr].type === "text_special") {
            tokens[curr].type = "text";
          }
        }
        for (curr = last2 = 0; curr < max; curr++) {
          if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last2) {
              tokens[last2] = tokens[curr];
            }
            last2++;
          }
        }
        if (curr !== last2) {
          tokens.length = last2;
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/token.js
var require_token = __commonJS({
  "node_modules/markdown-it/lib/token.js"(exports, module) {
    "use strict";
    function Token(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token.prototype.attrIndex = function attrIndex(name) {
      var attrs, i, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i = 0, len = attrs.length; i < len; i++) {
        if (attrs[i][0] === name) {
          return i;
        }
      }
      return -1;
    };
    Token.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token.prototype.attrSet = function attrSet(name, value) {
      var idx = this.attrIndex(name), attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token.prototype.attrGet = function attrGet(name) {
      var idx = this.attrIndex(name), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token.prototype.attrJoin = function attrJoin(name, value) {
      var idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    module.exports = Token;
  }
});

// node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core = __commonJS({
  "node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module) {
    "use strict";
    var Token = require_token();
    function StateCore(src, md, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token;
    module.exports = StateCore;
  }
});

// node_modules/markdown-it/lib/parser_core.js
var require_parser_core = __commonJS({
  "node_modules/markdown-it/lib/parser_core.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()],
      // `text_join` finds `text_special` tokens (for escape sequences)
      // and joins them with the rest of the text
      ["text_join", require_text_join()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i, l, rules;
      rules = this.ruler.getRules("");
      for (i = 0, l = rules.length; i < l; i++) {
        rules[i](state);
      }
    };
    Core.prototype.State = require_state_core();
    module.exports = Core;
  }
});

// node_modules/markdown-it/lib/rules_block/table.js
var require_table = __commonJS({
  "node_modules/markdown-it/lib/rules_block/table.js"(exports, module) {
    "use strict";
    var isSpace3 = require_utils().isSpace;
    function getLine(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
      return state.src.slice(pos, max);
    }
    function escapedSplit(str) {
      var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = "";
      ch = str.charCodeAt(pos);
      while (pos < max) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current + str.substring(lastPos));
      return result;
    }
    module.exports = function table(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, l, nextLine, columns, columnCount, token, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace3(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace3(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace3(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t = columns[i].trim();
        if (!t) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i = 0; i < columns.length; i++) {
        token = state.push("th_open", "th", 1);
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i].trim();
        token.children = [];
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token = state.push("tbody_open", "tbody", 1);
          token.map = tbodyLines = [startLine + 2, 0];
        }
        token = state.push("tr_open", "tr", 1);
        token.map = [nextLine, nextLine + 1];
        for (i = 0; i < columnCount; i++) {
          token = state.push("td_open", "td", 1);
          if (aligns[i]) {
            token.attrs = [["style", "text-align:" + aligns[i]]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i] ? columns[i].trim() : "";
          token.children = [];
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/code.js
var require_code = __commonJS({
  "node_modules/markdown-it/lib/rules_block/code.js"(exports, module) {
    "use strict";
    module.exports = function code(state, startLine, endLine) {
      var nextLine, last2, token;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last2 = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last2 = nextLine;
          continue;
        }
        break;
      }
      state.line = last2;
      token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last2, 4 + state.blkIndent, false) + "\n";
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/fence.js
var require_fence = __commonJS({
  "node_modules/markdown-it/lib/rules_block/fence.js"(exports, module) {
    "use strict";
    module.exports = function fence(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote = __commonJS({
  "node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module) {
    "use strict";
    var isSpace3 = require_utils().isSpace;
    module.exports = function blockquote(state, startLine, endLine, silent) {
      var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldBMarks = [];
      oldBSCount = [];
      oldSCount = [];
      oldTShift = [];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + initial) % 4 === 3) {
              pos++;
              initial++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          offset = initial;
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (isSpace3(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token = state.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token = state.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i = 0; i < oldTShift.length; i++) {
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
        state.sCount[i + startLine] = oldSCount[i];
        state.bsCount[i + startLine] = oldBSCount[i];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/hr.js
var require_hr = __commonJS({
  "node_modules/markdown-it/lib/rules_block/hr.js"(exports, module) {
    "use strict";
    var isSpace3 = require_utils().isSpace;
    module.exports = function hr(state, startLine, endLine, silent) {
      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace3(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/list.js
var require_list = __commonJS({
  "node_modules/markdown-it/lib/rules_block/list.js"(exports, module) {
    "use strict";
    var isSpace3 = require_utils().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace3(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
      if (pos + 1 >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace3(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i, l, level = state.level + 2;
      for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
          state.tokens[i + 2].hidden = true;
          state.tokens[i].hidden = true;
          i += 2;
        }
      }
    }
    module.exports = function list(state, startLine, endLine, silent) {
      var ch, contentStart, i, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, nextLine = startLine, isTerminatingParagraph = false, tight = true;
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[nextLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[nextLine] + state.tShift[nextLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine])
          return false;
      }
      if (silent) {
        return true;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [nextLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [nextLine, 0];
        if (isOrdered) {
          token.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[nextLine];
        oldSCount = state.sCount[nextLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[nextLine] = contentStart - state.bMarks[nextLine];
        state.sCount[nextLine] = offset;
        if (contentStart >= max && state.isEmpty(nextLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, nextLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[nextLine] = oldTShift;
        state.sCount[nextLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = state.line;
        itemLines[1] = nextLine;
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/reference.js
var require_reference = __commonJS({
  "node_modules/markdown-it/lib/rules_block/reference.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace3 = require_utils().isSpace;
    module.exports = function reference(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str.length;
      for (pos = 1; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace3(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace3(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace3(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str.charCodeAt(pos);
            if (!isSpace3(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks = __commonJS({
  "node_modules/markdown-it/lib/common/html_blocks.js"(exports, module) {
    "use strict";
    module.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});

// node_modules/markdown-it/lib/common/html_re.js
var require_html_re = __commonJS({
  "node_modules/markdown-it/lib/common/html_re.js"(exports, module) {
    "use strict";
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module.exports.HTML_TAG_RE = HTML_TAG_RE;
    module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});

// node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module) {
    "use strict";
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    module.exports = function html_block(state, startLine, endLine, silent) {
      var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i = 0; i < HTML_SEQUENCES.length; i++) {
        if (HTML_SEQUENCES[i][0].test(lineText)) {
          break;
        }
      }
      if (i === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/heading.js
var require_heading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/heading.js"(exports, module) {
    "use strict";
    var isSpace3 = require_utils().isSpace;
    module.exports = function heading(state, startLine, endLine, silent) {
      var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max && !isSpace3(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace3(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = "########".slice(0, level);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = state.src.slice(pos, max).trim();
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = "########".slice(0, level);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module) {
    "use strict";
    module.exports = function lheading(state, startLine, endLine) {
      var content, terminate, i, l, token, pos, max, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph = __commonJS({
  "node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module) {
    "use strict";
    module.exports = function paragraph(state, startLine, endLine) {
      var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph");
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token = state.push("paragraph_open", "p", 1);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module) {
    "use strict";
    var Token = require_token();
    var isSpace3 = require_utils().isSpace;
    function StateBlock(src, md, env, tokens) {
      var ch, s, start, pos, len, indent, offset, indent_found;
      this.src = src;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s = this.src;
      indent_found = false;
      for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
        ch = s.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace3(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type, tag, nesting) {
      var token = new Token(type, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace3(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace3(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i, lineIndent, ch, first, last2, queue, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i = 0; line < end; line++, i++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last2 = this.eMarks[line] + 1;
        } else {
          last2 = this.eMarks[line];
        }
        while (first < last2 && lineIndent < indent) {
          ch = this.src.charCodeAt(first);
          if (isSpace3(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue[i] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last2);
        } else {
          queue[i] = this.src.slice(first, last2);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token;
    module.exports = StateBlock;
  }
});

// node_modules/markdown-it/lib/parser_block.js
var require_parser_block = __commonJS({
  "node_modules/markdown-it/lib/parser_block.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      // First 2 params - rule name & source. Secondary array - list of rules,
      // which can be terminated by this one.
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["paragraph", require_paragraph()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i, prevLine, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        prevLine = state.line;
        for (i = 0; i < len; i++) {
          ok = rules[i](state, line, endLine, false);
          if (ok) {
            if (prevLine >= state.line) {
              throw new Error("block rule didn't increment state.line");
            }
            break;
          }
        }
        if (!ok)
          throw new Error("none of the block rules matched");
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module.exports = ParserBlock;
  }
});

// node_modules/markdown-it/lib/rules_inline/text.js
var require_text = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text.js"(exports, module) {
    "use strict";
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module.exports = function text(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/linkify.js
var require_linkify2 = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/linkify.js"(exports, module) {
    "use strict";
    var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
    module.exports = function linkify(state, silent) {
      var pos, max, match, proto, link, url, fullUrl, token;
      if (!state.md.options.linkify)
        return false;
      if (state.linkLevel > 0)
        return false;
      pos = state.pos;
      max = state.posMax;
      if (pos + 3 > max)
        return false;
      if (state.src.charCodeAt(pos) !== 58)
        return false;
      if (state.src.charCodeAt(pos + 1) !== 47)
        return false;
      if (state.src.charCodeAt(pos + 2) !== 47)
        return false;
      match = state.pending.match(SCHEME_RE);
      if (!match)
        return false;
      proto = match[1];
      link = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
      if (!link)
        return false;
      url = link.url;
      if (url.length <= proto.length)
        return false;
      url = url.replace(/\*+$/, "");
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl))
        return false;
      if (!silent) {
        state.pending = state.pending.slice(0, -proto.length);
        token = state.push("link_open", "a", 1);
        token.attrs = [["href", fullUrl]];
        token.markup = "linkify";
        token.info = "auto";
        token = state.push("text", "", 0);
        token.content = state.md.normalizeLinkText(url);
        token = state.push("link_close", "a", -1);
        token.markup = "linkify";
        token.info = "auto";
      }
      state.pos += url.length - proto.length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module) {
    "use strict";
    var isSpace3 = require_utils().isSpace;
    module.exports = function newline(state, silent) {
      var pmax, max, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace3(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module) {
    "use strict";
    var isSpace3 = require_utils().isSpace;
    var ESCAPED = [];
    for (i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    var i;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module.exports = function escape(state, silent) {
      var ch1, ch2, origStr, escapedStr, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92)
        return false;
      pos++;
      if (pos >= max)
        return false;
      ch1 = state.src.charCodeAt(pos);
      if (ch1 === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max) {
          ch1 = state.src.charCodeAt(pos);
          if (!isSpace3(ch1))
            break;
          pos++;
        }
        state.pos = pos;
        return true;
      }
      escapedStr = state.src[pos];
      if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
        ch2 = state.src.charCodeAt(pos + 1);
        if (ch2 >= 56320 && ch2 <= 57343) {
          escapedStr += state.src[pos + 1];
          pos++;
        }
      }
      origStr = "\\" + escapedStr;
      if (!silent) {
        token = state.push("text_special", "", 0);
        if (ch1 < 256 && ESCAPED[ch1] !== 0) {
          token.content = escapedStr;
        } else {
          token.content = origStr;
        }
        token.markup = origStr;
        token.info = "escape";
      }
      state.pos = pos + 1;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module) {
    "use strict";
    module.exports = function backtick(state, silent) {
      var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start, pos);
      openerLength = marker.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker;
        state.pos += openerLength;
        return true;
      }
      matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module) {
    "use strict";
    module.exports.tokenize = function strikethrough(state, silent) {
      var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i = 0; i < len; i += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          // disable "rule of 3" length checks meant for emphasis
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess2(state, delimiters) {
      var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
      for (i = 0; i < max; i++) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i = loneMarkers.pop();
        j = i + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    module.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess2(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess2(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module) {
    "use strict";
    module.exports.tokenize = function emphasis(state, silent) {
      var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i = 0; i < scanned.length; i++) {
        token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          // Char code of the starting marker (number).
          //
          marker,
          // Total length of these series of delimiters.
          //
          length: scanned.length,
          // A position of the token this delimiter corresponds to.
          //
          token: state.tokens.length - 1,
          // If this delimiter is matched as a valid opener, `end` will be
          // equal to its position, otherwise it's `-1`.
          //
          end: -1,
          // Boolean flags that determine if this delimiter could open or close
          // an emphasis.
          //
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess2(state, delimiters) {
      var i, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;
      for (i = max - 1; i >= 0; i--) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && // check that first two markers match and adjacent
        delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && // check that last two markers are adjacent (we can safely assume they match)
        delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token = state.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state.tokens[delimiters[i - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i--;
        }
      }
    }
    module.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess2(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess2(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/link.js
var require_link = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/link.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace3 = require_utils().isSpace;
    module.exports = function link(state, silent) {
      var attrs, code, label, labelEnd, labelStart, pos, res, ref, token, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace3(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace3(code) && code !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code = state.src.charCodeAt(pos);
              if (!isSpace3(code) && code !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.linkLevel++;
        state.md.inline.tokenize(state);
        state.linkLevel--;
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/image.js
var require_image = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/image.js"(exports, module) {
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace3 = require_utils().isSpace;
    module.exports = function image(state, silent) {
      var attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace3(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace3(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace3(code) && code !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(
          content,
          state.md,
          state.env,
          tokens = []
        );
        token = state.push("image", "img", 0);
        token.attrs = attrs = [["src", href], ["alt", ""]];
        token.children = tokens;
        token.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module) {
    "use strict";
    var EMAIL_RE2 = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE2 = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    module.exports = function autolink(state, silent) {
      var url, fullUrl, token, ch, start, max, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max = state.posMax;
      for (; ; ) {
        if (++pos >= max)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE2.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE2.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module) {
    "use strict";
    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module.exports = function html_inline(state, silent) {
      var ch, match, max, token, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        token = state.push("html_inline", "", 0);
        token.content = match[0];
        if (isLinkOpen(token.content))
          state.linkLevel++;
        if (isLinkClose(token.content))
          state.linkLevel--;
      }
      state.pos += match[0].length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module) {
    "use strict";
    var entities2 = require_entities2();
    var has = require_utils().has;
    var isValidEntityCode2 = require_utils().isValidEntityCode;
    var fromCodePoint3 = require_utils().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module.exports = function entity(state, silent) {
      var ch, code, match, token, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38)
        return false;
      if (pos + 1 >= max)
        return false;
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            token = state.push("text_special", "", 0);
            token.content = isValidEntityCode2(code) ? fromCodePoint3(code) : fromCodePoint3(65533);
            token.markup = match[0];
            token.info = "entity";
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          if (has(entities2, match[1])) {
            if (!silent) {
              token = state.push("text_special", "", 0);
              token.content = entities2[match[1]];
              token.markup = match[0];
              token.info = "entity";
            }
            state.pos += match[0].length;
            return true;
          }
        }
      }
      return false;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module) {
    "use strict";
    function processDelimiters(delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
      if (!max)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module.exports = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      processDelimiters(state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/fragments_join.js
var require_fragments_join = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/fragments_join.js"(exports, module) {
    "use strict";
    module.exports = function fragments_join(state) {
      var curr, last2, level = 0, tokens = state.tokens, max = state.tokens.length;
      for (curr = last2 = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last2) {
            tokens[last2] = tokens[curr];
          }
          last2++;
        }
      }
      if (curr !== last2) {
        tokens.length = last2;
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module) {
    "use strict";
    var Token = require_token();
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    function StateInline(src, md, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
      this.linkLevel = 0;
    }
    StateInline.prototype.pushPending = function() {
      var token = new Token("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function(type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token(type, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token;
    module.exports = StateInline;
  }
});

// node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline = __commonJS({
  "node_modules/markdown-it/lib/parser_inline.js"(exports, module) {
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["text", require_text()],
      ["linkify", require_linkify2()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link()],
      ["image", require_image()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      // rules for pairs separate '**' into its own text tokens, which may be left unused,
      // rule below merges unused segments back with the rest of the text
      ["fragments_join", require_fragments_join()]
    ];
    function ParserInline() {
      var i;
      this.ruler = new Ruler();
      for (i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
      this.ruler2 = new Ruler();
      for (i = 0; i < _rules2.length; i++) {
        this.ruler2.push(_rules2[i][0], _rules2[i][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          state.level++;
          ok = rules[i](state, true);
          state.level--;
          if (ok) {
            if (pos >= state.pos) {
              throw new Error("inline rule didn't increment state.pos");
            }
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      var ok, i, prevPos, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        prevPos = state.pos;
        if (state.level < maxNesting) {
          for (i = 0; i < len; i++) {
            ok = rules[i](state, false);
            if (ok) {
              if (prevPos >= state.pos) {
                throw new Error("inline rule didn't increment state.pos");
              }
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str, md, env, outTokens) {
      var i, rules, len;
      var state = new this.State(str, md, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i = 0; i < len; i++) {
        rules[i](state);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module.exports = ParserInline;
  }
});

// node_modules/linkify-it/lib/re.js
var require_re = __commonJS({
  "node_modules/linkify-it/lib/re.js"(exports, module) {
    "use strict";
    module.exports = function(opts) {
      var re = {};
      opts = opts || {};
      re.src_Any = require_regex2().source;
      re.src_Cc = require_regex3().source;
      re.src_Z = require_regex5().source;
      re.src_P = require_regex().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><\uFF5C]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re.src_ZCc + "|$)|;(?!" + re.src_ZCc + "|$)|\\!+(?!" + re.src_ZCc + "|[!]|$)|\\?(?!" + re.src_ZCc + "|[?]|$))+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = // Allow letters & digits (http://test1)
      "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});

// node_modules/linkify-it/index.js
var require_linkify_it = __commonJS({
  "node_modules/linkify-it/index.js"(exports, module) {
    "use strict";
    function assign2(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions2 = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions2.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp(
              "^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp(
              "^" + self2.re.src_auth + // Don't allow single-level domains, because of false positives like '//test'
              // with code comments
              "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path,
              "i"
            );
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text, pos, self2) {
          var tail = text.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp(
              "^" + self2.re.src_email_name + "@" + self2.re.src_host_strict,
              "i"
            );
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text, pos) {
        var tail = text.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self2) {
        self2.normalize(match);
      };
    }
    function compile(self2) {
      var re = self2.re = require_re()(self2.__opts__);
      var tlds2 = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds2.push(tlds_2ch_src_re);
      }
      tlds2.push(re.src_xn);
      re.src_tlds = tlds2.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name) {
        var val = self2.__schemas__[name];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name] = compiled;
        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name) {
        return name.length > 0 && self2.__compiled__[name];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
      self2.re.pretest = RegExp(
        "(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@",
        "i"
      );
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start = self2.__index__, end = self2.__last_index__, text = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text;
      this.text = text;
      this.url = text;
    }
    function createMatch(self2, shift) {
      var match = new Match(self2, shift);
      self2.__compiled__[match.schema].normalize(match, self2);
      return match;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign2({}, defaultOptions2, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign2({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };
    LinkifyIt.prototype.set = function set(options) {
      this.__opts__ = assign2(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text)) !== null) {
          len = this.testSchemaAt(text, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text) {
      return this.re.pretest.test(text);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
    };
    LinkifyIt.prototype.match = function match(text) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text.slice(shift) : text;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.matchAtStart = function matchAtStart(text) {
      this.__text_cache__ = text;
      this.__index__ = -1;
      if (!text.length)
        return null;
      var m = this.re.schema_at_start.exec(text);
      if (!m)
        return null;
      var len = this.testSchemaAt(text, m[2], m[0].length);
      if (!len)
        return null;
      this.__schema__ = m[2];
      this.__index__ = m.index + m[1].length;
      this.__last_index__ = m.index + m[0].length + len;
      return createMatch(this, 0);
    };
    LinkifyIt.prototype.tlds = function tlds2(list, keepOld) {
      list = Array.isArray(list) ? list : [list];
      if (!keepOld) {
        this.__tlds__ = list.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module.exports = LinkifyIt;
  }
});

// node_modules/markdown-it/lib/presets/default.js
var require_default = __commonJS({
  "node_modules/markdown-it/lib/presets/default.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 100
        // Internal protection, recursion limit
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/zero.js
var require_zero = __commonJS({
  "node_modules/markdown-it/lib/presets/zero.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: false,
        // Enable HTML tags in source
        xhtmlOut: false,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark = __commonJS({
  "node_modules/markdown-it/lib/presets/commonmark.js"(exports, module) {
    "use strict";
    module.exports = {
      options: {
        html: true,
        // Enable HTML tags in source
        xhtmlOut: true,
        // Use '/' to close single tags (<br />)
        breaks: false,
        // Convert '\n' in paragraphs into <br>
        langPrefix: "language-",
        // CSS language prefix for fenced blocks
        linkify: false,
        // autoconvert URL-like texts to links
        // Enable some language-neutral replacements + quotes beautification
        typographer: false,
        // Double + single quotes replacement pairs, when typographer enabled,
        // and smartquotes on. Could be either a String or an Array.
        //
        // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
        // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
        quotes: "\u201C\u201D\u2018\u2019",
        /* “”‘’ */
        // Highlighter function. Should return escaped HTML,
        // or '' if the source string is not changed and should be escaped externaly.
        // If result starts with <pre... internal wrapper is skipped.
        //
        // function (/*str, lang*/) { return ''; }
        //
        highlight: null,
        maxNesting: 20
        // Internal protection, recursion limit
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "fragments_join"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/index.js
var require_lib = __commonJS({
  "node_modules/markdown-it/lib/index.js"(exports, module) {
    "use strict";
    var utils = require_utils();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it();
    var mdurl = require_mdurl();
    var punycode = __require("punycode");
    var config = {
      default: require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt2(presetName, options) {
      if (!(this instanceof MarkdownIt2)) {
        return new MarkdownIt2(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt2.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt2.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name) {
          if (presets.components[name].rules) {
            self2[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self2[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt2.prototype.enable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list, true));
      var missed = list.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt2.prototype.disable = function(list, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list)) {
        list = [list];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list, true));
      var missed = list.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt2.prototype.use = function(plugin) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };
    MarkdownIt2.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt2.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt2.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt2.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module.exports = MarkdownIt2;
  }
});

// node_modules/markdown-it-sub/index.js
var require_markdown_it_sub = __commonJS({
  "node_modules/markdown-it-sub/index.js"(exports, module) {
    "use strict";
    var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;
    function subscript2(state, silent) {
      var found, content, token, max = state.posMax, start = state.pos;
      if (state.src.charCodeAt(start) !== 126) {
        return false;
      }
      if (silent) {
        return false;
      }
      if (start + 2 >= max) {
        return false;
      }
      state.pos = start + 1;
      while (state.pos < max) {
        if (state.src.charCodeAt(state.pos) === 126) {
          found = true;
          break;
        }
        state.md.inline.skipToken(state);
      }
      if (!found || start + 1 === state.pos) {
        state.pos = start;
        return false;
      }
      content = state.src.slice(start + 1, state.pos);
      if (content.match(/(^|[^\\])(\\\\)*\s/)) {
        state.pos = start;
        return false;
      }
      state.posMax = state.pos;
      state.pos = start + 1;
      token = state.push("sub_open", "sub", 1);
      token.markup = "~";
      token = state.push("text", "", 0);
      token.content = content.replace(UNESCAPE_RE, "$1");
      token = state.push("sub_close", "sub", -1);
      token.markup = "~";
      state.pos = state.posMax + 1;
      state.posMax = max;
      return true;
    }
    module.exports = function sub_plugin(md) {
      md.inline.ruler.after("emphasis", "sub", subscript2);
    };
  }
});

// node_modules/markdown-it-sup/index.js
var require_markdown_it_sup = __commonJS({
  "node_modules/markdown-it-sup/index.js"(exports, module) {
    "use strict";
    var UNESCAPE_RE = /\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;
    function superscript2(state, silent) {
      var found, content, token, max = state.posMax, start = state.pos;
      if (state.src.charCodeAt(start) !== 94) {
        return false;
      }
      if (silent) {
        return false;
      }
      if (start + 2 >= max) {
        return false;
      }
      state.pos = start + 1;
      while (state.pos < max) {
        if (state.src.charCodeAt(state.pos) === 94) {
          found = true;
          break;
        }
        state.md.inline.skipToken(state);
      }
      if (!found || start + 1 === state.pos) {
        state.pos = start;
        return false;
      }
      content = state.src.slice(start + 1, state.pos);
      if (content.match(/(^|[^\\])(\\\\)*\s/)) {
        state.pos = start;
        return false;
      }
      state.posMax = state.pos;
      state.pos = start + 1;
      token = state.push("sup_open", "sup", 1);
      token.markup = "^";
      token = state.push("text", "", 0);
      token.content = content.replace(UNESCAPE_RE, "$1");
      token = state.push("sup_close", "sup", -1);
      token.markup = "^";
      state.pos = state.posMax + 1;
      state.posMax = max;
      return true;
    }
    module.exports = function sup_plugin(md) {
      md.inline.ruler.after("emphasis", "sup", superscript2);
    };
  }
});

// node_modules/markdown-it-mark/index.js
var require_markdown_it_mark = __commonJS({
  "node_modules/markdown-it-mark/index.js"(exports, module) {
    "use strict";
    module.exports = function ins_plugin(md) {
      function tokenize5(state, silent) {
        var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
        if (silent) {
          return false;
        }
        if (marker !== 61) {
          return false;
        }
        scanned = state.scanDelims(state.pos, true);
        len = scanned.length;
        ch = String.fromCharCode(marker);
        if (len < 2) {
          return false;
        }
        if (len % 2) {
          token = state.push("text", "", 0);
          token.content = ch;
          len--;
        }
        for (i = 0; i < len; i += 2) {
          token = state.push("text", "", 0);
          token.content = ch + ch;
          if (!scanned.can_open && !scanned.can_close) {
            continue;
          }
          state.delimiters.push({
            marker,
            length: 0,
            // disable "rule of 3" length checks meant for emphasis
            jump: i / 2,
            // 1 delimiter = 2 characters
            token: state.tokens.length - 1,
            end: -1,
            open: scanned.can_open,
            close: scanned.can_close
          });
        }
        state.pos += scanned.length;
        return true;
      }
      function postProcess2(state, delimiters) {
        var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
        for (i = 0; i < max; i++) {
          startDelim = delimiters[i];
          if (startDelim.marker !== 61) {
            continue;
          }
          if (startDelim.end === -1) {
            continue;
          }
          endDelim = delimiters[startDelim.end];
          token = state.tokens[startDelim.token];
          token.type = "mark_open";
          token.tag = "mark";
          token.nesting = 1;
          token.markup = "==";
          token.content = "";
          token = state.tokens[endDelim.token];
          token.type = "mark_close";
          token.tag = "mark";
          token.nesting = -1;
          token.markup = "==";
          token.content = "";
          if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "=") {
            loneMarkers.push(endDelim.token - 1);
          }
        }
        while (loneMarkers.length) {
          i = loneMarkers.pop();
          j = i + 1;
          while (j < state.tokens.length && state.tokens[j].type === "mark_close") {
            j++;
          }
          j--;
          if (i !== j) {
            token = state.tokens[j];
            state.tokens[j] = state.tokens[i];
            state.tokens[i] = token;
          }
        }
      }
      md.inline.ruler.before("emphasis", "mark", tokenize5);
      md.inline.ruler2.before("emphasis", "mark", function(state) {
        var curr, tokens_meta = state.tokens_meta, max = (state.tokens_meta || []).length;
        postProcess2(state, state.delimiters);
        for (curr = 0; curr < max; curr++) {
          if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
            postProcess2(state, tokens_meta[curr].delimiters);
          }
        }
      });
    };
  }
});

// node_modules/path-browserify/index.js
var require_path_browserify = __commonJS({
  "node_modules/path-browserify/index.js"(exports, module) {
    "use strict";
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError("Path must be a string. Received " + JSON.stringify(path));
      }
    }
    function normalizeStringPosix(path, allowAboveRoot) {
      var res = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var code;
      for (var i = 0; i <= path.length; ++i) {
        if (i < path.length)
          code = path.charCodeAt(i);
        else if (code === 47)
          break;
        else
          code = 47;
        if (code === 47) {
          if (lastSlash === i - 1 || dots === 1) {
          } else if (lastSlash !== i - 1 && dots === 2) {
            if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
              if (res.length > 2) {
                var lastSlashIndex = res.lastIndexOf("/");
                if (lastSlashIndex !== res.length - 1) {
                  if (lastSlashIndex === -1) {
                    res = "";
                    lastSegmentLength = 0;
                  } else {
                    res = res.slice(0, lastSlashIndex);
                    lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                  }
                  lastSlash = i;
                  dots = 0;
                  continue;
                }
              } else if (res.length === 2 || res.length === 1) {
                res = "";
                lastSegmentLength = 0;
                lastSlash = i;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              if (res.length > 0)
                res += "/..";
              else
                res = "..";
              lastSegmentLength = 2;
            }
          } else {
            if (res.length > 0)
              res += "/" + path.slice(lastSlash + 1, i);
            else
              res = path.slice(lastSlash + 1, i);
            lastSegmentLength = i - lastSlash - 1;
          }
          lastSlash = i;
          dots = 0;
        } else if (code === 46 && dots !== -1) {
          ++dots;
        } else {
          dots = -1;
        }
      }
      return res;
    }
    function _format(sep, pathObject) {
      var dir = pathObject.dir || pathObject.root;
      var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
      if (!dir) {
        return base;
      }
      if (dir === pathObject.root) {
        return dir + base;
      }
      return dir + sep + base;
    }
    var posix6 = {
      // path.resolve([from ...], to)
      resolve: function resolve() {
        var resolvedPath = "";
        var resolvedAbsolute = false;
        var cwd;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path;
          if (i >= 0)
            path = arguments[i];
          else {
            if (cwd === void 0)
              cwd = process.cwd();
            path = cwd;
          }
          assertPath(path);
          if (path.length === 0) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path.charCodeAt(0) === 47;
        }
        resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
        if (resolvedAbsolute) {
          if (resolvedPath.length > 0)
            return "/" + resolvedPath;
          else
            return "/";
        } else if (resolvedPath.length > 0) {
          return resolvedPath;
        } else {
          return ".";
        }
      },
      normalize: function normalize(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var isAbsolute = path.charCodeAt(0) === 47;
        var trailingSeparator = path.charCodeAt(path.length - 1) === 47;
        path = normalizeStringPosix(path, !isAbsolute);
        if (path.length === 0 && !isAbsolute)
          path = ".";
        if (path.length > 0 && trailingSeparator)
          path += "/";
        if (isAbsolute)
          return "/" + path;
        return path;
      },
      isAbsolute: function isAbsolute(path) {
        assertPath(path);
        return path.length > 0 && path.charCodeAt(0) === 47;
      },
      join: function join() {
        if (arguments.length === 0)
          return ".";
        var joined;
        for (var i = 0; i < arguments.length; ++i) {
          var arg = arguments[i];
          assertPath(arg);
          if (arg.length > 0) {
            if (joined === void 0)
              joined = arg;
            else
              joined += "/" + arg;
          }
        }
        if (joined === void 0)
          return ".";
        return posix6.normalize(joined);
      },
      relative: function relative(from, to) {
        assertPath(from);
        assertPath(to);
        if (from === to)
          return "";
        from = posix6.resolve(from);
        to = posix6.resolve(to);
        if (from === to)
          return "";
        var fromStart = 1;
        for (; fromStart < from.length; ++fromStart) {
          if (from.charCodeAt(fromStart) !== 47)
            break;
        }
        var fromEnd = from.length;
        var fromLen = fromEnd - fromStart;
        var toStart = 1;
        for (; toStart < to.length; ++toStart) {
          if (to.charCodeAt(toStart) !== 47)
            break;
        }
        var toEnd = to.length;
        var toLen = toEnd - toStart;
        var length = fromLen < toLen ? fromLen : toLen;
        var lastCommonSep = -1;
        var i = 0;
        for (; i <= length; ++i) {
          if (i === length) {
            if (toLen > length) {
              if (to.charCodeAt(toStart + i) === 47) {
                return to.slice(toStart + i + 1);
              } else if (i === 0) {
                return to.slice(toStart + i);
              }
            } else if (fromLen > length) {
              if (from.charCodeAt(fromStart + i) === 47) {
                lastCommonSep = i;
              } else if (i === 0) {
                lastCommonSep = 0;
              }
            }
            break;
          }
          var fromCode = from.charCodeAt(fromStart + i);
          var toCode = to.charCodeAt(toStart + i);
          if (fromCode !== toCode)
            break;
          else if (fromCode === 47)
            lastCommonSep = i;
        }
        var out = "";
        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
          if (i === fromEnd || from.charCodeAt(i) === 47) {
            if (out.length === 0)
              out += "..";
            else
              out += "/..";
          }
        }
        if (out.length > 0)
          return out + to.slice(toStart + lastCommonSep);
        else {
          toStart += lastCommonSep;
          if (to.charCodeAt(toStart) === 47)
            ++toStart;
          return to.slice(toStart);
        }
      },
      _makeLong: function _makeLong(path) {
        return path;
      },
      dirname: function dirname(path) {
        assertPath(path);
        if (path.length === 0)
          return ".";
        var code = path.charCodeAt(0);
        var hasRoot = code === 47;
        var end = -1;
        var matchedSlash = true;
        for (var i = path.length - 1; i >= 1; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
            matchedSlash = false;
          }
        }
        if (end === -1)
          return hasRoot ? "/" : ".";
        if (hasRoot && end === 1)
          return "//";
        return path.slice(0, end);
      },
      basename: function basename(path, ext2) {
        if (ext2 !== void 0 && typeof ext2 !== "string")
          throw new TypeError('"ext" argument must be a string');
        assertPath(path);
        var start = 0;
        var end = -1;
        var matchedSlash = true;
        var i;
        if (ext2 !== void 0 && ext2.length > 0 && ext2.length <= path.length) {
          if (ext2.length === path.length && ext2 === path)
            return "";
          var extIdx = ext2.length - 1;
          var firstNonSlashEnd = -1;
          for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else {
              if (firstNonSlashEnd === -1) {
                matchedSlash = false;
                firstNonSlashEnd = i + 1;
              }
              if (extIdx >= 0) {
                if (code === ext2.charCodeAt(extIdx)) {
                  if (--extIdx === -1) {
                    end = i;
                  }
                } else {
                  extIdx = -1;
                  end = firstNonSlashEnd;
                }
              }
            }
          }
          if (start === end)
            end = firstNonSlashEnd;
          else if (end === -1)
            end = path.length;
          return path.slice(start, end);
        } else {
          for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47) {
              if (!matchedSlash) {
                start = i + 1;
                break;
              }
            } else if (end === -1) {
              matchedSlash = false;
              end = i + 1;
            }
          }
          if (end === -1)
            return "";
          return path.slice(start, end);
        }
      },
      extname: function extname(path) {
        assertPath(path);
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var preDotState = 0;
        for (var i = path.length - 1; i >= 0; --i) {
          var code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          return "";
        }
        return path.slice(startDot, end);
      },
      format: function format(pathObject) {
        if (pathObject === null || typeof pathObject !== "object") {
          throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
        }
        return _format("/", pathObject);
      },
      parse: function parse(path) {
        assertPath(path);
        var ret = { root: "", dir: "", base: "", ext: "", name: "" };
        if (path.length === 0)
          return ret;
        var code = path.charCodeAt(0);
        var isAbsolute = code === 47;
        var start;
        if (isAbsolute) {
          ret.root = "/";
          start = 1;
        } else {
          start = 0;
        }
        var startDot = -1;
        var startPart = 0;
        var end = -1;
        var matchedSlash = true;
        var i = path.length - 1;
        var preDotState = 0;
        for (; i >= start; --i) {
          code = path.charCodeAt(i);
          if (code === 47) {
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
          if (end === -1) {
            matchedSlash = false;
            end = i + 1;
          }
          if (code === 46) {
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
          } else if (startDot !== -1) {
            preDotState = -1;
          }
        }
        if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
        preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
          if (end !== -1) {
            if (startPart === 0 && isAbsolute)
              ret.base = ret.name = path.slice(1, end);
            else
              ret.base = ret.name = path.slice(startPart, end);
          }
        } else {
          if (startPart === 0 && isAbsolute) {
            ret.name = path.slice(1, startDot);
            ret.base = path.slice(1, end);
          } else {
            ret.name = path.slice(startPart, startDot);
            ret.base = path.slice(startPart, end);
          }
          ret.ext = path.slice(startDot, end);
        }
        if (startPart > 0)
          ret.dir = path.slice(0, startPart - 1);
        else if (isAbsolute)
          ret.dir = "/";
        return ret;
      },
      sep: "/",
      delimiter: ":",
      win32: null,
      posix: null
    };
    posix6.posix = posix6;
    module.exports = posix6;
  }
});

// node_modules/handlebars/dist/cjs/handlebars/utils.js
var require_utils2 = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/utils.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.extend = extend;
    exports.indexOf = indexOf;
    exports.escapeExpression = escapeExpression;
    exports.isEmpty = isEmpty;
    exports.createFrame = createFrame;
    exports.blockParams = blockParams;
    exports.appendContextPath = appendContextPath;
    var escape = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;",
      "=": "&#x3D;"
    };
    var badChars = /[&<>"'`=]/g;
    var possible = /[&<>"'`=]/;
    function escapeChar(chr) {
      return escape[chr];
    }
    function extend(obj) {
      for (var i = 1; i < arguments.length; i++) {
        for (var key in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
            obj[key] = arguments[i][key];
          }
        }
      }
      return obj;
    }
    var toString = Object.prototype.toString;
    exports.toString = toString;
    var isFunction = function isFunction2(value) {
      return typeof value === "function";
    };
    if (isFunction(/x/)) {
      exports.isFunction = isFunction = function(value) {
        return typeof value === "function" && toString.call(value) === "[object Function]";
      };
    }
    exports.isFunction = isFunction;
    var isArray = Array.isArray || function(value) {
      return value && typeof value === "object" ? toString.call(value) === "[object Array]" : false;
    };
    exports.isArray = isArray;
    function indexOf(array, value) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    }
    function escapeExpression(string) {
      if (typeof string !== "string") {
        if (string && string.toHTML) {
          return string.toHTML();
        } else if (string == null) {
          return "";
        } else if (!string) {
          return string + "";
        }
        string = "" + string;
      }
      if (!possible.test(string)) {
        return string;
      }
      return string.replace(badChars, escapeChar);
    }
    function isEmpty(value) {
      if (!value && value !== 0) {
        return true;
      } else if (isArray(value) && value.length === 0) {
        return true;
      } else {
        return false;
      }
    }
    function createFrame(object) {
      var frame = extend({}, object);
      frame._parent = object;
      return frame;
    }
    function blockParams(params, ids) {
      params.path = ids;
      return params;
    }
    function appendContextPath(contextPath, id) {
      return (contextPath ? contextPath + "." : "") + id;
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/exception.js
var require_exception = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/exception.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
    function Exception(message, node) {
      var loc = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
      if (loc) {
        line = loc.start.line;
        endLineNumber = loc.end.line;
        column = loc.start.column;
        endColumn = loc.end.column;
        message += " - " + line + ":" + column;
      }
      var tmp = Error.prototype.constructor.call(this, message);
      for (var idx = 0; idx < errorProps.length; idx++) {
        this[errorProps[idx]] = tmp[errorProps[idx]];
      }
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, Exception);
      }
      try {
        if (loc) {
          this.lineNumber = line;
          this.endLineNumber = endLineNumber;
          if (Object.defineProperty) {
            Object.defineProperty(this, "column", {
              value: column,
              enumerable: true
            });
            Object.defineProperty(this, "endColumn", {
              value: endColumn,
              enumerable: true
            });
          } else {
            this.column = column;
            this.endColumn = endColumn;
          }
        }
      } catch (nop) {
      }
    }
    Exception.prototype = new Error();
    exports["default"] = Exception;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js
var require_block_helper_missing = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils2();
    exports["default"] = function(instance) {
      instance.registerHelper("blockHelperMissing", function(context, options) {
        var inverse = options.inverse, fn = options.fn;
        if (context === true) {
          return fn(this);
        } else if (context === false || context == null) {
          return inverse(this);
        } else if (_utils.isArray(context)) {
          if (context.length > 0) {
            if (options.ids) {
              options.ids = [options.name];
            }
            return instance.helpers.each(context, options);
          } else {
            return inverse(this);
          }
        } else {
          if (options.data && options.ids) {
            var data = _utils.createFrame(options.data);
            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
            options = { data };
          }
          return fn(context, options);
        }
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/each.js
var require_each = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/each.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils2();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("each", function(context, options) {
        if (!options) {
          throw new _exception2["default"]("Must pass iterator to #each");
        }
        var fn = options.fn, inverse = options.inverse, i = 0, ret = "", data = void 0, contextPath = void 0;
        if (options.data && options.ids) {
          contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
        }
        if (_utils.isFunction(context)) {
          context = context.call(this);
        }
        if (options.data) {
          data = _utils.createFrame(options.data);
        }
        function execIteration(field, index, last2) {
          if (data) {
            data.key = field;
            data.index = index;
            data.first = index === 0;
            data.last = !!last2;
            if (contextPath) {
              data.contextPath = contextPath + field;
            }
          }
          ret = ret + fn(context[field], {
            data,
            blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
          });
        }
        if (context && typeof context === "object") {
          if (_utils.isArray(context)) {
            for (var j = context.length; i < j; i++) {
              if (i in context) {
                execIteration(i, i, i === context.length - 1);
              }
            }
          } else if (typeof Symbol === "function" && context[Symbol.iterator]) {
            var newContext = [];
            var iterator = context[Symbol.iterator]();
            for (var it = iterator.next(); !it.done; it = iterator.next()) {
              newContext.push(it.value);
            }
            context = newContext;
            for (var j = context.length; i < j; i++) {
              execIteration(i, i, i === context.length - 1);
            }
          } else {
            (function() {
              var priorKey = void 0;
              Object.keys(context).forEach(function(key) {
                if (priorKey !== void 0) {
                  execIteration(priorKey, i - 1);
                }
                priorKey = key;
                i++;
              });
              if (priorKey !== void 0) {
                execIteration(priorKey, i - 1, true);
              }
            })();
          }
        }
        if (i === 0) {
          ret = inverse(this);
        }
        return ret;
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js
var require_helper_missing = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("helperMissing", function() {
        if (arguments.length === 1) {
          return void 0;
        } else {
          throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
        }
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/if.js
var require_if = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/if.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils2();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("if", function(conditional, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#if requires exactly one argument");
        }
        if (_utils.isFunction(conditional)) {
          conditional = conditional.call(this);
        }
        if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
          return options.inverse(this);
        } else {
          return options.fn(this);
        }
      });
      instance.registerHelper("unless", function(conditional, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#unless requires exactly one argument");
        }
        return instance.helpers["if"].call(this, conditional, {
          fn: options.inverse,
          inverse: options.fn,
          hash: options.hash
        });
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/log.js
var require_log = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/log.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(instance) {
      instance.registerHelper("log", function() {
        var args = [void 0], options = arguments[arguments.length - 1];
        for (var i = 0; i < arguments.length - 1; i++) {
          args.push(arguments[i]);
        }
        var level = 1;
        if (options.hash.level != null) {
          level = options.hash.level;
        } else if (options.data && options.data.level != null) {
          level = options.data.level;
        }
        args[0] = level;
        instance.log.apply(instance, args);
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js
var require_lookup = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(instance) {
      instance.registerHelper("lookup", function(obj, field, options) {
        if (!obj) {
          return obj;
        }
        return options.lookupProperty(obj, field);
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers/with.js
var require_with = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers/with.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils2();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    exports["default"] = function(instance) {
      instance.registerHelper("with", function(context, options) {
        if (arguments.length != 2) {
          throw new _exception2["default"]("#with requires exactly one argument");
        }
        if (_utils.isFunction(context)) {
          context = context.call(this);
        }
        var fn = options.fn;
        if (!_utils.isEmpty(context)) {
          var data = options.data;
          if (options.data && options.ids) {
            data = _utils.createFrame(options.data);
            data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
          }
          return fn(context, {
            data,
            blockParams: _utils.blockParams([context], [data && data.contextPath])
          });
        } else {
          return options.inverse(this);
        }
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/helpers.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.registerDefaultHelpers = registerDefaultHelpers;
    exports.moveHelperToHooks = moveHelperToHooks;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _helpersBlockHelperMissing = require_block_helper_missing();
    var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
    var _helpersEach = require_each();
    var _helpersEach2 = _interopRequireDefault(_helpersEach);
    var _helpersHelperMissing = require_helper_missing();
    var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
    var _helpersIf = require_if();
    var _helpersIf2 = _interopRequireDefault(_helpersIf);
    var _helpersLog = require_log();
    var _helpersLog2 = _interopRequireDefault(_helpersLog);
    var _helpersLookup = require_lookup();
    var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
    var _helpersWith = require_with();
    var _helpersWith2 = _interopRequireDefault(_helpersWith);
    function registerDefaultHelpers(instance) {
      _helpersBlockHelperMissing2["default"](instance);
      _helpersEach2["default"](instance);
      _helpersHelperMissing2["default"](instance);
      _helpersIf2["default"](instance);
      _helpersLog2["default"](instance);
      _helpersLookup2["default"](instance);
      _helpersWith2["default"](instance);
    }
    function moveHelperToHooks(instance, helperName, keepHelper) {
      if (instance.helpers[helperName]) {
        instance.hooks[helperName] = instance.helpers[helperName];
        if (!keepHelper) {
          delete instance.helpers[helperName];
        }
      }
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js
var require_inline2 = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils2();
    exports["default"] = function(instance) {
      instance.registerDecorator("inline", function(fn, props, container, options) {
        var ret = fn;
        if (!props.partials) {
          props.partials = {};
          ret = function(context, options2) {
            var original = container.partials;
            container.partials = _utils.extend({}, original, props.partials);
            var ret2 = fn(context, options2);
            container.partials = original;
            return ret2;
          };
        }
        props.partials[options.args[0]] = options.fn;
        return ret;
      });
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/decorators.js
var require_decorators = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/decorators.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.registerDefaultDecorators = registerDefaultDecorators;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _decoratorsInline = require_inline2();
    var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
    function registerDefaultDecorators(instance) {
      _decoratorsInline2["default"](instance);
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/logger.js
var require_logger = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/logger.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils2();
    var logger = {
      methodMap: ["debug", "info", "warn", "error"],
      level: "info",
      // Maps a given level value to the `methodMap` indexes above.
      lookupLevel: function lookupLevel(level) {
        if (typeof level === "string") {
          var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
          if (levelMap >= 0) {
            level = levelMap;
          } else {
            level = parseInt(level, 10);
          }
        }
        return level;
      },
      // Can be overridden in the host environment
      log: function log(level) {
        level = logger.lookupLevel(level);
        if (typeof console !== "undefined" && logger.lookupLevel(logger.level) <= level) {
          var method = logger.methodMap[level];
          if (!console[method]) {
            method = "log";
          }
          for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            message[_key - 1] = arguments[_key];
          }
        }
      }
    };
    exports["default"] = logger;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js
var require_create_new_lookup_object = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.createNewLookupObject = createNewLookupObject;
    var _utils = require_utils2();
    function createNewLookupObject() {
      for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      return _utils.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(sources));
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js
var require_proto_access = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.createProtoAccessControl = createProtoAccessControl;
    exports.resultIsAllowed = resultIsAllowed;
    exports.resetLoggedProperties = resetLoggedProperties;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _createNewLookupObject = require_create_new_lookup_object();
    var _logger = require_logger();
    var _logger2 = _interopRequireDefault(_logger);
    var loggedProperties = /* @__PURE__ */ Object.create(null);
    function createProtoAccessControl(runtimeOptions) {
      var defaultMethodWhiteList = /* @__PURE__ */ Object.create(null);
      defaultMethodWhiteList["constructor"] = false;
      defaultMethodWhiteList["__defineGetter__"] = false;
      defaultMethodWhiteList["__defineSetter__"] = false;
      defaultMethodWhiteList["__lookupGetter__"] = false;
      var defaultPropertyWhiteList = /* @__PURE__ */ Object.create(null);
      defaultPropertyWhiteList["__proto__"] = false;
      return {
        properties: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
          defaultValue: runtimeOptions.allowProtoPropertiesByDefault
        },
        methods: {
          whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
          defaultValue: runtimeOptions.allowProtoMethodsByDefault
        }
      };
    }
    function resultIsAllowed(result, protoAccessControl, propertyName) {
      if (typeof result === "function") {
        return checkWhiteList(protoAccessControl.methods, propertyName);
      } else {
        return checkWhiteList(protoAccessControl.properties, propertyName);
      }
    }
    function checkWhiteList(protoAccessControlForType, propertyName) {
      if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
        return protoAccessControlForType.whitelist[propertyName] === true;
      }
      if (protoAccessControlForType.defaultValue !== void 0) {
        return protoAccessControlForType.defaultValue;
      }
      logUnexpecedPropertyAccessOnce(propertyName);
      return false;
    }
    function logUnexpecedPropertyAccessOnce(propertyName) {
      if (loggedProperties[propertyName] !== true) {
        loggedProperties[propertyName] = true;
        _logger2["default"].log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
      }
    }
    function resetLoggedProperties() {
      Object.keys(loggedProperties).forEach(function(propertyName) {
        delete loggedProperties[propertyName];
      });
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/base.js
var require_base = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/base.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.HandlebarsEnvironment = HandlebarsEnvironment;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _utils = require_utils2();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _helpers = require_helpers2();
    var _decorators = require_decorators();
    var _logger = require_logger();
    var _logger2 = _interopRequireDefault(_logger);
    var _internalProtoAccess = require_proto_access();
    var VERSION = "4.7.8";
    exports.VERSION = VERSION;
    var COMPILER_REVISION = 8;
    exports.COMPILER_REVISION = COMPILER_REVISION;
    var LAST_COMPATIBLE_COMPILER_REVISION = 7;
    exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
    var REVISION_CHANGES = {
      1: "<= 1.0.rc.2",
      // 1.0.rc.2 is actually rev2 but doesn't report it
      2: "== 1.0.0-rc.3",
      3: "== 1.0.0-rc.4",
      4: "== 1.x.x",
      5: "== 2.0.0-alpha.x",
      6: ">= 2.0.0-beta.1",
      7: ">= 4.0.0 <4.3.0",
      8: ">= 4.3.0"
    };
    exports.REVISION_CHANGES = REVISION_CHANGES;
    var objectType = "[object Object]";
    function HandlebarsEnvironment(helpers, partials, decorators) {
      this.helpers = helpers || {};
      this.partials = partials || {};
      this.decorators = decorators || {};
      _helpers.registerDefaultHelpers(this);
      _decorators.registerDefaultDecorators(this);
    }
    HandlebarsEnvironment.prototype = {
      constructor: HandlebarsEnvironment,
      logger: _logger2["default"],
      log: _logger2["default"].log,
      registerHelper: function registerHelper(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple helpers");
          }
          _utils.extend(this.helpers, name);
        } else {
          this.helpers[name] = fn;
        }
      },
      unregisterHelper: function unregisterHelper(name) {
        delete this.helpers[name];
      },
      registerPartial: function registerPartial(name, partial) {
        if (_utils.toString.call(name) === objectType) {
          _utils.extend(this.partials, name);
        } else {
          if (typeof partial === "undefined") {
            throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
          }
          this.partials[name] = partial;
        }
      },
      unregisterPartial: function unregisterPartial(name) {
        delete this.partials[name];
      },
      registerDecorator: function registerDecorator(name, fn) {
        if (_utils.toString.call(name) === objectType) {
          if (fn) {
            throw new _exception2["default"]("Arg not supported with multiple decorators");
          }
          _utils.extend(this.decorators, name);
        } else {
          this.decorators[name] = fn;
        }
      },
      unregisterDecorator: function unregisterDecorator(name) {
        delete this.decorators[name];
      },
      /**
       * Reset the memory of illegal property accesses that have already been logged.
       * @deprecated should only be used in handlebars test-cases
       */
      resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
        _internalProtoAccess.resetLoggedProperties();
      }
    };
    var log = _logger2["default"].log;
    exports.log = log;
    exports.createFrame = _utils.createFrame;
    exports.logger = _logger2["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/safe-string.js
var require_safe_string = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/safe-string.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function SafeString(string) {
      this.string = string;
    }
    SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
      return "" + this.string;
    };
    exports["default"] = SafeString;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js
var require_wrapHelper = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.wrapHelper = wrapHelper;
    function wrapHelper(helper, transformOptionsFn) {
      if (typeof helper !== "function") {
        return helper;
      }
      var wrapper = function wrapper2() {
        var options = arguments[arguments.length - 1];
        arguments[arguments.length - 1] = transformOptionsFn(options);
        return helper.apply(this, arguments);
      };
      return wrapper;
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/runtime.js
var require_runtime = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/runtime.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.checkRevision = checkRevision;
    exports.template = template;
    exports.wrapProgram = wrapProgram;
    exports.resolvePartial = resolvePartial;
    exports.invokePartial = invokePartial;
    exports.noop = noop2;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var _utils = require_utils2();
    var Utils = _interopRequireWildcard(_utils);
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _base = require_base();
    var _helpers = require_helpers2();
    var _internalWrapHelper = require_wrapHelper();
    var _internalProtoAccess = require_proto_access();
    function checkRevision(compilerInfo) {
      var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
      if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
        return;
      }
      if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
        var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
        throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
      } else {
        throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
      }
    }
    function template(templateSpec, env) {
      if (!env) {
        throw new _exception2["default"]("No environment passed to template");
      }
      if (!templateSpec || !templateSpec.main) {
        throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
      }
      templateSpec.main.decorator = templateSpec.main_d;
      env.VM.checkRevision(templateSpec.compiler);
      var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
      function invokePartialWrapper(partial, context, options) {
        if (options.hash) {
          context = Utils.extend({}, context, options.hash);
          if (options.ids) {
            options.ids[0] = true;
          }
        }
        partial = env.VM.resolvePartial.call(this, partial, context, options);
        var extendedOptions = Utils.extend({}, options, {
          hooks: this.hooks,
          protoAccessControl: this.protoAccessControl
        });
        var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
        if (result == null && env.compile) {
          options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
          result = options.partials[options.name](context, extendedOptions);
        }
        if (result != null) {
          if (options.indent) {
            var lines = result.split("\n");
            for (var i = 0, l = lines.length; i < l; i++) {
              if (!lines[i] && i + 1 === l) {
                break;
              }
              lines[i] = options.indent + lines[i];
            }
            result = lines.join("\n");
          }
          return result;
        } else {
          throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
        }
      }
      var container = {
        strict: function strict(obj, name, loc) {
          if (!obj || !(name in obj)) {
            throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
              loc
            });
          }
          return container.lookupProperty(obj, name);
        },
        lookupProperty: function lookupProperty(parent, propertyName) {
          var result = parent[propertyName];
          if (result == null) {
            return result;
          }
          if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
            return result;
          }
          if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
            return result;
          }
          return void 0;
        },
        lookup: function lookup2(depths, name) {
          var len = depths.length;
          for (var i = 0; i < len; i++) {
            var result = depths[i] && container.lookupProperty(depths[i], name);
            if (result != null) {
              return depths[i][name];
            }
          }
        },
        lambda: function lambda(current, context) {
          return typeof current === "function" ? current.call(context) : current;
        },
        escapeExpression: Utils.escapeExpression,
        invokePartial: invokePartialWrapper,
        fn: function fn(i) {
          var ret2 = templateSpec[i];
          ret2.decorator = templateSpec[i + "_d"];
          return ret2;
        },
        programs: [],
        program: function program(i, data, declaredBlockParams, blockParams, depths) {
          var programWrapper = this.programs[i], fn = this.fn(i);
          if (data || depths || blockParams || declaredBlockParams) {
            programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
          } else if (!programWrapper) {
            programWrapper = this.programs[i] = wrapProgram(this, i, fn);
          }
          return programWrapper;
        },
        data: function data(value, depth) {
          while (value && depth--) {
            value = value._parent;
          }
          return value;
        },
        mergeIfNeeded: function mergeIfNeeded(param, common) {
          var obj = param || common;
          if (param && common && param !== common) {
            obj = Utils.extend({}, common, param);
          }
          return obj;
        },
        // An empty object to use as replacement for null-contexts
        nullContext: Object.seal({}),
        noop: env.VM.noop,
        compilerInfo: templateSpec.compiler
      };
      function ret(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var data = options.data;
        ret._setup(options);
        if (!options.partial && templateSpec.useData) {
          data = initData(context, data);
        }
        var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
        if (templateSpec.useDepths) {
          if (options.depths) {
            depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
          } else {
            depths = [context];
          }
        }
        function main(context2) {
          return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams, depths);
        }
        main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
        return main(context, options);
      }
      ret.isTop = true;
      ret._setup = function(options) {
        if (!options.partial) {
          var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
          wrapHelpersToPassLookupProperty(mergedHelpers, container);
          container.helpers = mergedHelpers;
          if (templateSpec.usePartial) {
            container.partials = container.mergeIfNeeded(options.partials, env.partials);
          }
          if (templateSpec.usePartial || templateSpec.useDecorators) {
            container.decorators = Utils.extend({}, env.decorators, options.decorators);
          }
          container.hooks = {};
          container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
          var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
          _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
          _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
        } else {
          container.protoAccessControl = options.protoAccessControl;
          container.helpers = options.helpers;
          container.partials = options.partials;
          container.decorators = options.decorators;
          container.hooks = options.hooks;
        }
      };
      ret._child = function(i, data, blockParams, depths) {
        if (templateSpec.useBlockParams && !blockParams) {
          throw new _exception2["default"]("must pass block params");
        }
        if (templateSpec.useDepths && !depths) {
          throw new _exception2["default"]("must pass parent depths");
        }
        return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
      };
      return ret;
    }
    function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
      function prog(context) {
        var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
        var currentDepths = depths;
        if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
          currentDepths = [context].concat(depths);
        }
        return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
      }
      prog = executeDecorators(fn, prog, container, depths, data, blockParams);
      prog.program = i;
      prog.depth = depths ? depths.length : 0;
      prog.blockParams = declaredBlockParams || 0;
      return prog;
    }
    function resolvePartial(partial, context, options) {
      if (!partial) {
        if (options.name === "@partial-block") {
          partial = options.data["partial-block"];
        } else {
          partial = options.partials[options.name];
        }
      } else if (!partial.call && !options.name) {
        options.name = partial;
        partial = options.partials[partial];
      }
      return partial;
    }
    function invokePartial(partial, context, options) {
      var currentPartialBlock = options.data && options.data["partial-block"];
      options.partial = true;
      if (options.ids) {
        options.data.contextPath = options.ids[0] || options.data.contextPath;
      }
      var partialBlock = void 0;
      if (options.fn && options.fn !== noop2) {
        (function() {
          options.data = _base.createFrame(options.data);
          var fn = options.fn;
          partialBlock = options.data["partial-block"] = function partialBlockWrapper(context2) {
            var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
            options2.data = _base.createFrame(options2.data);
            options2.data["partial-block"] = currentPartialBlock;
            return fn(context2, options2);
          };
          if (fn.partials) {
            options.partials = Utils.extend({}, options.partials, fn.partials);
          }
        })();
      }
      if (partial === void 0 && partialBlock) {
        partial = partialBlock;
      }
      if (partial === void 0) {
        throw new _exception2["default"]("The partial " + options.name + " could not be found");
      } else if (partial instanceof Function) {
        return partial(context, options);
      }
    }
    function noop2() {
      return "";
    }
    function initData(context, data) {
      if (!data || !("root" in data)) {
        data = data ? _base.createFrame(data) : {};
        data.root = context;
      }
      return data;
    }
    function executeDecorators(fn, prog, container, depths, data, blockParams) {
      if (fn.decorator) {
        var props = {};
        prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
        Utils.extend(prog, props);
      }
      return prog;
    }
    function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
      Object.keys(mergedHelpers).forEach(function(helperName) {
        var helper = mergedHelpers[helperName];
        mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
      });
    }
    function passLookupPropertyOption(helper, container) {
      var lookupProperty = container.lookupProperty;
      return _internalWrapHelper.wrapHelper(helper, function(options) {
        return Utils.extend({ lookupProperty }, options);
      });
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/no-conflict.js
var require_no_conflict = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/no-conflict.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    exports["default"] = function(Handlebars6) {
      (function() {
        if (typeof globalThis === "object")
          return;
        Object.prototype.__defineGetter__("__magic__", function() {
          return this;
        });
        __magic__.globalThis = __magic__;
        delete Object.prototype.__magic__;
      })();
      var $Handlebars = globalThis.Handlebars;
      Handlebars6.noConflict = function() {
        if (globalThis.Handlebars === Handlebars6) {
          globalThis.Handlebars = $Handlebars;
        }
        return Handlebars6;
      };
    };
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars.runtime.js
var require_handlebars_runtime = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars.runtime.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    var _handlebarsBase = require_base();
    var base = _interopRequireWildcard(_handlebarsBase);
    var _handlebarsSafeString = require_safe_string();
    var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
    var _handlebarsException = require_exception();
    var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
    var _handlebarsUtils = require_utils2();
    var Utils = _interopRequireWildcard(_handlebarsUtils);
    var _handlebarsRuntime = require_runtime();
    var runtime = _interopRequireWildcard(_handlebarsRuntime);
    var _handlebarsNoConflict = require_no_conflict();
    var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
    function create() {
      var hb = new base.HandlebarsEnvironment();
      Utils.extend(hb, base);
      hb.SafeString = _handlebarsSafeString2["default"];
      hb.Exception = _handlebarsException2["default"];
      hb.Utils = Utils;
      hb.escapeExpression = Utils.escapeExpression;
      hb.VM = runtime;
      hb.template = function(spec) {
        return runtime.template(spec, hb);
      };
      return hb;
    }
    var inst = create();
    inst.create = create;
    _handlebarsNoConflict2["default"](inst);
    inst["default"] = inst;
    exports["default"] = inst;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js
var require_ast = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var AST = {
      // Public API used to evaluate derived attributes regarding AST nodes
      helpers: {
        // a mustache is definitely a helper if:
        // * it is an eligible helper, and
        // * it has at least one parameter or hash segment
        helperExpression: function helperExpression(node) {
          return node.type === "SubExpression" || (node.type === "MustacheStatement" || node.type === "BlockStatement") && !!(node.params && node.params.length || node.hash);
        },
        scopedId: function scopedId(path) {
          return /^\.|this\b/.test(path.original);
        },
        // an ID is simple if it only has one part, and that part is not
        // `..` or `this`.
        simpleId: function simpleId(path) {
          return path.parts.length === 1 && !AST.helpers.scopedId(path) && !path.depth;
        }
      }
    };
    exports["default"] = AST;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js
var require_parser = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var handlebars = function() {
      var parser = {
        trace: function trace() {
        },
        yy: {},
        symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
        terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
        productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          var $0 = $$.length - 1;
          switch (yystate) {
            case 1:
              return $$[$0 - 1];
              break;
            case 2:
              this.$ = yy.prepareProgram($$[$0]);
              break;
            case 3:
              this.$ = $$[$0];
              break;
            case 4:
              this.$ = $$[$0];
              break;
            case 5:
              this.$ = $$[$0];
              break;
            case 6:
              this.$ = $$[$0];
              break;
            case 7:
              this.$ = $$[$0];
              break;
            case 8:
              this.$ = $$[$0];
              break;
            case 9:
              this.$ = {
                type: "CommentStatement",
                value: yy.stripComment($$[$0]),
                strip: yy.stripFlags($$[$0], $$[$0]),
                loc: yy.locInfo(this._$)
              };
              break;
            case 10:
              this.$ = {
                type: "ContentStatement",
                original: $$[$0],
                value: $$[$0],
                loc: yy.locInfo(this._$)
              };
              break;
            case 11:
              this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
              break;
            case 12:
              this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
              break;
            case 13:
              this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
              break;
            case 14:
              this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
              break;
            case 15:
              this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 16:
              this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 17:
              this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
              break;
            case 18:
              this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
              break;
            case 19:
              var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program = yy.prepareProgram([inverse], $$[$0 - 1].loc);
              program.chained = true;
              this.$ = { strip: $$[$0 - 2].strip, program, chain: true };
              break;
            case 20:
              this.$ = $$[$0];
              break;
            case 21:
              this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
              break;
            case 22:
              this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
              break;
            case 23:
              this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
              break;
            case 24:
              this.$ = {
                type: "PartialStatement",
                name: $$[$0 - 3],
                params: $$[$0 - 2],
                hash: $$[$0 - 1],
                indent: "",
                strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                loc: yy.locInfo(this._$)
              };
              break;
            case 25:
              this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
              break;
            case 26:
              this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
              break;
            case 27:
              this.$ = $$[$0];
              break;
            case 28:
              this.$ = $$[$0];
              break;
            case 29:
              this.$ = {
                type: "SubExpression",
                path: $$[$0 - 3],
                params: $$[$0 - 2],
                hash: $$[$0 - 1],
                loc: yy.locInfo(this._$)
              };
              break;
            case 30:
              this.$ = { type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 31:
              this.$ = { type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 32:
              this.$ = yy.id($$[$0 - 1]);
              break;
            case 33:
              this.$ = $$[$0];
              break;
            case 34:
              this.$ = $$[$0];
              break;
            case 35:
              this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
              break;
            case 36:
              this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
              break;
            case 37:
              this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$) };
              break;
            case 38:
              this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$) };
              break;
            case 39:
              this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
              break;
            case 40:
              this.$ = $$[$0];
              break;
            case 41:
              this.$ = $$[$0];
              break;
            case 42:
              this.$ = yy.preparePath(true, $$[$0], this._$);
              break;
            case 43:
              this.$ = yy.preparePath(false, $$[$0], this._$);
              break;
            case 44:
              $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
              this.$ = $$[$0 - 2];
              break;
            case 45:
              this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
              break;
            case 46:
              this.$ = [];
              break;
            case 47:
              $$[$0 - 1].push($$[$0]);
              break;
            case 48:
              this.$ = [];
              break;
            case 49:
              $$[$0 - 1].push($$[$0]);
              break;
            case 50:
              this.$ = [];
              break;
            case 51:
              $$[$0 - 1].push($$[$0]);
              break;
            case 58:
              this.$ = [];
              break;
            case 59:
              $$[$0 - 1].push($$[$0]);
              break;
            case 64:
              this.$ = [];
              break;
            case 65:
              $$[$0 - 1].push($$[$0]);
              break;
            case 70:
              this.$ = [];
              break;
            case 71:
              $$[$0 - 1].push($$[$0]);
              break;
            case 78:
              this.$ = [];
              break;
            case 79:
              $$[$0 - 1].push($$[$0]);
              break;
            case 82:
              this.$ = [];
              break;
            case 83:
              $$[$0 - 1].push($$[$0]);
              break;
            case 86:
              this.$ = [];
              break;
            case 87:
              $$[$0 - 1].push($$[$0]);
              break;
            case 90:
              this.$ = [];
              break;
            case 91:
              $$[$0 - 1].push($$[$0]);
              break;
            case 94:
              this.$ = [];
              break;
            case 95:
              $$[$0 - 1].push($$[$0]);
              break;
            case 98:
              this.$ = [$$[$0]];
              break;
            case 99:
              $$[$0 - 1].push($$[$0]);
              break;
            case 100:
              this.$ = [$$[$0]];
              break;
            case 101:
              $$[$0 - 1].push($$[$0]);
              break;
          }
        },
        table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
        defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
        parseError: function parseError(str, hash) {
          throw new Error(str);
        },
        parse: function parse(input) {
          var self2 = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
          this.lexer.setInput(input);
          this.lexer.yy = this.yy;
          this.yy.lexer = this.lexer;
          this.yy.parser = this;
          if (typeof this.lexer.yylloc == "undefined")
            this.lexer.yylloc = {};
          var yyloc = this.lexer.yylloc;
          lstack.push(yyloc);
          var ranges = this.lexer.options && this.lexer.options.ranges;
          if (typeof this.yy.parseError === "function")
            this.parseError = this.yy.parseError;
          function popStack(n) {
            stack.length = stack.length - 2 * n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
          }
          function lex() {
            var token;
            token = self2.lexer.lex() || 1;
            if (typeof token !== "number") {
              token = self2.symbols_[token] || token;
            }
            return token;
          }
          var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
          while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
              action = this.defaultActions[state];
            } else {
              if (symbol === null || typeof symbol == "undefined") {
                symbol = lex();
              }
              action = table[state] && table[state][symbol];
            }
            if (typeof action === "undefined" || !action.length || !action[0]) {
              var errStr = "";
              if (!recovering) {
                expected = [];
                for (p in table[state])
                  if (this.terminals_[p] && p > 2) {
                    expected.push("'" + this.terminals_[p] + "'");
                  }
                if (this.lexer.showPosition) {
                  errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                } else {
                  errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                }
                this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
              }
            }
            if (action[0] instanceof Array && action.length > 1) {
              throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
            }
            switch (action[0]) {
              case 1:
                stack.push(symbol);
                vstack.push(this.lexer.yytext);
                lstack.push(this.lexer.yylloc);
                stack.push(action[1]);
                symbol = null;
                if (!preErrorSymbol) {
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  if (recovering > 0)
                    recovering--;
                } else {
                  symbol = preErrorSymbol;
                  preErrorSymbol = null;
                }
                break;
              case 2:
                len = this.productions_[action[1]][1];
                yyval.$ = vstack[vstack.length - len];
                yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                if (ranges) {
                  yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                }
                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                if (typeof r !== "undefined") {
                  return r;
                }
                if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
                }
                stack.push(this.productions_[action[1]][0]);
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);
                break;
              case 3:
                return true;
            }
          }
          return true;
        }
      };
      var lexer = function() {
        var lexer2 = {
          EOF: 1,
          parseError: function parseError(str, hash) {
            if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
            } else {
              throw new Error(str);
            }
          },
          setInput: function setInput(input) {
            this._input = input;
            this._more = this._less = this.done = false;
            this.yylineno = this.yyleng = 0;
            this.yytext = this.matched = this.match = "";
            this.conditionStack = ["INITIAL"];
            this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
            if (this.options.ranges)
              this.yylloc.range = [0, 0];
            this.offset = 0;
            return this;
          },
          input: function input() {
            var ch = this._input[0];
            this.yytext += ch;
            this.yyleng++;
            this.offset++;
            this.match += ch;
            this.matched += ch;
            var lines = ch.match(/(?:\r\n?|\n).*/g);
            if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
            } else {
              this.yylloc.last_column++;
            }
            if (this.options.ranges)
              this.yylloc.range[1]++;
            this._input = this._input.slice(1);
            return ch;
          },
          unput: function unput(ch) {
            var len = ch.length;
            var lines = ch.split(/(?:\r\n?|\n)/g);
            this._input = ch + this._input;
            this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
            this.offset -= len;
            var oldLines = this.match.split(/(?:\r\n?|\n)/g);
            this.match = this.match.substr(0, this.match.length - 1);
            this.matched = this.matched.substr(0, this.matched.length - 1);
            if (lines.length - 1)
              this.yylineno -= lines.length - 1;
            var r = this.yylloc.range;
            this.yylloc = {
              first_line: this.yylloc.first_line,
              last_line: this.yylineno + 1,
              first_column: this.yylloc.first_column,
              last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
            };
            if (this.options.ranges) {
              this.yylloc.range = [r[0], r[0] + this.yyleng - len];
            }
            return this;
          },
          more: function more() {
            this._more = true;
            return this;
          },
          less: function less(n) {
            this.unput(this.match.slice(n));
          },
          pastInput: function pastInput() {
            var past = this.matched.substr(0, this.matched.length - this.match.length);
            return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
          },
          upcomingInput: function upcomingInput() {
            var next = this.match;
            if (next.length < 20) {
              next += this._input.substr(0, 20 - next.length);
            }
            return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
          },
          showPosition: function showPosition() {
            var pre = this.pastInput();
            var c = new Array(pre.length + 1).join("-");
            return pre + this.upcomingInput() + "\n" + c + "^";
          },
          next: function next() {
            if (this.done) {
              return this.EOF;
            }
            if (!this._input)
              this.done = true;
            var token, match, tempMatch, index, col, lines;
            if (!this._more) {
              this.yytext = "";
              this.match = "";
            }
            var rules = this._currentRules();
            for (var i = 0; i < rules.length; i++) {
              tempMatch = this._input.match(this.rules[rules[i]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (!this.options.flex)
                  break;
              }
            }
            if (match) {
              lines = match[0].match(/(?:\r\n?|\n).*/g);
              if (lines)
                this.yylineno += lines.length;
              this.yylloc = {
                first_line: this.yylloc.last_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.last_column,
                last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
              };
              this.yytext += match[0];
              this.match += match[0];
              this.matches = match;
              this.yyleng = this.yytext.length;
              if (this.options.ranges) {
                this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }
              this._more = false;
              this._input = this._input.slice(match[0].length);
              this.matched += match[0];
              token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
              if (this.done && this._input)
                this.done = false;
              if (token)
                return token;
              else
                return;
            }
            if (this._input === "") {
              return this.EOF;
            } else {
              return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
            }
          },
          lex: function lex() {
            var r = this.next();
            if (typeof r !== "undefined") {
              return r;
            } else {
              return this.lex();
            }
          },
          begin: function begin(condition) {
            this.conditionStack.push(condition);
          },
          popState: function popState() {
            return this.conditionStack.pop();
          },
          _currentRules: function _currentRules() {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
          },
          topState: function topState() {
            return this.conditionStack[this.conditionStack.length - 2];
          },
          pushState: function begin(condition) {
            this.begin(condition);
          }
        };
        lexer2.options = {};
        lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          function strip(start, end) {
            return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
          }
          var YYSTATE = YY_START;
          switch ($avoiding_name_collisions) {
            case 0:
              if (yy_.yytext.slice(-2) === "\\\\") {
                strip(0, 1);
                this.begin("mu");
              } else if (yy_.yytext.slice(-1) === "\\") {
                strip(0, 1);
                this.begin("emu");
              } else {
                this.begin("mu");
              }
              if (yy_.yytext)
                return 15;
              break;
            case 1:
              return 15;
              break;
            case 2:
              this.popState();
              return 15;
              break;
            case 3:
              this.begin("raw");
              return 15;
              break;
            case 4:
              this.popState();
              if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
                return 15;
              } else {
                strip(5, 9);
                return "END_RAW_BLOCK";
              }
              break;
            case 5:
              return 15;
              break;
            case 6:
              this.popState();
              return 14;
              break;
            case 7:
              return 65;
              break;
            case 8:
              return 68;
              break;
            case 9:
              return 19;
              break;
            case 10:
              this.popState();
              this.begin("raw");
              return 23;
              break;
            case 11:
              return 55;
              break;
            case 12:
              return 60;
              break;
            case 13:
              return 29;
              break;
            case 14:
              return 47;
              break;
            case 15:
              this.popState();
              return 44;
              break;
            case 16:
              this.popState();
              return 44;
              break;
            case 17:
              return 34;
              break;
            case 18:
              return 39;
              break;
            case 19:
              return 51;
              break;
            case 20:
              return 48;
              break;
            case 21:
              this.unput(yy_.yytext);
              this.popState();
              this.begin("com");
              break;
            case 22:
              this.popState();
              return 14;
              break;
            case 23:
              return 48;
              break;
            case 24:
              return 73;
              break;
            case 25:
              return 72;
              break;
            case 26:
              return 72;
              break;
            case 27:
              return 87;
              break;
            case 28:
              break;
            case 29:
              this.popState();
              return 54;
              break;
            case 30:
              this.popState();
              return 33;
              break;
            case 31:
              yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
              return 80;
              break;
            case 32:
              yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
              return 80;
              break;
            case 33:
              return 85;
              break;
            case 34:
              return 82;
              break;
            case 35:
              return 82;
              break;
            case 36:
              return 83;
              break;
            case 37:
              return 84;
              break;
            case 38:
              return 81;
              break;
            case 39:
              return 75;
              break;
            case 40:
              return 77;
              break;
            case 41:
              return 72;
              break;
            case 42:
              yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
              return 72;
              break;
            case 43:
              return "INVALID";
              break;
            case 44:
              return 5;
              break;
          }
        };
        lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
        lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
        return lexer2;
      }();
      parser.lexer = lexer;
      function Parser3() {
        this.yy = {};
      }
      Parser3.prototype = parser;
      parser.Parser = Parser3;
      return new Parser3();
    }();
    exports["default"] = handlebars;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js
var require_visitor = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    function Visitor() {
      this.parents = [];
    }
    Visitor.prototype = {
      constructor: Visitor,
      mutating: false,
      // Visits a given value. If mutating, will replace the value if necessary.
      acceptKey: function acceptKey(node, name) {
        var value = this.accept(node[name]);
        if (this.mutating) {
          if (value && !Visitor.prototype[value.type]) {
            throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node.type);
          }
          node[name] = value;
        }
      },
      // Performs an accept operation with added sanity check to ensure
      // required keys are not removed.
      acceptRequired: function acceptRequired(node, name) {
        this.acceptKey(node, name);
        if (!node[name]) {
          throw new _exception2["default"](node.type + " requires " + name);
        }
      },
      // Traverses a given array. If mutating, empty respnses will be removed
      // for child elements.
      acceptArray: function acceptArray(array) {
        for (var i = 0, l = array.length; i < l; i++) {
          this.acceptKey(array, i);
          if (!array[i]) {
            array.splice(i, 1);
            i--;
            l--;
          }
        }
      },
      accept: function accept(object) {
        if (!object) {
          return;
        }
        if (!this[object.type]) {
          throw new _exception2["default"]("Unknown type: " + object.type, object);
        }
        if (this.current) {
          this.parents.unshift(this.current);
        }
        this.current = object;
        var ret = this[object.type](object);
        this.current = this.parents.shift();
        if (!this.mutating || ret) {
          return ret;
        } else if (ret !== false) {
          return object;
        }
      },
      Program: function Program(program) {
        this.acceptArray(program.body);
      },
      MustacheStatement: visitSubExpression,
      Decorator: visitSubExpression,
      BlockStatement: visitBlock,
      DecoratorBlock: visitBlock,
      PartialStatement: visitPartial,
      PartialBlockStatement: function PartialBlockStatement(partial) {
        visitPartial.call(this, partial);
        this.acceptKey(partial, "program");
      },
      ContentStatement: function ContentStatement() {
      },
      CommentStatement: function CommentStatement() {
      },
      SubExpression: visitSubExpression,
      PathExpression: function PathExpression() {
      },
      StringLiteral: function StringLiteral() {
      },
      NumberLiteral: function NumberLiteral() {
      },
      BooleanLiteral: function BooleanLiteral() {
      },
      UndefinedLiteral: function UndefinedLiteral() {
      },
      NullLiteral: function NullLiteral() {
      },
      Hash: function Hash(hash) {
        this.acceptArray(hash.pairs);
      },
      HashPair: function HashPair(pair) {
        this.acceptRequired(pair, "value");
      }
    };
    function visitSubExpression(mustache) {
      this.acceptRequired(mustache, "path");
      this.acceptArray(mustache.params);
      this.acceptKey(mustache, "hash");
    }
    function visitBlock(block) {
      visitSubExpression.call(this, block);
      this.acceptKey(block, "program");
      this.acceptKey(block, "inverse");
    }
    function visitPartial(partial) {
      this.acceptRequired(partial, "name");
      this.acceptArray(partial.params);
      this.acceptKey(partial, "hash");
    }
    exports["default"] = Visitor;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js
var require_whitespace_control = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _visitor = require_visitor();
    var _visitor2 = _interopRequireDefault(_visitor);
    function WhitespaceControl() {
      var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
      this.options = options;
    }
    WhitespaceControl.prototype = new _visitor2["default"]();
    WhitespaceControl.prototype.Program = function(program) {
      var doStandalone = !this.options.ignoreStandalone;
      var isRoot = !this.isRootSeen;
      this.isRootSeen = true;
      var body = program.body;
      for (var i = 0, l = body.length; i < l; i++) {
        var current = body[i], strip = this.accept(current);
        if (!strip) {
          continue;
        }
        var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
        if (strip.close) {
          omitRight(body, i, true);
        }
        if (strip.open) {
          omitLeft(body, i, true);
        }
        if (doStandalone && inlineStandalone) {
          omitRight(body, i);
          if (omitLeft(body, i)) {
            if (current.type === "PartialStatement") {
              current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
            }
          }
        }
        if (doStandalone && openStandalone) {
          omitRight((current.program || current.inverse).body);
          omitLeft(body, i);
        }
        if (doStandalone && closeStandalone) {
          omitRight(body, i);
          omitLeft((current.inverse || current.program).body);
        }
      }
      return program;
    };
    WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block) {
      this.accept(block.program);
      this.accept(block.inverse);
      var program = block.program || block.inverse, inverse = block.program && block.inverse, firstInverse = inverse, lastInverse = inverse;
      if (inverse && inverse.chained) {
        firstInverse = inverse.body[0].program;
        while (lastInverse.chained) {
          lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
        }
      }
      var strip = {
        open: block.openStrip.open,
        close: block.closeStrip.close,
        // Determine the standalone candiacy. Basically flag our content as being possibly standalone
        // so our parent can determine if we actually are standalone
        openStandalone: isNextWhitespace(program.body),
        closeStandalone: isPrevWhitespace((firstInverse || program).body)
      };
      if (block.openStrip.close) {
        omitRight(program.body, null, true);
      }
      if (inverse) {
        var inverseStrip = block.inverseStrip;
        if (inverseStrip.open) {
          omitLeft(program.body, null, true);
        }
        if (inverseStrip.close) {
          omitRight(firstInverse.body, null, true);
        }
        if (block.closeStrip.open) {
          omitLeft(lastInverse.body, null, true);
        }
        if (!this.options.ignoreStandalone && isPrevWhitespace(program.body) && isNextWhitespace(firstInverse.body)) {
          omitLeft(program.body);
          omitRight(firstInverse.body);
        }
      } else if (block.closeStrip.open) {
        omitLeft(program.body, null, true);
      }
      return strip;
    };
    WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
      return mustache.strip;
    };
    WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
      var strip = node.strip || {};
      return {
        inlineStandalone: true,
        open: strip.open,
        close: strip.close
      };
    };
    function isPrevWhitespace(body, i, isRoot) {
      if (i === void 0) {
        i = body.length;
      }
      var prev = body[i - 1], sibling = body[i - 2];
      if (!prev) {
        return isRoot;
      }
      if (prev.type === "ContentStatement") {
        return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
      }
    }
    function isNextWhitespace(body, i, isRoot) {
      if (i === void 0) {
        i = -1;
      }
      var next = body[i + 1], sibling = body[i + 2];
      if (!next) {
        return isRoot;
      }
      if (next.type === "ContentStatement") {
        return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
      }
    }
    function omitRight(body, i, multiple) {
      var current = body[i == null ? 0 : i + 1];
      if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
        return;
      }
      var original = current.value;
      current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
      current.rightStripped = current.value !== original;
    }
    function omitLeft(body, i, multiple) {
      var current = body[i == null ? body.length - 1 : i - 1];
      if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
        return;
      }
      var original = current.value;
      current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
      current.leftStripped = current.value !== original;
      return current.leftStripped;
    }
    exports["default"] = WhitespaceControl;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.SourceLocation = SourceLocation;
    exports.id = id;
    exports.stripFlags = stripFlags;
    exports.stripComment = stripComment;
    exports.preparePath = preparePath;
    exports.prepareMustache = prepareMustache;
    exports.prepareRawBlock = prepareRawBlock;
    exports.prepareBlock = prepareBlock;
    exports.prepareProgram = prepareProgram;
    exports.preparePartialBlock = preparePartialBlock;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    function validateClose(open, close) {
      close = close.path ? close.path.original : close;
      if (open.path.original !== close) {
        var errorNode = { loc: open.path.loc };
        throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
      }
    }
    function SourceLocation(source, locInfo) {
      this.source = source;
      this.start = {
        line: locInfo.first_line,
        column: locInfo.first_column
      };
      this.end = {
        line: locInfo.last_line,
        column: locInfo.last_column
      };
    }
    function id(token) {
      if (/^\[.*\]$/.test(token)) {
        return token.substring(1, token.length - 1);
      } else {
        return token;
      }
    }
    function stripFlags(open, close) {
      return {
        open: open.charAt(2) === "~",
        close: close.charAt(close.length - 3) === "~"
      };
    }
    function stripComment(comment) {
      return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
    }
    function preparePath(data, parts, loc) {
      loc = this.locInfo(loc);
      var original = data ? "@" : "", dig = [], depth = 0;
      for (var i = 0, l = parts.length; i < l; i++) {
        var part = parts[i].part, isLiteral = parts[i].original !== part;
        original += (parts[i].separator || "") + part;
        if (!isLiteral && (part === ".." || part === "." || part === "this")) {
          if (dig.length > 0) {
            throw new _exception2["default"]("Invalid path: " + original, { loc });
          } else if (part === "..") {
            depth++;
          }
        } else {
          dig.push(part);
        }
      }
      return {
        type: "PathExpression",
        data,
        depth,
        parts: dig,
        original,
        loc
      };
    }
    function prepareMustache(path, params, hash, open, strip, locInfo) {
      var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
      var decorator = /\*/.test(open);
      return {
        type: decorator ? "Decorator" : "MustacheStatement",
        path,
        params,
        hash,
        escaped,
        strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareRawBlock(openRawBlock, contents, close, locInfo) {
      validateClose(openRawBlock, close);
      locInfo = this.locInfo(locInfo);
      var program = {
        type: "Program",
        body: contents,
        strip: {},
        loc: locInfo
      };
      return {
        type: "BlockStatement",
        path: openRawBlock.path,
        params: openRawBlock.params,
        hash: openRawBlock.hash,
        program,
        openStrip: {},
        inverseStrip: {},
        closeStrip: {},
        loc: locInfo
      };
    }
    function prepareBlock(openBlock, program, inverseAndProgram, close, inverted, locInfo) {
      if (close && close.path) {
        validateClose(openBlock, close);
      }
      var decorator = /\*/.test(openBlock.open);
      program.blockParams = openBlock.blockParams;
      var inverse = void 0, inverseStrip = void 0;
      if (inverseAndProgram) {
        if (decorator) {
          throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
        }
        if (inverseAndProgram.chain) {
          inverseAndProgram.program.body[0].closeStrip = close.strip;
        }
        inverseStrip = inverseAndProgram.strip;
        inverse = inverseAndProgram.program;
      }
      if (inverted) {
        inverted = inverse;
        inverse = program;
        program = inverted;
      }
      return {
        type: decorator ? "DecoratorBlock" : "BlockStatement",
        path: openBlock.path,
        params: openBlock.params,
        hash: openBlock.hash,
        program,
        inverse,
        openStrip: openBlock.strip,
        inverseStrip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
    function prepareProgram(statements, loc) {
      if (!loc && statements.length) {
        var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
        if (firstLoc && lastLoc) {
          loc = {
            source: firstLoc.source,
            start: {
              line: firstLoc.start.line,
              column: firstLoc.start.column
            },
            end: {
              line: lastLoc.end.line,
              column: lastLoc.end.column
            }
          };
        }
      }
      return {
        type: "Program",
        body: statements,
        strip: {},
        loc
      };
    }
    function preparePartialBlock(open, program, close, locInfo) {
      validateClose(open, close);
      return {
        type: "PartialBlockStatement",
        name: open.path,
        params: open.params,
        hash: open.hash,
        program,
        openStrip: open.strip,
        closeStrip: close && close.strip,
        loc: this.locInfo(locInfo)
      };
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/base.js
var require_base2 = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/base.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.parseWithoutProcessing = parseWithoutProcessing;
    exports.parse = parse;
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key))
              newObj[key] = obj[key];
          }
        }
        newObj["default"] = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _parser = require_parser();
    var _parser2 = _interopRequireDefault(_parser);
    var _whitespaceControl = require_whitespace_control();
    var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
    var _helpers = require_helpers3();
    var Helpers = _interopRequireWildcard(_helpers);
    var _utils = require_utils2();
    exports.parser = _parser2["default"];
    var yy = {};
    _utils.extend(yy, Helpers);
    function parseWithoutProcessing(input, options) {
      if (input.type === "Program") {
        return input;
      }
      _parser2["default"].yy = yy;
      yy.locInfo = function(locInfo) {
        return new yy.SourceLocation(options && options.srcName, locInfo);
      };
      var ast = _parser2["default"].parse(input);
      return ast;
    }
    function parse(input, options) {
      var ast = parseWithoutProcessing(input, options);
      var strip = new _whitespaceControl2["default"](options);
      return strip.accept(ast);
    }
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js
var require_compiler = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js"(exports) {
    "use strict";
    exports.__esModule = true;
    exports.Compiler = Compiler;
    exports.precompile = precompile;
    exports.compile = compile;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _utils = require_utils2();
    var _ast = require_ast();
    var _ast2 = _interopRequireDefault(_ast);
    var slice = [].slice;
    function Compiler() {
    }
    Compiler.prototype = {
      compiler: Compiler,
      equals: function equals(other) {
        var len = this.opcodes.length;
        if (other.opcodes.length !== len) {
          return false;
        }
        for (var i = 0; i < len; i++) {
          var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
          if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
            return false;
          }
        }
        len = this.children.length;
        for (var i = 0; i < len; i++) {
          if (!this.children[i].equals(other.children[i])) {
            return false;
          }
        }
        return true;
      },
      guid: 0,
      compile: function compile2(program, options) {
        this.sourceNode = [];
        this.opcodes = [];
        this.children = [];
        this.options = options;
        this.stringParams = options.stringParams;
        this.trackIds = options.trackIds;
        options.blockParams = options.blockParams || [];
        options.knownHelpers = _utils.extend(/* @__PURE__ */ Object.create(null), {
          helperMissing: true,
          blockHelperMissing: true,
          each: true,
          "if": true,
          unless: true,
          "with": true,
          log: true,
          lookup: true
        }, options.knownHelpers);
        return this.accept(program);
      },
      compileProgram: function compileProgram(program) {
        var childCompiler = new this.compiler(), result = childCompiler.compile(program, this.options), guid = this.guid++;
        this.usePartial = this.usePartial || result.usePartial;
        this.children[guid] = result;
        this.useDepths = this.useDepths || result.useDepths;
        return guid;
      },
      accept: function accept(node) {
        if (!this[node.type]) {
          throw new _exception2["default"]("Unknown type: " + node.type, node);
        }
        this.sourceNode.unshift(node);
        var ret = this[node.type](node);
        this.sourceNode.shift();
        return ret;
      },
      Program: function Program(program) {
        this.options.blockParams.unshift(program.blockParams);
        var body = program.body, bodyLength = body.length;
        for (var i = 0; i < bodyLength; i++) {
          this.accept(body[i]);
        }
        this.options.blockParams.shift();
        this.isSimple = bodyLength === 1;
        this.blockParams = program.blockParams ? program.blockParams.length : 0;
        return this;
      },
      BlockStatement: function BlockStatement(block) {
        transformLiteralToPath(block);
        var program = block.program, inverse = block.inverse;
        program = program && this.compileProgram(program);
        inverse = inverse && this.compileProgram(inverse);
        var type = this.classifySexpr(block);
        if (type === "helper") {
          this.helperSexpr(block, program, inverse);
        } else if (type === "simple") {
          this.simpleSexpr(block);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("blockValue", block.path.original);
        } else {
          this.ambiguousSexpr(block, program, inverse);
          this.opcode("pushProgram", program);
          this.opcode("pushProgram", inverse);
          this.opcode("emptyHash");
          this.opcode("ambiguousBlockValue");
        }
        this.opcode("append");
      },
      DecoratorBlock: function DecoratorBlock(decorator) {
        var program = decorator.program && this.compileProgram(decorator.program);
        var params = this.setupFullMustacheParams(decorator, program, void 0), path = decorator.path;
        this.useDecorators = true;
        this.opcode("registerDecorator", params.length, path.original);
      },
      PartialStatement: function PartialStatement(partial) {
        this.usePartial = true;
        var program = partial.program;
        if (program) {
          program = this.compileProgram(partial.program);
        }
        var params = partial.params;
        if (params.length > 1) {
          throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
        } else if (!params.length) {
          if (this.options.explicitPartialContext) {
            this.opcode("pushLiteral", "undefined");
          } else {
            params.push({ type: "PathExpression", parts: [], depth: 0 });
          }
        }
        var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
        if (isDynamic) {
          this.accept(partial.name);
        }
        this.setupFullMustacheParams(partial, program, void 0, true);
        var indent = partial.indent || "";
        if (this.options.preventIndent && indent) {
          this.opcode("appendContent", indent);
          indent = "";
        }
        this.opcode("invokePartial", isDynamic, partialName, indent);
        this.opcode("append");
      },
      PartialBlockStatement: function PartialBlockStatement(partialBlock) {
        this.PartialStatement(partialBlock);
      },
      MustacheStatement: function MustacheStatement(mustache) {
        this.SubExpression(mustache);
        if (mustache.escaped && !this.options.noEscape) {
          this.opcode("appendEscaped");
        } else {
          this.opcode("append");
        }
      },
      Decorator: function Decorator(decorator) {
        this.DecoratorBlock(decorator);
      },
      ContentStatement: function ContentStatement(content) {
        if (content.value) {
          this.opcode("appendContent", content.value);
        }
      },
      CommentStatement: function CommentStatement() {
      },
      SubExpression: function SubExpression(sexpr) {
        transformLiteralToPath(sexpr);
        var type = this.classifySexpr(sexpr);
        if (type === "simple") {
          this.simpleSexpr(sexpr);
        } else if (type === "helper") {
          this.helperSexpr(sexpr);
        } else {
          this.ambiguousSexpr(sexpr);
        }
      },
      ambiguousSexpr: function ambiguousSexpr(sexpr, program, inverse) {
        var path = sexpr.path, name = path.parts[0], isBlock2 = program != null || inverse != null;
        this.opcode("getContext", path.depth);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        path.strict = true;
        this.accept(path);
        this.opcode("invokeAmbiguous", name, isBlock2);
      },
      simpleSexpr: function simpleSexpr(sexpr) {
        var path = sexpr.path;
        path.strict = true;
        this.accept(path);
        this.opcode("resolvePossibleLambda");
      },
      helperSexpr: function helperSexpr(sexpr, program, inverse) {
        var params = this.setupFullMustacheParams(sexpr, program, inverse), path = sexpr.path, name = path.parts[0];
        if (this.options.knownHelpers[name]) {
          this.opcode("invokeKnownHelper", params.length, name);
        } else if (this.options.knownHelpersOnly) {
          throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
        } else {
          path.strict = true;
          path.falsy = true;
          this.accept(path);
          this.opcode("invokeHelper", params.length, path.original, _ast2["default"].helpers.simpleId(path));
        }
      },
      PathExpression: function PathExpression(path) {
        this.addDepth(path.depth);
        this.opcode("getContext", path.depth);
        var name = path.parts[0], scoped = _ast2["default"].helpers.scopedId(path), blockParamId = !path.depth && !scoped && this.blockParamIndex(name);
        if (blockParamId) {
          this.opcode("lookupBlockParam", blockParamId, path.parts);
        } else if (!name) {
          this.opcode("pushContext");
        } else if (path.data) {
          this.options.data = true;
          this.opcode("lookupData", path.depth, path.parts, path.strict);
        } else {
          this.opcode("lookupOnContext", path.parts, path.falsy, path.strict, scoped);
        }
      },
      StringLiteral: function StringLiteral(string) {
        this.opcode("pushString", string.value);
      },
      NumberLiteral: function NumberLiteral(number) {
        this.opcode("pushLiteral", number.value);
      },
      BooleanLiteral: function BooleanLiteral(bool) {
        this.opcode("pushLiteral", bool.value);
      },
      UndefinedLiteral: function UndefinedLiteral() {
        this.opcode("pushLiteral", "undefined");
      },
      NullLiteral: function NullLiteral() {
        this.opcode("pushLiteral", "null");
      },
      Hash: function Hash(hash) {
        var pairs = hash.pairs, i = 0, l = pairs.length;
        this.opcode("pushHash");
        for (; i < l; i++) {
          this.pushParam(pairs[i].value);
        }
        while (i--) {
          this.opcode("assignToHash", pairs[i].key);
        }
        this.opcode("popHash");
      },
      // HELPERS
      opcode: function opcode(name) {
        this.opcodes.push({
          opcode: name,
          args: slice.call(arguments, 1),
          loc: this.sourceNode[0].loc
        });
      },
      addDepth: function addDepth(depth) {
        if (!depth) {
          return;
        }
        this.useDepths = true;
      },
      classifySexpr: function classifySexpr(sexpr) {
        var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
        var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
        var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
        var isEligible = !isBlockParam && (isHelper || isSimple);
        if (isEligible && !isHelper) {
          var _name = sexpr.path.parts[0], options = this.options;
          if (options.knownHelpers[_name]) {
            isHelper = true;
          } else if (options.knownHelpersOnly) {
            isEligible = false;
          }
        }
        if (isHelper) {
          return "helper";
        } else if (isEligible) {
          return "ambiguous";
        } else {
          return "simple";
        }
      },
      pushParams: function pushParams(params) {
        for (var i = 0, l = params.length; i < l; i++) {
          this.pushParam(params[i]);
        }
      },
      pushParam: function pushParam(val) {
        var value = val.value != null ? val.value : val.original || "";
        if (this.stringParams) {
          if (value.replace) {
            value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
          }
          if (val.depth) {
            this.addDepth(val.depth);
          }
          this.opcode("getContext", val.depth || 0);
          this.opcode("pushStringParam", value, val.type);
          if (val.type === "SubExpression") {
            this.accept(val);
          }
        } else {
          if (this.trackIds) {
            var blockParamIndex = void 0;
            if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
              blockParamIndex = this.blockParamIndex(val.parts[0]);
            }
            if (blockParamIndex) {
              var blockParamChild = val.parts.slice(1).join(".");
              this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
            } else {
              value = val.original || value;
              if (value.replace) {
                value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
              }
              this.opcode("pushId", val.type, value);
            }
          }
          this.accept(val);
        }
      },
      setupFullMustacheParams: function setupFullMustacheParams(sexpr, program, inverse, omitEmpty) {
        var params = sexpr.params;
        this.pushParams(params);
        this.opcode("pushProgram", program);
        this.opcode("pushProgram", inverse);
        if (sexpr.hash) {
          this.accept(sexpr.hash);
        } else {
          this.opcode("emptyHash", omitEmpty);
        }
        return params;
      },
      blockParamIndex: function blockParamIndex(name) {
        for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
          var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
          if (blockParams && param >= 0) {
            return [depth, param];
          }
        }
      }
    };
    function precompile(input, options, env) {
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
      }
      options = options || {};
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options);
      return new env.JavaScriptCompiler().compile(environment, options);
    }
    function compile(input, options, env) {
      if (options === void 0)
        options = {};
      if (input == null || typeof input !== "string" && input.type !== "Program") {
        throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
      }
      options = _utils.extend({}, options);
      if (!("data" in options)) {
        options.data = true;
      }
      if (options.compat) {
        options.useDepths = true;
      }
      var compiled = void 0;
      function compileInput() {
        var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
        return env.template(templateSpec);
      }
      function ret(context, execOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled.call(this, context, execOptions);
      }
      ret._setup = function(setupOptions) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._setup(setupOptions);
      };
      ret._child = function(i, data, blockParams, depths) {
        if (!compiled) {
          compiled = compileInput();
        }
        return compiled._child(i, data, blockParams, depths);
      };
      return ret;
    }
    function argEquals(a, b) {
      if (a === b) {
        return true;
      }
      if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
        for (var i = 0; i < a.length; i++) {
          if (!argEquals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
    }
    function transformLiteralToPath(sexpr) {
      if (!sexpr.path.parts) {
        var literal = sexpr.path;
        sexpr.path = {
          type: "PathExpression",
          data: false,
          depth: 0,
          parts: [literal.original + ""],
          original: literal.original + "",
          loc: literal.loc
        };
      }
    }
  }
});

// node_modules/handlebars/node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/handlebars/node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/handlebars/node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/handlebars/node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/handlebars/node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/handlebars/node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/handlebars/node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/handlebars/node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/handlebars/node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/handlebars/node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/handlebars/node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/handlebars/node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/handlebars/node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/handlebars/node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/handlebars/node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/handlebars/node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p, r) {
      if (p < r) {
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
        swap(ary, i + 1, j);
        var q = i + 1;
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/handlebars/node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/handlebars/node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c = aStr.charAt(index);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file = util.getArg(sourceMap, "file", null);
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url;
      if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version != this._version) {
        throw new Error("Unsupported version: " + version);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset, "line");
        var offsetColumn = util.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/handlebars/node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/handlebars/node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null)
        this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/handlebars/node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/handlebars/node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js
var require_code_gen = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    var _utils = require_utils2();
    var SourceNode = void 0;
    try {
      if (typeof define !== "function" || !define.amd) {
        SourceMap = require_source_map();
        SourceNode = SourceMap.SourceNode;
      }
    } catch (err) {
    }
    var SourceMap;
    if (!SourceNode) {
      SourceNode = function(line, column, srcFile, chunks) {
        this.src = "";
        if (chunks) {
          this.add(chunks);
        }
      };
      SourceNode.prototype = {
        add: function add(chunks) {
          if (_utils.isArray(chunks)) {
            chunks = chunks.join("");
          }
          this.src += chunks;
        },
        prepend: function prepend(chunks) {
          if (_utils.isArray(chunks)) {
            chunks = chunks.join("");
          }
          this.src = chunks + this.src;
        },
        toStringWithSourceMap: function toStringWithSourceMap() {
          return { code: this.toString() };
        },
        toString: function toString() {
          return this.src;
        }
      };
    }
    function castChunk(chunk, codeGen, loc) {
      if (_utils.isArray(chunk)) {
        var ret = [];
        for (var i = 0, len = chunk.length; i < len; i++) {
          ret.push(codeGen.wrap(chunk[i], loc));
        }
        return ret;
      } else if (typeof chunk === "boolean" || typeof chunk === "number") {
        return chunk + "";
      }
      return chunk;
    }
    function CodeGen(srcFile) {
      this.srcFile = srcFile;
      this.source = [];
    }
    CodeGen.prototype = {
      isEmpty: function isEmpty() {
        return !this.source.length;
      },
      prepend: function prepend(source, loc) {
        this.source.unshift(this.wrap(source, loc));
      },
      push: function push(source, loc) {
        this.source.push(this.wrap(source, loc));
      },
      merge: function merge2() {
        var source = this.empty();
        this.each(function(line) {
          source.add(["  ", line, "\n"]);
        });
        return source;
      },
      each: function each(iter) {
        for (var i = 0, len = this.source.length; i < len; i++) {
          iter(this.source[i]);
        }
      },
      empty: function empty() {
        var loc = this.currentLocation || { start: {} };
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
      },
      wrap: function wrap(chunk) {
        var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
        if (chunk instanceof SourceNode) {
          return chunk;
        }
        chunk = castChunk(chunk, this, loc);
        return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
      },
      functionCall: function functionCall(fn, type, params) {
        params = this.generateList(params);
        return this.wrap([fn, type ? "." + type + "(" : "(", params, ")"]);
      },
      quotedString: function quotedString(str) {
        return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
      },
      objectLiteral: function objectLiteral(obj) {
        var _this = this;
        var pairs = [];
        Object.keys(obj).forEach(function(key) {
          var value = castChunk(obj[key], _this);
          if (value !== "undefined") {
            pairs.push([_this.quotedString(key), ":", value]);
          }
        });
        var ret = this.generateList(pairs);
        ret.prepend("{");
        ret.add("}");
        return ret;
      },
      generateList: function generateList(entries) {
        var ret = this.empty();
        for (var i = 0, len = entries.length; i < len; i++) {
          if (i) {
            ret.add(",");
          }
          ret.add(castChunk(entries[i], this));
        }
        return ret;
      },
      generateArray: function generateArray(entries) {
        var ret = this.generateList(entries);
        ret.prepend("[");
        ret.add("]");
        return ret;
      }
    };
    exports["default"] = CodeGen;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js
var require_javascript_compiler = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _base = require_base();
    var _exception = require_exception();
    var _exception2 = _interopRequireDefault(_exception);
    var _utils = require_utils2();
    var _codeGen = require_code_gen();
    var _codeGen2 = _interopRequireDefault(_codeGen);
    function Literal(value) {
      this.value = value;
    }
    function JavaScriptCompiler() {
    }
    JavaScriptCompiler.prototype = {
      // PUBLIC API: You can override these methods in a subclass to provide
      // alternative compiled forms for name lookup and buffering semantics
      nameLookup: function nameLookup(parent, name) {
        return this.internalNameLookup(parent, name);
      },
      depthedLookup: function depthedLookup(name) {
        return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
      },
      compilerInfo: function compilerInfo() {
        var revision = _base.COMPILER_REVISION, versions = _base.REVISION_CHANGES[revision];
        return [revision, versions];
      },
      appendToBuffer: function appendToBuffer(source, location, explicit) {
        if (!_utils.isArray(source)) {
          source = [source];
        }
        source = this.source.wrap(source, location);
        if (this.environment.isSimple) {
          return ["return ", source, ";"];
        } else if (explicit) {
          return ["buffer += ", source, ";"];
        } else {
          source.appendToBuffer = true;
          return source;
        }
      },
      initializeBuffer: function initializeBuffer() {
        return this.quotedString("");
      },
      // END PUBLIC API
      internalNameLookup: function internalNameLookup(parent, name) {
        this.lookupPropertyFunctionIsUsed = true;
        return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
      },
      lookupPropertyFunctionIsUsed: false,
      compile: function compile(environment, options, context, asObject) {
        this.environment = environment;
        this.options = options;
        this.stringParams = this.options.stringParams;
        this.trackIds = this.options.trackIds;
        this.precompile = !asObject;
        this.name = this.environment.name;
        this.isChild = !!context;
        this.context = context || {
          decorators: [],
          programs: [],
          environments: []
        };
        this.preamble();
        this.stackSlot = 0;
        this.stackVars = [];
        this.aliases = {};
        this.registers = { list: [] };
        this.hashes = [];
        this.compileStack = [];
        this.inlineStack = [];
        this.blockParams = [];
        this.compileChildren(environment, options);
        this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
        this.useBlockParams = this.useBlockParams || environment.useBlockParams;
        var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i = void 0, l = void 0;
        for (i = 0, l = opcodes.length; i < l; i++) {
          opcode = opcodes[i];
          this.source.currentLocation = opcode.loc;
          firstLoc = firstLoc || opcode.loc;
          this[opcode.opcode].apply(this, opcode.args);
        }
        this.source.currentLocation = firstLoc;
        this.pushSource("");
        if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
          throw new _exception2["default"]("Compile completed with content left on stack");
        }
        if (!this.decorators.isEmpty()) {
          this.useDecorators = true;
          this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
          this.decorators.push("return fn;");
          if (asObject) {
            this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
          } else {
            this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
            this.decorators.push("}\n");
            this.decorators = this.decorators.merge();
          }
        } else {
          this.decorators = void 0;
        }
        var fn = this.createFunctionContext(asObject);
        if (!this.isChild) {
          var ret = {
            compiler: this.compilerInfo(),
            main: fn
          };
          if (this.decorators) {
            ret.main_d = this.decorators;
            ret.useDecorators = true;
          }
          var _context = this.context;
          var programs = _context.programs;
          var decorators = _context.decorators;
          for (i = 0, l = programs.length; i < l; i++) {
            if (programs[i]) {
              ret[i] = programs[i];
              if (decorators[i]) {
                ret[i + "_d"] = decorators[i];
                ret.useDecorators = true;
              }
            }
          }
          if (this.environment.usePartial) {
            ret.usePartial = true;
          }
          if (this.options.data) {
            ret.useData = true;
          }
          if (this.useDepths) {
            ret.useDepths = true;
          }
          if (this.useBlockParams) {
            ret.useBlockParams = true;
          }
          if (this.options.compat) {
            ret.compat = true;
          }
          if (!asObject) {
            ret.compiler = JSON.stringify(ret.compiler);
            this.source.currentLocation = { start: { line: 1, column: 0 } };
            ret = this.objectLiteral(ret);
            if (options.srcName) {
              ret = ret.toStringWithSourceMap({ file: options.destName });
              ret.map = ret.map && ret.map.toString();
            } else {
              ret = ret.toString();
            }
          } else {
            ret.compilerOptions = this.options;
          }
          return ret;
        } else {
          return fn;
        }
      },
      preamble: function preamble() {
        this.lastContext = 0;
        this.source = new _codeGen2["default"](this.options.srcName);
        this.decorators = new _codeGen2["default"](this.options.srcName);
      },
      createFunctionContext: function createFunctionContext(asObject) {
        var _this = this;
        var varDeclarations = "";
        var locals = this.stackVars.concat(this.registers.list);
        if (locals.length > 0) {
          varDeclarations += ", " + locals.join(", ");
        }
        var aliasCount = 0;
        Object.keys(this.aliases).forEach(function(alias) {
          var node = _this.aliases[alias];
          if (node.children && node.referenceCount > 1) {
            varDeclarations += ", alias" + ++aliasCount + "=" + alias;
            node.children[0] = "alias" + aliasCount;
          }
        });
        if (this.lookupPropertyFunctionIsUsed) {
          varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
        }
        var params = ["container", "depth0", "helpers", "partials", "data"];
        if (this.useBlockParams || this.useDepths) {
          params.push("blockParams");
        }
        if (this.useDepths) {
          params.push("depths");
        }
        var source = this.mergeSource(varDeclarations);
        if (asObject) {
          params.push(source);
          return Function.apply(this, params);
        } else {
          return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
        }
      },
      mergeSource: function mergeSource(varDeclarations) {
        var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
        this.source.each(function(line) {
          if (line.appendToBuffer) {
            if (bufferStart) {
              line.prepend("  + ");
            } else {
              bufferStart = line;
            }
            bufferEnd = line;
          } else {
            if (bufferStart) {
              if (!sourceSeen) {
                appendFirst = true;
              } else {
                bufferStart.prepend("buffer += ");
              }
              bufferEnd.add(";");
              bufferStart = bufferEnd = void 0;
            }
            sourceSeen = true;
            if (!isSimple) {
              appendOnly = false;
            }
          }
        });
        if (appendOnly) {
          if (bufferStart) {
            bufferStart.prepend("return ");
            bufferEnd.add(";");
          } else if (!sourceSeen) {
            this.source.push('return "";');
          }
        } else {
          varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
          if (bufferStart) {
            bufferStart.prepend("return buffer + ");
            bufferEnd.add(";");
          } else {
            this.source.push("return buffer;");
          }
        }
        if (varDeclarations) {
          this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
        }
        return this.source.merge();
      },
      lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
        return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
      },
      // [blockValue]
      //
      // On stack, before: hash, inverse, program, value
      // On stack, after: return value of blockHelperMissing
      //
      // The purpose of this opcode is to take a block of the form
      // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
      // replace it on the stack with the result of properly
      // invoking blockHelperMissing.
      blockValue: function blockValue(name) {
        var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
        this.setupHelperArgs(name, 0, params);
        var blockName = this.popStack();
        params.splice(1, 0, blockName);
        this.push(this.source.functionCall(blockHelperMissing, "call", params));
      },
      // [ambiguousBlockValue]
      //
      // On stack, before: hash, inverse, program, value
      // Compiler value, before: lastHelper=value of last found helper, if any
      // On stack, after, if no lastHelper: same as [blockValue]
      // On stack, after, if lastHelper: value
      ambiguousBlockValue: function ambiguousBlockValue() {
        var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
        this.setupHelperArgs("", 0, params, true);
        this.flushInline();
        var current = this.topStack();
        params.splice(1, 0, current);
        this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing, "call", params), "}"]);
      },
      // [appendContent]
      //
      // On stack, before: ...
      // On stack, after: ...
      //
      // Appends the string value of `content` to the current buffer
      appendContent: function appendContent(content) {
        if (this.pendingContent) {
          content = this.pendingContent + content;
        } else {
          this.pendingLocation = this.source.currentLocation;
        }
        this.pendingContent = content;
      },
      // [append]
      //
      // On stack, before: value, ...
      // On stack, after: ...
      //
      // Coerces `value` to a String and appends it to the current buffer.
      //
      // If `value` is truthy, or 0, it is coerced into a string and appended
      // Otherwise, the empty string is appended
      append: function append() {
        if (this.isInline()) {
          this.replaceStack(function(current) {
            return [" != null ? ", current, ' : ""'];
          });
          this.pushSource(this.appendToBuffer(this.popStack()));
        } else {
          var local = this.popStack();
          this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
          if (this.environment.isSimple) {
            this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
          }
        }
      },
      // [appendEscaped]
      //
      // On stack, before: value, ...
      // On stack, after: ...
      //
      // Escape `value` and append it to the buffer
      appendEscaped: function appendEscaped() {
        this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
      },
      // [getContext]
      //
      // On stack, before: ...
      // On stack, after: ...
      // Compiler value, after: lastContext=depth
      //
      // Set the value of the `lastContext` compiler value to the depth
      getContext: function getContext(depth) {
        this.lastContext = depth;
      },
      // [pushContext]
      //
      // On stack, before: ...
      // On stack, after: currentContext, ...
      //
      // Pushes the value of the current context onto the stack.
      pushContext: function pushContext() {
        this.pushStackLiteral(this.contextName(this.lastContext));
      },
      // [lookupOnContext]
      //
      // On stack, before: ...
      // On stack, after: currentContext[name], ...
      //
      // Looks up the value of `name` on the current context and pushes
      // it onto the stack.
      lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
        var i = 0;
        if (!scoped && this.options.compat && !this.lastContext) {
          this.push(this.depthedLookup(parts[i++]));
        } else {
          this.pushContext();
        }
        this.resolvePath("context", parts, i, falsy, strict);
      },
      // [lookupBlockParam]
      //
      // On stack, before: ...
      // On stack, after: blockParam[name], ...
      //
      // Looks up the value of `parts` on the given block param and pushes
      // it onto the stack.
      lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
        this.useBlockParams = true;
        this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
        this.resolvePath("context", parts, 1);
      },
      // [lookupData]
      //
      // On stack, before: ...
      // On stack, after: data, ...
      //
      // Push the data lookup operator
      lookupData: function lookupData(depth, parts, strict) {
        if (!depth) {
          this.pushStackLiteral("data");
        } else {
          this.pushStackLiteral("container.data(data, " + depth + ")");
        }
        this.resolvePath("data", parts, 0, true, strict);
      },
      resolvePath: function resolvePath2(type, parts, i, falsy, strict) {
        var _this2 = this;
        if (this.options.strict || this.options.assumeObjects) {
          this.push(strictLookup(this.options.strict && strict, this, parts, i, type));
          return;
        }
        var len = parts.length;
        for (; i < len; i++) {
          this.replaceStack(function(current) {
            var lookup2 = _this2.nameLookup(current, parts[i], type);
            if (!falsy) {
              return [" != null ? ", lookup2, " : ", current];
            } else {
              return [" && ", lookup2];
            }
          });
        }
      },
      // [resolvePossibleLambda]
      //
      // On stack, before: value, ...
      // On stack, after: resolved value, ...
      //
      // If the `value` is a lambda, replace it on the stack by
      // the return value of the lambda
      resolvePossibleLambda: function resolvePossibleLambda() {
        this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
      },
      // [pushStringParam]
      //
      // On stack, before: ...
      // On stack, after: string, currentContext, ...
      //
      // This opcode is designed for use in string mode, which
      // provides the string value of a parameter along with its
      // depth rather than resolving it immediately.
      pushStringParam: function pushStringParam(string, type) {
        this.pushContext();
        this.pushString(type);
        if (type !== "SubExpression") {
          if (typeof string === "string") {
            this.pushString(string);
          } else {
            this.pushStackLiteral(string);
          }
        }
      },
      emptyHash: function emptyHash(omitEmpty) {
        if (this.trackIds) {
          this.push("{}");
        }
        if (this.stringParams) {
          this.push("{}");
          this.push("{}");
        }
        this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
      },
      pushHash: function pushHash() {
        if (this.hash) {
          this.hashes.push(this.hash);
        }
        this.hash = { values: {}, types: [], contexts: [], ids: [] };
      },
      popHash: function popHash() {
        var hash = this.hash;
        this.hash = this.hashes.pop();
        if (this.trackIds) {
          this.push(this.objectLiteral(hash.ids));
        }
        if (this.stringParams) {
          this.push(this.objectLiteral(hash.contexts));
          this.push(this.objectLiteral(hash.types));
        }
        this.push(this.objectLiteral(hash.values));
      },
      // [pushString]
      //
      // On stack, before: ...
      // On stack, after: quotedString(string), ...
      //
      // Push a quoted version of `string` onto the stack
      pushString: function pushString(string) {
        this.pushStackLiteral(this.quotedString(string));
      },
      // [pushLiteral]
      //
      // On stack, before: ...
      // On stack, after: value, ...
      //
      // Pushes a value onto the stack. This operation prevents
      // the compiler from creating a temporary variable to hold
      // it.
      pushLiteral: function pushLiteral(value) {
        this.pushStackLiteral(value);
      },
      // [pushProgram]
      //
      // On stack, before: ...
      // On stack, after: program(guid), ...
      //
      // Push a program expression onto the stack. This takes
      // a compile-time guid and converts it into a runtime-accessible
      // expression.
      pushProgram: function pushProgram(guid) {
        if (guid != null) {
          this.pushStackLiteral(this.programExpression(guid));
        } else {
          this.pushStackLiteral(null);
        }
      },
      // [registerDecorator]
      //
      // On stack, before: hash, program, params..., ...
      // On stack, after: ...
      //
      // Pops off the decorator's parameters, invokes the decorator,
      // and inserts the decorator into the decorators list.
      registerDecorator: function registerDecorator(paramSize, name) {
        var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
        this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
      },
      // [invokeHelper]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of helper invocation
      //
      // Pops off the helper's parameters, invokes the helper,
      // and pushes the helper's return value onto the stack.
      //
      // If the helper is not found, `helperMissing` is called.
      invokeHelper: function invokeHelper(paramSize, name, isSimple) {
        var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
        var possibleFunctionCalls = [];
        if (isSimple) {
          possibleFunctionCalls.push(helper.name);
        }
        possibleFunctionCalls.push(nonHelper);
        if (!this.options.strict) {
          possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
        }
        var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
        var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
        this.push(functionCall);
      },
      itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
        var result = [];
        result.push(items[0]);
        for (var i = 1; i < items.length; i++) {
          result.push(separator, items[i]);
        }
        return result;
      },
      // [invokeKnownHelper]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of helper invocation
      //
      // This operation is used when the helper is known to exist,
      // so a `helperMissing` fallback is not required.
      invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
        var helper = this.setupHelper(paramSize, name);
        this.push(this.source.functionCall(helper.name, "call", helper.callParams));
      },
      // [invokeAmbiguous]
      //
      // On stack, before: hash, inverse, program, params..., ...
      // On stack, after: result of disambiguation
      //
      // This operation is used when an expression like `{{foo}}`
      // is provided, but we don't know at compile-time whether it
      // is a helper or a path.
      //
      // This operation emits more code than the other options,
      // and can be avoided by passing the `knownHelpers` and
      // `knownHelpersOnly` flags at compile-time.
      invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
        this.useRegister("helper");
        var nonHelper = this.popStack();
        this.emptyHash();
        var helper = this.setupHelper(0, name, helperCall);
        var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
        var lookup2 = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
        if (!this.options.strict) {
          lookup2[0] = "(helper = ";
          lookup2.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
        }
        this.push(["(", lookup2, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
      },
      // [invokePartial]
      //
      // On stack, before: context, ...
      // On stack after: result of partial invocation
      //
      // This operation pops off a context, invokes a partial with that context,
      // and pushes the result of the invocation back.
      invokePartial: function invokePartial(isDynamic, name, indent) {
        var params = [], options = this.setupParams(name, 1, params);
        if (isDynamic) {
          name = this.popStack();
          delete options.name;
        }
        if (indent) {
          options.indent = JSON.stringify(indent);
        }
        options.helpers = "helpers";
        options.partials = "partials";
        options.decorators = "container.decorators";
        if (!isDynamic) {
          params.unshift(this.nameLookup("partials", name, "partial"));
        } else {
          params.unshift(name);
        }
        if (this.options.compat) {
          options.depths = "depths";
        }
        options = this.objectLiteral(options);
        params.push(options);
        this.push(this.source.functionCall("container.invokePartial", "", params));
      },
      // [assignToHash]
      //
      // On stack, before: value, ..., hash, ...
      // On stack, after: ..., hash, ...
      //
      // Pops a value off the stack and assigns it to the current hash
      assignToHash: function assignToHash(key) {
        var value = this.popStack(), context = void 0, type = void 0, id = void 0;
        if (this.trackIds) {
          id = this.popStack();
        }
        if (this.stringParams) {
          type = this.popStack();
          context = this.popStack();
        }
        var hash = this.hash;
        if (context) {
          hash.contexts[key] = context;
        }
        if (type) {
          hash.types[key] = type;
        }
        if (id) {
          hash.ids[key] = id;
        }
        hash.values[key] = value;
      },
      pushId: function pushId(type, name, child) {
        if (type === "BlockParam") {
          this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
        } else if (type === "PathExpression") {
          this.pushString(name);
        } else if (type === "SubExpression") {
          this.pushStackLiteral("true");
        } else {
          this.pushStackLiteral("null");
        }
      },
      // HELPERS
      compiler: JavaScriptCompiler,
      compileChildren: function compileChildren(environment, options) {
        var children = environment.children, child = void 0, compiler = void 0;
        for (var i = 0, l = children.length; i < l; i++) {
          child = children[i];
          compiler = new this.compiler();
          var existing = this.matchExistingProgram(child);
          if (existing == null) {
            this.context.programs.push("");
            var index = this.context.programs.length;
            child.index = index;
            child.name = "program" + index;
            this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
            this.context.decorators[index] = compiler.decorators;
            this.context.environments[index] = child;
            this.useDepths = this.useDepths || compiler.useDepths;
            this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
            child.useDepths = this.useDepths;
            child.useBlockParams = this.useBlockParams;
          } else {
            child.index = existing.index;
            child.name = "program" + existing.index;
            this.useDepths = this.useDepths || existing.useDepths;
            this.useBlockParams = this.useBlockParams || existing.useBlockParams;
          }
        }
      },
      matchExistingProgram: function matchExistingProgram(child) {
        for (var i = 0, len = this.context.environments.length; i < len; i++) {
          var environment = this.context.environments[i];
          if (environment && environment.equals(child)) {
            return environment;
          }
        }
      },
      programExpression: function programExpression(guid) {
        var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
        if (this.useBlockParams || this.useDepths) {
          programParams.push("blockParams");
        }
        if (this.useDepths) {
          programParams.push("depths");
        }
        return "container.program(" + programParams.join(", ") + ")";
      },
      useRegister: function useRegister(name) {
        if (!this.registers[name]) {
          this.registers[name] = true;
          this.registers.list.push(name);
        }
      },
      push: function push(expr) {
        if (!(expr instanceof Literal)) {
          expr = this.source.wrap(expr);
        }
        this.inlineStack.push(expr);
        return expr;
      },
      pushStackLiteral: function pushStackLiteral(item) {
        this.push(new Literal(item));
      },
      pushSource: function pushSource(source) {
        if (this.pendingContent) {
          this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
          this.pendingContent = void 0;
        }
        if (source) {
          this.source.push(source);
        }
      },
      replaceStack: function replaceStack(callback) {
        var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
        if (!this.isInline()) {
          throw new _exception2["default"]("replaceStack on non-inline");
        }
        var top = this.popStack(true);
        if (top instanceof Literal) {
          stack = [top.value];
          prefix = ["(", stack];
          usedLiteral = true;
        } else {
          createdStack = true;
          var _name = this.incrStack();
          prefix = ["((", this.push(_name), " = ", top, ")"];
          stack = this.topStack();
        }
        var item = callback.call(this, stack);
        if (!usedLiteral) {
          this.popStack();
        }
        if (createdStack) {
          this.stackSlot--;
        }
        this.push(prefix.concat(item, ")"));
      },
      incrStack: function incrStack() {
        this.stackSlot++;
        if (this.stackSlot > this.stackVars.length) {
          this.stackVars.push("stack" + this.stackSlot);
        }
        return this.topStackName();
      },
      topStackName: function topStackName() {
        return "stack" + this.stackSlot;
      },
      flushInline: function flushInline() {
        var inlineStack = this.inlineStack;
        this.inlineStack = [];
        for (var i = 0, len = inlineStack.length; i < len; i++) {
          var entry = inlineStack[i];
          if (entry instanceof Literal) {
            this.compileStack.push(entry);
          } else {
            var stack = this.incrStack();
            this.pushSource([stack, " = ", entry, ";"]);
            this.compileStack.push(stack);
          }
        }
      },
      isInline: function isInline2() {
        return this.inlineStack.length;
      },
      popStack: function popStack(wrapped) {
        var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
        if (!wrapped && item instanceof Literal) {
          return item.value;
        } else {
          if (!inline) {
            if (!this.stackSlot) {
              throw new _exception2["default"]("Invalid stack pop");
            }
            this.stackSlot--;
          }
          return item;
        }
      },
      topStack: function topStack() {
        var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
        if (item instanceof Literal) {
          return item.value;
        } else {
          return item;
        }
      },
      contextName: function contextName(context) {
        if (this.useDepths && context) {
          return "depths[" + context + "]";
        } else {
          return "depth" + context;
        }
      },
      quotedString: function quotedString(str) {
        return this.source.quotedString(str);
      },
      objectLiteral: function objectLiteral(obj) {
        return this.source.objectLiteral(obj);
      },
      aliasable: function aliasable(name) {
        var ret = this.aliases[name];
        if (ret) {
          ret.referenceCount++;
          return ret;
        }
        ret = this.aliases[name] = this.source.wrap(name);
        ret.aliasable = true;
        ret.referenceCount = 1;
        return ret;
      },
      setupHelper: function setupHelper(paramSize, name, blockHelper) {
        var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
        var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
        return {
          params,
          paramsInit,
          name: foundHelper,
          callParams: [callContext].concat(params)
        };
      },
      setupParams: function setupParams(helper, paramSize, params) {
        var options = {}, contexts = [], types = [], ids = [], objectArgs = !params, param = void 0;
        if (objectArgs) {
          params = [];
        }
        options.name = this.quotedString(helper);
        options.hash = this.popStack();
        if (this.trackIds) {
          options.hashIds = this.popStack();
        }
        if (this.stringParams) {
          options.hashTypes = this.popStack();
          options.hashContexts = this.popStack();
        }
        var inverse = this.popStack(), program = this.popStack();
        if (program || inverse) {
          options.fn = program || "container.noop";
          options.inverse = inverse || "container.noop";
        }
        var i = paramSize;
        while (i--) {
          param = this.popStack();
          params[i] = param;
          if (this.trackIds) {
            ids[i] = this.popStack();
          }
          if (this.stringParams) {
            types[i] = this.popStack();
            contexts[i] = this.popStack();
          }
        }
        if (objectArgs) {
          options.args = this.source.generateArray(params);
        }
        if (this.trackIds) {
          options.ids = this.source.generateArray(ids);
        }
        if (this.stringParams) {
          options.types = this.source.generateArray(types);
          options.contexts = this.source.generateArray(contexts);
        }
        if (this.options.data) {
          options.data = "data";
        }
        if (this.useBlockParams) {
          options.blockParams = "blockParams";
        }
        return options;
      },
      setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
        var options = this.setupParams(helper, paramSize, params);
        options.loc = JSON.stringify(this.source.currentLocation);
        options = this.objectLiteral(options);
        if (useRegister) {
          this.useRegister("options");
          params.push("options");
          return ["options=", options];
        } else if (params) {
          params.push(options);
          return "";
        } else {
          return options;
        }
      }
    };
    (function() {
      var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
      var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
      for (var i = 0, l = reservedWords.length; i < l; i++) {
        compilerWords[reservedWords[i]] = true;
      }
    })();
    JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
      return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
    };
    function strictLookup(requireTerminal, compiler, parts, i, type) {
      var stack = compiler.popStack(), len = parts.length;
      if (requireTerminal) {
        len--;
      }
      for (; i < len; i++) {
        stack = compiler.nameLookup(stack, parts[i], type);
      }
      if (requireTerminal) {
        return [compiler.aliasable("container.strict"), "(", stack, ", ", compiler.quotedString(parts[i]), ", ", JSON.stringify(compiler.source.currentLocation), " )"];
      } else {
        return stack;
      }
    }
    exports["default"] = JavaScriptCompiler;
    module.exports = exports["default"];
  }
});

// node_modules/handlebars/dist/cjs/handlebars.js
var require_handlebars = __commonJS({
  "node_modules/handlebars/dist/cjs/handlebars.js"(exports, module) {
    "use strict";
    exports.__esModule = true;
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var _handlebarsRuntime = require_handlebars_runtime();
    var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
    var _handlebarsCompilerAst = require_ast();
    var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
    var _handlebarsCompilerBase = require_base2();
    var _handlebarsCompilerCompiler = require_compiler();
    var _handlebarsCompilerJavascriptCompiler = require_javascript_compiler();
    var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
    var _handlebarsCompilerVisitor = require_visitor();
    var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
    var _handlebarsNoConflict = require_no_conflict();
    var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
    var _create = _handlebarsRuntime2["default"].create;
    function create() {
      var hb = _create();
      hb.compile = function(input, options) {
        return _handlebarsCompilerCompiler.compile(input, options, hb);
      };
      hb.precompile = function(input, options) {
        return _handlebarsCompilerCompiler.precompile(input, options, hb);
      };
      hb.AST = _handlebarsCompilerAst2["default"];
      hb.Compiler = _handlebarsCompilerCompiler.Compiler;
      hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
      hb.Parser = _handlebarsCompilerBase.parser;
      hb.parse = _handlebarsCompilerBase.parse;
      hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
      return hb;
    }
    var inst = create();
    inst.create = create;
    _handlebarsNoConflict2["default"](inst);
    inst.Visitor = _handlebarsCompilerVisitor2["default"];
    inst["default"] = inst;
    exports["default"] = inst;
    module.exports = exports["default"];
  }
});

// node_modules/htmlnorm/node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/htmlnorm/node_modules/entities/lib/decode_codepoint.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var decodeMap2 = /* @__PURE__ */ new Map([
      [0, 65533],
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    var fromCodePoint3 = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
      String.fromCodePoint || function(codePoint) {
        var output = "";
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += String.fromCharCode(codePoint);
        return output;
      }
    );
    function decodeCodePoint2(codePoint) {
      var _a3;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return "\uFFFD";
      }
      return fromCodePoint3((_a3 = decodeMap2.get(codePoint)) !== null && _a3 !== void 0 ? _a3 : codePoint);
    }
    exports.default = decodeCodePoint2;
  }
});

// node_modules/htmlnorm/node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "node_modules/htmlnorm/node_modules/entities/lib/generated/decode-data-html.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array([14866, 60, 237, 340, 721, 1312, 1562, 1654, 1838, 1957, 2183, 2239, 2301, 2958, 3037, 3893, 4123, 4298, 4330, 4801, 5191, 5395, 5752, 5903, 5943, 5972, 6050, 0, 0, 0, 0, 0, 0, 6135, 6565, 7422, 8183, 8738, 9242, 9503, 9938, 10189, 10573, 10637, 10715, 11950, 12246, 13539, 13950, 14445, 14533, 15364, 16514, 16980, 17390, 17763, 17849, 18036, 18125, 4096, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 92, 100, 106, 115, 122, 137, 142, 151, 157, 163, 167, 182, 196, 204, 220, 229, 108, 105, 103, 33024, 198, 59, 32768, 198, 80, 33024, 38, 59, 32768, 38, 99, 117, 116, 101, 33024, 193, 59, 32768, 193, 114, 101, 118, 101, 59, 32768, 258, 512, 105, 121, 127, 134, 114, 99, 33024, 194, 59, 32768, 194, 59, 32768, 1040, 114, 59, 32896, 55349, 56580, 114, 97, 118, 101, 33024, 192, 59, 32768, 192, 112, 104, 97, 59, 32768, 913, 97, 99, 114, 59, 32768, 256, 100, 59, 32768, 10835, 512, 103, 112, 172, 177, 111, 110, 59, 32768, 260, 102, 59, 32896, 55349, 56632, 112, 108, 121, 70, 117, 110, 99, 116, 105, 111, 110, 59, 32768, 8289, 105, 110, 103, 33024, 197, 59, 32768, 197, 512, 99, 115, 209, 214, 114, 59, 32896, 55349, 56476, 105, 103, 110, 59, 32768, 8788, 105, 108, 100, 101, 33024, 195, 59, 32768, 195, 109, 108, 33024, 196, 59, 32768, 196, 2048, 97, 99, 101, 102, 111, 114, 115, 117, 253, 278, 282, 310, 315, 321, 327, 332, 512, 99, 114, 258, 267, 107, 115, 108, 97, 115, 104, 59, 32768, 8726, 583, 271, 274, 59, 32768, 10983, 101, 100, 59, 32768, 8966, 121, 59, 32768, 1041, 768, 99, 114, 116, 289, 296, 306, 97, 117, 115, 101, 59, 32768, 8757, 110, 111, 117, 108, 108, 105, 115, 59, 32768, 8492, 97, 59, 32768, 914, 114, 59, 32896, 55349, 56581, 112, 102, 59, 32896, 55349, 56633, 101, 118, 101, 59, 32768, 728, 99, 114, 59, 32768, 8492, 109, 112, 101, 113, 59, 32768, 8782, 3584, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 368, 373, 380, 426, 461, 466, 487, 491, 495, 533, 593, 695, 701, 707, 99, 121, 59, 32768, 1063, 80, 89, 33024, 169, 59, 32768, 169, 768, 99, 112, 121, 387, 393, 419, 117, 116, 101, 59, 32768, 262, 512, 59, 105, 398, 400, 32768, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 32768, 8517, 108, 101, 121, 115, 59, 32768, 8493, 1024, 97, 101, 105, 111, 435, 441, 449, 454, 114, 111, 110, 59, 32768, 268, 100, 105, 108, 33024, 199, 59, 32768, 199, 114, 99, 59, 32768, 264, 110, 105, 110, 116, 59, 32768, 8752, 111, 116, 59, 32768, 266, 512, 100, 110, 471, 478, 105, 108, 108, 97, 59, 32768, 184, 116, 101, 114, 68, 111, 116, 59, 32768, 183, 114, 59, 32768, 8493, 105, 59, 32768, 935, 114, 99, 108, 101, 1024, 68, 77, 80, 84, 508, 513, 520, 526, 111, 116, 59, 32768, 8857, 105, 110, 117, 115, 59, 32768, 8854, 108, 117, 115, 59, 32768, 8853, 105, 109, 101, 115, 59, 32768, 8855, 111, 512, 99, 115, 539, 562, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8754, 101, 67, 117, 114, 108, 121, 512, 68, 81, 573, 586, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 32768, 8221, 117, 111, 116, 101, 59, 32768, 8217, 1024, 108, 110, 112, 117, 602, 614, 648, 664, 111, 110, 512, 59, 101, 609, 611, 32768, 8759, 59, 32768, 10868, 768, 103, 105, 116, 621, 629, 634, 114, 117, 101, 110, 116, 59, 32768, 8801, 110, 116, 59, 32768, 8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8750, 512, 102, 114, 653, 656, 59, 32768, 8450, 111, 100, 117, 99, 116, 59, 32768, 8720, 110, 116, 101, 114, 67, 108, 111, 99, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8755, 111, 115, 115, 59, 32768, 10799, 99, 114, 59, 32896, 55349, 56478, 112, 512, 59, 67, 713, 715, 32768, 8915, 97, 112, 59, 32768, 8781, 2816, 68, 74, 83, 90, 97, 99, 101, 102, 105, 111, 115, 743, 758, 763, 768, 773, 795, 809, 821, 826, 910, 1295, 512, 59, 111, 748, 750, 32768, 8517, 116, 114, 97, 104, 100, 59, 32768, 10513, 99, 121, 59, 32768, 1026, 99, 121, 59, 32768, 1029, 99, 121, 59, 32768, 1039, 768, 103, 114, 115, 780, 786, 790, 103, 101, 114, 59, 32768, 8225, 114, 59, 32768, 8609, 104, 118, 59, 32768, 10980, 512, 97, 121, 800, 806, 114, 111, 110, 59, 32768, 270, 59, 32768, 1044, 108, 512, 59, 116, 815, 817, 32768, 8711, 97, 59, 32768, 916, 114, 59, 32896, 55349, 56583, 512, 97, 102, 831, 897, 512, 99, 109, 836, 891, 114, 105, 116, 105, 99, 97, 108, 1024, 65, 68, 71, 84, 852, 859, 877, 884, 99, 117, 116, 101, 59, 32768, 180, 111, 581, 864, 867, 59, 32768, 729, 98, 108, 101, 65, 99, 117, 116, 101, 59, 32768, 733, 114, 97, 118, 101, 59, 32768, 96, 105, 108, 100, 101, 59, 32768, 732, 111, 110, 100, 59, 32768, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 32768, 8518, 2113, 920, 0, 0, 0, 925, 946, 0, 1139, 102, 59, 32896, 55349, 56635, 768, 59, 68, 69, 931, 933, 938, 32768, 168, 111, 116, 59, 32768, 8412, 113, 117, 97, 108, 59, 32768, 8784, 98, 108, 101, 1536, 67, 68, 76, 82, 85, 86, 961, 978, 996, 1080, 1101, 1125, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 32768, 8751, 111, 1093, 985, 0, 0, 988, 59, 32768, 168, 110, 65, 114, 114, 111, 119, 59, 32768, 8659, 512, 101, 111, 1001, 1034, 102, 116, 768, 65, 82, 84, 1010, 1017, 1029, 114, 114, 111, 119, 59, 32768, 8656, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8660, 101, 101, 59, 32768, 10980, 110, 103, 512, 76, 82, 1041, 1068, 101, 102, 116, 512, 65, 82, 1049, 1056, 114, 114, 111, 119, 59, 32768, 10232, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10233, 105, 103, 104, 116, 512, 65, 84, 1089, 1096, 114, 114, 111, 119, 59, 32768, 8658, 101, 101, 59, 32768, 8872, 112, 1042, 1108, 0, 0, 1115, 114, 114, 111, 119, 59, 32768, 8657, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 32768, 8741, 110, 1536, 65, 66, 76, 82, 84, 97, 1152, 1179, 1186, 1236, 1272, 1288, 114, 114, 111, 119, 768, 59, 66, 85, 1163, 1165, 1170, 32768, 8595, 97, 114, 59, 32768, 10515, 112, 65, 114, 114, 111, 119, 59, 32768, 8693, 114, 101, 118, 101, 59, 32768, 785, 101, 102, 116, 1315, 1196, 0, 1209, 0, 1220, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 32768, 10576, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10590, 101, 99, 116, 111, 114, 512, 59, 66, 1229, 1231, 32768, 8637, 97, 114, 59, 32768, 10582, 105, 103, 104, 116, 805, 1245, 0, 1256, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10591, 101, 99, 116, 111, 114, 512, 59, 66, 1265, 1267, 32768, 8641, 97, 114, 59, 32768, 10583, 101, 101, 512, 59, 65, 1279, 1281, 32768, 8868, 114, 114, 111, 119, 59, 32768, 8615, 114, 114, 111, 119, 59, 32768, 8659, 512, 99, 116, 1300, 1305, 114, 59, 32896, 55349, 56479, 114, 111, 107, 59, 32768, 272, 4096, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115, 116, 117, 120, 1344, 1348, 1354, 1363, 1386, 1391, 1396, 1405, 1413, 1460, 1475, 1483, 1514, 1527, 1531, 1538, 71, 59, 32768, 330, 72, 33024, 208, 59, 32768, 208, 99, 117, 116, 101, 33024, 201, 59, 32768, 201, 768, 97, 105, 121, 1370, 1376, 1383, 114, 111, 110, 59, 32768, 282, 114, 99, 33024, 202, 59, 32768, 202, 59, 32768, 1069, 111, 116, 59, 32768, 278, 114, 59, 32896, 55349, 56584, 114, 97, 118, 101, 33024, 200, 59, 32768, 200, 101, 109, 101, 110, 116, 59, 32768, 8712, 512, 97, 112, 1418, 1423, 99, 114, 59, 32768, 274, 116, 121, 1060, 1431, 0, 0, 1444, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9643, 512, 103, 112, 1465, 1470, 111, 110, 59, 32768, 280, 102, 59, 32896, 55349, 56636, 115, 105, 108, 111, 110, 59, 32768, 917, 117, 512, 97, 105, 1489, 1504, 108, 512, 59, 84, 1495, 1497, 32768, 10869, 105, 108, 100, 101, 59, 32768, 8770, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 8652, 512, 99, 105, 1519, 1523, 114, 59, 32768, 8496, 109, 59, 32768, 10867, 97, 59, 32768, 919, 109, 108, 33024, 203, 59, 32768, 203, 512, 105, 112, 1543, 1549, 115, 116, 115, 59, 32768, 8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 32768, 8519, 1280, 99, 102, 105, 111, 115, 1572, 1576, 1581, 1620, 1648, 121, 59, 32768, 1060, 114, 59, 32896, 55349, 56585, 108, 108, 101, 100, 1060, 1591, 0, 0, 1604, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9724, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 32768, 9642, 1601, 1628, 0, 1633, 0, 0, 1639, 102, 59, 32896, 55349, 56637, 65, 108, 108, 59, 32768, 8704, 114, 105, 101, 114, 116, 114, 102, 59, 32768, 8497, 99, 114, 59, 32768, 8497, 3072, 74, 84, 97, 98, 99, 100, 102, 103, 111, 114, 115, 116, 1678, 1683, 1688, 1701, 1708, 1729, 1734, 1739, 1742, 1748, 1828, 1834, 99, 121, 59, 32768, 1027, 33024, 62, 59, 32768, 62, 109, 109, 97, 512, 59, 100, 1696, 1698, 32768, 915, 59, 32768, 988, 114, 101, 118, 101, 59, 32768, 286, 768, 101, 105, 121, 1715, 1721, 1726, 100, 105, 108, 59, 32768, 290, 114, 99, 59, 32768, 284, 59, 32768, 1043, 111, 116, 59, 32768, 288, 114, 59, 32896, 55349, 56586, 59, 32768, 8921, 112, 102, 59, 32896, 55349, 56638, 101, 97, 116, 101, 114, 1536, 69, 70, 71, 76, 83, 84, 1766, 1783, 1794, 1803, 1809, 1821, 113, 117, 97, 108, 512, 59, 76, 1775, 1777, 32768, 8805, 101, 115, 115, 59, 32768, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8807, 114, 101, 97, 116, 101, 114, 59, 32768, 10914, 101, 115, 115, 59, 32768, 8823, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 10878, 105, 108, 100, 101, 59, 32768, 8819, 99, 114, 59, 32896, 55349, 56482, 59, 32768, 8811, 2048, 65, 97, 99, 102, 105, 111, 115, 117, 1854, 1861, 1874, 1880, 1884, 1897, 1919, 1934, 82, 68, 99, 121, 59, 32768, 1066, 512, 99, 116, 1866, 1871, 101, 107, 59, 32768, 711, 59, 32768, 94, 105, 114, 99, 59, 32768, 292, 114, 59, 32768, 8460, 108, 98, 101, 114, 116, 83, 112, 97, 99, 101, 59, 32768, 8459, 833, 1902, 0, 1906, 102, 59, 32768, 8461, 105, 122, 111, 110, 116, 97, 108, 76, 105, 110, 101, 59, 32768, 9472, 512, 99, 116, 1924, 1928, 114, 59, 32768, 8459, 114, 111, 107, 59, 32768, 294, 109, 112, 533, 1940, 1950, 111, 119, 110, 72, 117, 109, 112, 59, 32768, 8782, 113, 117, 97, 108, 59, 32768, 8783, 3584, 69, 74, 79, 97, 99, 100, 102, 103, 109, 110, 111, 115, 116, 117, 1985, 1990, 1996, 2001, 2010, 2025, 2030, 2034, 2043, 2077, 2134, 2155, 2160, 2167, 99, 121, 59, 32768, 1045, 108, 105, 103, 59, 32768, 306, 99, 121, 59, 32768, 1025, 99, 117, 116, 101, 33024, 205, 59, 32768, 205, 512, 105, 121, 2015, 2022, 114, 99, 33024, 206, 59, 32768, 206, 59, 32768, 1048, 111, 116, 59, 32768, 304, 114, 59, 32768, 8465, 114, 97, 118, 101, 33024, 204, 59, 32768, 204, 768, 59, 97, 112, 2050, 2052, 2070, 32768, 8465, 512, 99, 103, 2057, 2061, 114, 59, 32768, 298, 105, 110, 97, 114, 121, 73, 59, 32768, 8520, 108, 105, 101, 115, 59, 32768, 8658, 837, 2082, 0, 2110, 512, 59, 101, 2086, 2088, 32768, 8748, 512, 103, 114, 2093, 2099, 114, 97, 108, 59, 32768, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 32768, 8898, 105, 115, 105, 98, 108, 101, 512, 67, 84, 2120, 2127, 111, 109, 109, 97, 59, 32768, 8291, 105, 109, 101, 115, 59, 32768, 8290, 768, 103, 112, 116, 2141, 2146, 2151, 111, 110, 59, 32768, 302, 102, 59, 32896, 55349, 56640, 97, 59, 32768, 921, 99, 114, 59, 32768, 8464, 105, 108, 100, 101, 59, 32768, 296, 828, 2172, 0, 2177, 99, 121, 59, 32768, 1030, 108, 33024, 207, 59, 32768, 207, 1280, 99, 102, 111, 115, 117, 2193, 2206, 2211, 2217, 2232, 512, 105, 121, 2198, 2203, 114, 99, 59, 32768, 308, 59, 32768, 1049, 114, 59, 32896, 55349, 56589, 112, 102, 59, 32896, 55349, 56641, 820, 2222, 0, 2227, 114, 59, 32896, 55349, 56485, 114, 99, 121, 59, 32768, 1032, 107, 99, 121, 59, 32768, 1028, 1792, 72, 74, 97, 99, 102, 111, 115, 2253, 2258, 2263, 2269, 2283, 2288, 2294, 99, 121, 59, 32768, 1061, 99, 121, 59, 32768, 1036, 112, 112, 97, 59, 32768, 922, 512, 101, 121, 2274, 2280, 100, 105, 108, 59, 32768, 310, 59, 32768, 1050, 114, 59, 32896, 55349, 56590, 112, 102, 59, 32896, 55349, 56642, 99, 114, 59, 32896, 55349, 56486, 2816, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2323, 2328, 2333, 2374, 2396, 2775, 2780, 2797, 2804, 2934, 2954, 99, 121, 59, 32768, 1033, 33024, 60, 59, 32768, 60, 1280, 99, 109, 110, 112, 114, 2344, 2350, 2356, 2360, 2370, 117, 116, 101, 59, 32768, 313, 98, 100, 97, 59, 32768, 923, 103, 59, 32768, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 32768, 8466, 114, 59, 32768, 8606, 768, 97, 101, 121, 2381, 2387, 2393, 114, 111, 110, 59, 32768, 317, 100, 105, 108, 59, 32768, 315, 59, 32768, 1051, 512, 102, 115, 2401, 2702, 116, 2560, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114, 2423, 2470, 2479, 2530, 2537, 2561, 2618, 2666, 2683, 2690, 512, 110, 114, 2428, 2441, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10216, 114, 111, 119, 768, 59, 66, 82, 2451, 2453, 2458, 32768, 8592, 97, 114, 59, 32768, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8646, 101, 105, 108, 105, 110, 103, 59, 32768, 8968, 111, 838, 2485, 0, 2498, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10214, 110, 805, 2503, 0, 2514, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10593, 101, 99, 116, 111, 114, 512, 59, 66, 2523, 2525, 32768, 8643, 97, 114, 59, 32768, 10585, 108, 111, 111, 114, 59, 32768, 8970, 105, 103, 104, 116, 512, 65, 86, 2546, 2553, 114, 114, 111, 119, 59, 32768, 8596, 101, 99, 116, 111, 114, 59, 32768, 10574, 512, 101, 114, 2566, 2591, 101, 768, 59, 65, 86, 2574, 2576, 2583, 32768, 8867, 114, 114, 111, 119, 59, 32768, 8612, 101, 99, 116, 111, 114, 59, 32768, 10586, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 2604, 2606, 2611, 32768, 8882, 97, 114, 59, 32768, 10703, 113, 117, 97, 108, 59, 32768, 8884, 112, 768, 68, 84, 86, 2626, 2638, 2649, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 32768, 10577, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10592, 101, 99, 116, 111, 114, 512, 59, 66, 2659, 2661, 32768, 8639, 97, 114, 59, 32768, 10584, 101, 99, 116, 111, 114, 512, 59, 66, 2676, 2678, 32768, 8636, 97, 114, 59, 32768, 10578, 114, 114, 111, 119, 59, 32768, 8656, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8660, 115, 1536, 69, 70, 71, 76, 83, 84, 2716, 2730, 2741, 2750, 2756, 2768, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 32768, 8922, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8806, 114, 101, 97, 116, 101, 114, 59, 32768, 8822, 101, 115, 115, 59, 32768, 10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 10877, 105, 108, 100, 101, 59, 32768, 8818, 114, 59, 32896, 55349, 56591, 512, 59, 101, 2785, 2787, 32768, 8920, 102, 116, 97, 114, 114, 111, 119, 59, 32768, 8666, 105, 100, 111, 116, 59, 32768, 319, 768, 110, 112, 119, 2811, 2899, 2904, 103, 1024, 76, 82, 108, 114, 2821, 2848, 2860, 2887, 101, 102, 116, 512, 65, 82, 2829, 2836, 114, 114, 111, 119, 59, 32768, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10231, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 10230, 101, 102, 116, 512, 97, 114, 2868, 2875, 114, 114, 111, 119, 59, 32768, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10233, 102, 59, 32896, 55349, 56643, 101, 114, 512, 76, 82, 2911, 2922, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8601, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8600, 768, 99, 104, 116, 2941, 2945, 2948, 114, 59, 32768, 8466, 59, 32768, 8624, 114, 111, 107, 59, 32768, 321, 59, 32768, 8810, 2048, 97, 99, 101, 102, 105, 111, 115, 117, 2974, 2978, 2982, 3007, 3012, 3022, 3028, 3033, 112, 59, 32768, 10501, 121, 59, 32768, 1052, 512, 100, 108, 2987, 2998, 105, 117, 109, 83, 112, 97, 99, 101, 59, 32768, 8287, 108, 105, 110, 116, 114, 102, 59, 32768, 8499, 114, 59, 32896, 55349, 56592, 110, 117, 115, 80, 108, 117, 115, 59, 32768, 8723, 112, 102, 59, 32896, 55349, 56644, 99, 114, 59, 32768, 8499, 59, 32768, 924, 2304, 74, 97, 99, 101, 102, 111, 115, 116, 117, 3055, 3060, 3067, 3089, 3201, 3206, 3874, 3880, 3889, 99, 121, 59, 32768, 1034, 99, 117, 116, 101, 59, 32768, 323, 768, 97, 101, 121, 3074, 3080, 3086, 114, 111, 110, 59, 32768, 327, 100, 105, 108, 59, 32768, 325, 59, 32768, 1053, 768, 103, 115, 119, 3096, 3160, 3194, 97, 116, 105, 118, 101, 768, 77, 84, 86, 3108, 3121, 3145, 101, 100, 105, 117, 109, 83, 112, 97, 99, 101, 59, 32768, 8203, 104, 105, 512, 99, 110, 3128, 3137, 107, 83, 112, 97, 99, 101, 59, 32768, 8203, 83, 112, 97, 99, 101, 59, 32768, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 32768, 8203, 116, 101, 100, 512, 71, 76, 3168, 3184, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 32768, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 32768, 8810, 76, 105, 110, 101, 59, 32768, 10, 114, 59, 32896, 55349, 56593, 1024, 66, 110, 112, 116, 3215, 3222, 3238, 3242, 114, 101, 97, 107, 59, 32768, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97, 99, 101, 59, 32768, 160, 102, 59, 32768, 8469, 3328, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84, 86, 3269, 3271, 3293, 3312, 3352, 3430, 3455, 3551, 3589, 3625, 3678, 3821, 3861, 32768, 10988, 512, 111, 117, 3276, 3286, 110, 103, 114, 117, 101, 110, 116, 59, 32768, 8802, 112, 67, 97, 112, 59, 32768, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 32768, 8742, 768, 108, 113, 120, 3319, 3327, 3345, 101, 109, 101, 110, 116, 59, 32768, 8713, 117, 97, 108, 512, 59, 84, 3335, 3337, 32768, 8800, 105, 108, 100, 101, 59, 32896, 8770, 824, 105, 115, 116, 115, 59, 32768, 8708, 114, 101, 97, 116, 101, 114, 1792, 59, 69, 70, 71, 76, 83, 84, 3373, 3375, 3382, 3394, 3404, 3410, 3423, 32768, 8815, 113, 117, 97, 108, 59, 32768, 8817, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32896, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 32896, 8811, 824, 101, 115, 115, 59, 32768, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32896, 10878, 824, 105, 108, 100, 101, 59, 32768, 8821, 117, 109, 112, 533, 3437, 3448, 111, 119, 110, 72, 117, 109, 112, 59, 32896, 8782, 824, 113, 117, 97, 108, 59, 32896, 8783, 824, 101, 512, 102, 115, 3461, 3492, 116, 84, 114, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 3477, 3479, 3485, 32768, 8938, 97, 114, 59, 32896, 10703, 824, 113, 117, 97, 108, 59, 32768, 8940, 115, 1536, 59, 69, 71, 76, 83, 84, 3506, 3508, 3515, 3524, 3531, 3544, 32768, 8814, 113, 117, 97, 108, 59, 32768, 8816, 114, 101, 97, 116, 101, 114, 59, 32768, 8824, 101, 115, 115, 59, 32896, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32896, 10877, 824, 105, 108, 100, 101, 59, 32768, 8820, 101, 115, 116, 101, 100, 512, 71, 76, 3561, 3578, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 32896, 10914, 824, 101, 115, 115, 76, 101, 115, 115, 59, 32896, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 768, 59, 69, 83, 3603, 3605, 3613, 32768, 8832, 113, 117, 97, 108, 59, 32896, 10927, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8928, 512, 101, 105, 3630, 3645, 118, 101, 114, 115, 101, 69, 108, 101, 109, 101, 110, 116, 59, 32768, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 3663, 3665, 3671, 32768, 8939, 97, 114, 59, 32896, 10704, 824, 113, 117, 97, 108, 59, 32768, 8941, 512, 113, 117, 3683, 3732, 117, 97, 114, 101, 83, 117, 512, 98, 112, 3694, 3712, 115, 101, 116, 512, 59, 69, 3702, 3705, 32896, 8847, 824, 113, 117, 97, 108, 59, 32768, 8930, 101, 114, 115, 101, 116, 512, 59, 69, 3722, 3725, 32896, 8848, 824, 113, 117, 97, 108, 59, 32768, 8931, 768, 98, 99, 112, 3739, 3757, 3801, 115, 101, 116, 512, 59, 69, 3747, 3750, 32896, 8834, 8402, 113, 117, 97, 108, 59, 32768, 8840, 99, 101, 101, 100, 115, 1024, 59, 69, 83, 84, 3771, 3773, 3781, 3793, 32768, 8833, 113, 117, 97, 108, 59, 32896, 10928, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8929, 105, 108, 100, 101, 59, 32896, 8831, 824, 101, 114, 115, 101, 116, 512, 59, 69, 3811, 3814, 32896, 8835, 8402, 113, 117, 97, 108, 59, 32768, 8841, 105, 108, 100, 101, 1024, 59, 69, 70, 84, 3834, 3836, 3843, 3854, 32768, 8769, 113, 117, 97, 108, 59, 32768, 8772, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8775, 105, 108, 100, 101, 59, 32768, 8777, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 32768, 8740, 99, 114, 59, 32896, 55349, 56489, 105, 108, 100, 101, 33024, 209, 59, 32768, 209, 59, 32768, 925, 3584, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114, 115, 116, 117, 118, 3921, 3927, 3936, 3951, 3958, 3963, 3972, 3996, 4002, 4034, 4037, 4055, 4071, 4078, 108, 105, 103, 59, 32768, 338, 99, 117, 116, 101, 33024, 211, 59, 32768, 211, 512, 105, 121, 3941, 3948, 114, 99, 33024, 212, 59, 32768, 212, 59, 32768, 1054, 98, 108, 97, 99, 59, 32768, 336, 114, 59, 32896, 55349, 56594, 114, 97, 118, 101, 33024, 210, 59, 32768, 210, 768, 97, 101, 105, 3979, 3984, 3989, 99, 114, 59, 32768, 332, 103, 97, 59, 32768, 937, 99, 114, 111, 110, 59, 32768, 927, 112, 102, 59, 32896, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 512, 68, 81, 4014, 4027, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 32768, 8220, 117, 111, 116, 101, 59, 32768, 8216, 59, 32768, 10836, 512, 99, 108, 4042, 4047, 114, 59, 32896, 55349, 56490, 97, 115, 104, 33024, 216, 59, 32768, 216, 105, 573, 4060, 4067, 100, 101, 33024, 213, 59, 32768, 213, 101, 115, 59, 32768, 10807, 109, 108, 33024, 214, 59, 32768, 214, 101, 114, 512, 66, 80, 4085, 4109, 512, 97, 114, 4090, 4094, 114, 59, 32768, 8254, 97, 99, 512, 101, 107, 4101, 4104, 59, 32768, 9182, 101, 116, 59, 32768, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 32768, 9180, 2304, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4141, 4150, 4154, 4159, 4163, 4166, 4176, 4198, 4284, 114, 116, 105, 97, 108, 68, 59, 32768, 8706, 121, 59, 32768, 1055, 114, 59, 32896, 55349, 56595, 105, 59, 32768, 934, 59, 32768, 928, 117, 115, 77, 105, 110, 117, 115, 59, 32768, 177, 512, 105, 112, 4181, 4194, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 32768, 8460, 102, 59, 32768, 8473, 1024, 59, 101, 105, 111, 4207, 4209, 4251, 4256, 32768, 10939, 99, 101, 100, 101, 115, 1024, 59, 69, 83, 84, 4223, 4225, 4232, 4244, 32768, 8826, 113, 117, 97, 108, 59, 32768, 10927, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8828, 105, 108, 100, 101, 59, 32768, 8830, 109, 101, 59, 32768, 8243, 512, 100, 112, 4261, 4267, 117, 99, 116, 59, 32768, 8719, 111, 114, 116, 105, 111, 110, 512, 59, 97, 4278, 4280, 32768, 8759, 108, 59, 32768, 8733, 512, 99, 105, 4289, 4294, 114, 59, 32896, 55349, 56491, 59, 32768, 936, 1024, 85, 102, 111, 115, 4306, 4313, 4318, 4323, 79, 84, 33024, 34, 59, 32768, 34, 114, 59, 32896, 55349, 56596, 112, 102, 59, 32768, 8474, 99, 114, 59, 32896, 55349, 56492, 3072, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4354, 4360, 4366, 4395, 4417, 4473, 4477, 4481, 4743, 4764, 4776, 4788, 97, 114, 114, 59, 32768, 10512, 71, 33024, 174, 59, 32768, 174, 768, 99, 110, 114, 4373, 4379, 4383, 117, 116, 101, 59, 32768, 340, 103, 59, 32768, 10219, 114, 512, 59, 116, 4389, 4391, 32768, 8608, 108, 59, 32768, 10518, 768, 97, 101, 121, 4402, 4408, 4414, 114, 111, 110, 59, 32768, 344, 100, 105, 108, 59, 32768, 342, 59, 32768, 1056, 512, 59, 118, 4422, 4424, 32768, 8476, 101, 114, 115, 101, 512, 69, 85, 4433, 4458, 512, 108, 113, 4438, 4446, 101, 109, 101, 110, 116, 59, 32768, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 8651, 112, 69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 10607, 114, 59, 32768, 8476, 111, 59, 32768, 929, 103, 104, 116, 2048, 65, 67, 68, 70, 84, 85, 86, 97, 4501, 4547, 4556, 4607, 4614, 4671, 4719, 4736, 512, 110, 114, 4506, 4519, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10217, 114, 111, 119, 768, 59, 66, 76, 4529, 4531, 4536, 32768, 8594, 97, 114, 59, 32768, 8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8644, 101, 105, 108, 105, 110, 103, 59, 32768, 8969, 111, 838, 4562, 0, 4575, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 32768, 10215, 110, 805, 4580, 0, 4591, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10589, 101, 99, 116, 111, 114, 512, 59, 66, 4600, 4602, 32768, 8642, 97, 114, 59, 32768, 10581, 108, 111, 111, 114, 59, 32768, 8971, 512, 101, 114, 4619, 4644, 101, 768, 59, 65, 86, 4627, 4629, 4636, 32768, 8866, 114, 114, 111, 119, 59, 32768, 8614, 101, 99, 116, 111, 114, 59, 32768, 10587, 105, 97, 110, 103, 108, 101, 768, 59, 66, 69, 4657, 4659, 4664, 32768, 8883, 97, 114, 59, 32768, 10704, 113, 117, 97, 108, 59, 32768, 8885, 112, 768, 68, 84, 86, 4679, 4691, 4702, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 32768, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 32768, 10588, 101, 99, 116, 111, 114, 512, 59, 66, 4712, 4714, 32768, 8638, 97, 114, 59, 32768, 10580, 101, 99, 116, 111, 114, 512, 59, 66, 4729, 4731, 32768, 8640, 97, 114, 59, 32768, 10579, 114, 114, 111, 119, 59, 32768, 8658, 512, 112, 117, 4748, 4752, 102, 59, 32768, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 32768, 10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8667, 512, 99, 104, 4781, 4785, 114, 59, 32768, 8475, 59, 32768, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 32768, 10740, 3328, 72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 4827, 4842, 4849, 4856, 4889, 4894, 4949, 4955, 4967, 4973, 5059, 5065, 5070, 512, 67, 99, 4832, 4838, 72, 99, 121, 59, 32768, 1065, 121, 59, 32768, 1064, 70, 84, 99, 121, 59, 32768, 1068, 99, 117, 116, 101, 59, 32768, 346, 1280, 59, 97, 101, 105, 121, 4867, 4869, 4875, 4881, 4886, 32768, 10940, 114, 111, 110, 59, 32768, 352, 100, 105, 108, 59, 32768, 350, 114, 99, 59, 32768, 348, 59, 32768, 1057, 114, 59, 32896, 55349, 56598, 111, 114, 116, 1024, 68, 76, 82, 85, 4906, 4917, 4928, 4940, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8592, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8594, 112, 65, 114, 114, 111, 119, 59, 32768, 8593, 103, 109, 97, 59, 32768, 931, 97, 108, 108, 67, 105, 114, 99, 108, 101, 59, 32768, 8728, 112, 102, 59, 32896, 55349, 56650, 1091, 4979, 0, 0, 4983, 116, 59, 32768, 8730, 97, 114, 101, 1024, 59, 73, 83, 85, 4994, 4996, 5010, 5052, 32768, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 32768, 8851, 117, 512, 98, 112, 5016, 5033, 115, 101, 116, 512, 59, 69, 5024, 5026, 32768, 8847, 113, 117, 97, 108, 59, 32768, 8849, 101, 114, 115, 101, 116, 512, 59, 69, 5043, 5045, 32768, 8848, 113, 117, 97, 108, 59, 32768, 8850, 110, 105, 111, 110, 59, 32768, 8852, 99, 114, 59, 32896, 55349, 56494, 97, 114, 59, 32768, 8902, 1024, 98, 99, 109, 112, 5079, 5102, 5155, 5158, 512, 59, 115, 5084, 5086, 32768, 8912, 101, 116, 512, 59, 69, 5093, 5095, 32768, 8912, 113, 117, 97, 108, 59, 32768, 8838, 512, 99, 104, 5107, 5148, 101, 101, 100, 115, 1024, 59, 69, 83, 84, 5120, 5122, 5129, 5141, 32768, 8827, 113, 117, 97, 108, 59, 32768, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 32768, 8829, 105, 108, 100, 101, 59, 32768, 8831, 84, 104, 97, 116, 59, 32768, 8715, 59, 32768, 8721, 768, 59, 101, 115, 5165, 5167, 5185, 32768, 8913, 114, 115, 101, 116, 512, 59, 69, 5176, 5178, 32768, 8835, 113, 117, 97, 108, 59, 32768, 8839, 101, 116, 59, 32768, 8913, 2816, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5213, 5221, 5227, 5241, 5252, 5274, 5279, 5323, 5362, 5368, 5378, 79, 82, 78, 33024, 222, 59, 32768, 222, 65, 68, 69, 59, 32768, 8482, 512, 72, 99, 5232, 5237, 99, 121, 59, 32768, 1035, 121, 59, 32768, 1062, 512, 98, 117, 5246, 5249, 59, 32768, 9, 59, 32768, 932, 768, 97, 101, 121, 5259, 5265, 5271, 114, 111, 110, 59, 32768, 356, 100, 105, 108, 59, 32768, 354, 59, 32768, 1058, 114, 59, 32896, 55349, 56599, 512, 101, 105, 5284, 5300, 835, 5289, 0, 5297, 101, 102, 111, 114, 101, 59, 32768, 8756, 97, 59, 32768, 920, 512, 99, 110, 5305, 5315, 107, 83, 112, 97, 99, 101, 59, 32896, 8287, 8202, 83, 112, 97, 99, 101, 59, 32768, 8201, 108, 100, 101, 1024, 59, 69, 70, 84, 5335, 5337, 5344, 5355, 32768, 8764, 113, 117, 97, 108, 59, 32768, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 32768, 8773, 105, 108, 100, 101, 59, 32768, 8776, 112, 102, 59, 32896, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 32768, 8411, 512, 99, 116, 5383, 5388, 114, 59, 32896, 55349, 56495, 114, 111, 107, 59, 32768, 358, 5426, 5417, 5444, 5458, 5473, 0, 5480, 5485, 0, 0, 0, 0, 0, 5494, 5500, 5564, 5579, 0, 5726, 5732, 5738, 5745, 512, 99, 114, 5421, 5429, 117, 116, 101, 33024, 218, 59, 32768, 218, 114, 512, 59, 111, 5435, 5437, 32768, 8607, 99, 105, 114, 59, 32768, 10569, 114, 820, 5449, 0, 5453, 121, 59, 32768, 1038, 118, 101, 59, 32768, 364, 512, 105, 121, 5462, 5469, 114, 99, 33024, 219, 59, 32768, 219, 59, 32768, 1059, 98, 108, 97, 99, 59, 32768, 368, 114, 59, 32896, 55349, 56600, 114, 97, 118, 101, 33024, 217, 59, 32768, 217, 97, 99, 114, 59, 32768, 362, 512, 100, 105, 5504, 5548, 101, 114, 512, 66, 80, 5511, 5535, 512, 97, 114, 5516, 5520, 114, 59, 32768, 95, 97, 99, 512, 101, 107, 5527, 5530, 59, 32768, 9183, 101, 116, 59, 32768, 9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 32768, 9181, 111, 110, 512, 59, 80, 5555, 5557, 32768, 8899, 108, 117, 115, 59, 32768, 8846, 512, 103, 112, 5568, 5573, 111, 110, 59, 32768, 370, 102, 59, 32896, 55349, 56652, 2048, 65, 68, 69, 84, 97, 100, 112, 115, 5595, 5624, 5635, 5648, 5664, 5671, 5682, 5712, 114, 114, 111, 119, 768, 59, 66, 68, 5606, 5608, 5613, 32768, 8593, 97, 114, 59, 32768, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8645, 111, 119, 110, 65, 114, 114, 111, 119, 59, 32768, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 32768, 10606, 101, 101, 512, 59, 65, 5655, 5657, 32768, 8869, 114, 114, 111, 119, 59, 32768, 8613, 114, 114, 111, 119, 59, 32768, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 32768, 8661, 101, 114, 512, 76, 82, 5689, 5700, 101, 102, 116, 65, 114, 114, 111, 119, 59, 32768, 8598, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 32768, 8599, 105, 512, 59, 108, 5718, 5720, 32768, 978, 111, 110, 59, 32768, 933, 105, 110, 103, 59, 32768, 366, 99, 114, 59, 32896, 55349, 56496, 105, 108, 100, 101, 59, 32768, 360, 109, 108, 33024, 220, 59, 32768, 220, 2304, 68, 98, 99, 100, 101, 102, 111, 115, 118, 5770, 5776, 5781, 5785, 5798, 5878, 5883, 5889, 5895, 97, 115, 104, 59, 32768, 8875, 97, 114, 59, 32768, 10987, 121, 59, 32768, 1042, 97, 115, 104, 512, 59, 108, 5793, 5795, 32768, 8873, 59, 32768, 10982, 512, 101, 114, 5803, 5806, 59, 32768, 8897, 768, 98, 116, 121, 5813, 5818, 5866, 97, 114, 59, 32768, 8214, 512, 59, 105, 5823, 5825, 32768, 8214, 99, 97, 108, 1024, 66, 76, 83, 84, 5837, 5842, 5848, 5859, 97, 114, 59, 32768, 8739, 105, 110, 101, 59, 32768, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 32768, 10072, 105, 108, 100, 101, 59, 32768, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 32768, 8202, 114, 59, 32896, 55349, 56601, 112, 102, 59, 32896, 55349, 56653, 99, 114, 59, 32896, 55349, 56497, 100, 97, 115, 104, 59, 32768, 8874, 1280, 99, 101, 102, 111, 115, 5913, 5919, 5925, 5930, 5936, 105, 114, 99, 59, 32768, 372, 100, 103, 101, 59, 32768, 8896, 114, 59, 32896, 55349, 56602, 112, 102, 59, 32896, 55349, 56654, 99, 114, 59, 32896, 55349, 56498, 1024, 102, 105, 111, 115, 5951, 5956, 5959, 5965, 114, 59, 32896, 55349, 56603, 59, 32768, 926, 112, 102, 59, 32896, 55349, 56655, 99, 114, 59, 32896, 55349, 56499, 2304, 65, 73, 85, 97, 99, 102, 111, 115, 117, 5990, 5995, 6e3, 6005, 6014, 6027, 6032, 6038, 6044, 99, 121, 59, 32768, 1071, 99, 121, 59, 32768, 1031, 99, 121, 59, 32768, 1070, 99, 117, 116, 101, 33024, 221, 59, 32768, 221, 512, 105, 121, 6019, 6024, 114, 99, 59, 32768, 374, 59, 32768, 1067, 114, 59, 32896, 55349, 56604, 112, 102, 59, 32896, 55349, 56656, 99, 114, 59, 32896, 55349, 56500, 109, 108, 59, 32768, 376, 2048, 72, 97, 99, 100, 101, 102, 111, 115, 6066, 6071, 6078, 6092, 6097, 6119, 6123, 6128, 99, 121, 59, 32768, 1046, 99, 117, 116, 101, 59, 32768, 377, 512, 97, 121, 6083, 6089, 114, 111, 110, 59, 32768, 381, 59, 32768, 1047, 111, 116, 59, 32768, 379, 835, 6102, 0, 6116, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 32768, 8203, 97, 59, 32768, 918, 114, 59, 32768, 8488, 112, 102, 59, 32768, 8484, 99, 114, 59, 32896, 55349, 56501, 5938, 6159, 6168, 6175, 0, 6214, 6222, 6233, 0, 0, 0, 0, 6242, 6267, 6290, 6429, 6444, 0, 6495, 6503, 6531, 6540, 0, 6547, 99, 117, 116, 101, 33024, 225, 59, 32768, 225, 114, 101, 118, 101, 59, 32768, 259, 1536, 59, 69, 100, 105, 117, 121, 6187, 6189, 6193, 6196, 6203, 6210, 32768, 8766, 59, 32896, 8766, 819, 59, 32768, 8767, 114, 99, 33024, 226, 59, 32768, 226, 116, 101, 33024, 180, 59, 32768, 180, 59, 32768, 1072, 108, 105, 103, 33024, 230, 59, 32768, 230, 512, 59, 114, 6226, 6228, 32768, 8289, 59, 32896, 55349, 56606, 114, 97, 118, 101, 33024, 224, 59, 32768, 224, 512, 101, 112, 6246, 6261, 512, 102, 112, 6251, 6257, 115, 121, 109, 59, 32768, 8501, 104, 59, 32768, 8501, 104, 97, 59, 32768, 945, 512, 97, 112, 6271, 6284, 512, 99, 108, 6276, 6280, 114, 59, 32768, 257, 103, 59, 32768, 10815, 33024, 38, 59, 32768, 38, 1077, 6295, 0, 0, 6326, 1280, 59, 97, 100, 115, 118, 6305, 6307, 6312, 6315, 6322, 32768, 8743, 110, 100, 59, 32768, 10837, 59, 32768, 10844, 108, 111, 112, 101, 59, 32768, 10840, 59, 32768, 10842, 1792, 59, 101, 108, 109, 114, 115, 122, 6340, 6342, 6345, 6349, 6391, 6410, 6422, 32768, 8736, 59, 32768, 10660, 101, 59, 32768, 8736, 115, 100, 512, 59, 97, 6356, 6358, 32768, 8737, 2098, 6368, 6371, 6374, 6377, 6380, 6383, 6386, 6389, 59, 32768, 10664, 59, 32768, 10665, 59, 32768, 10666, 59, 32768, 10667, 59, 32768, 10668, 59, 32768, 10669, 59, 32768, 10670, 59, 32768, 10671, 116, 512, 59, 118, 6397, 6399, 32768, 8735, 98, 512, 59, 100, 6405, 6407, 32768, 8894, 59, 32768, 10653, 512, 112, 116, 6415, 6419, 104, 59, 32768, 8738, 59, 32768, 197, 97, 114, 114, 59, 32768, 9084, 512, 103, 112, 6433, 6438, 111, 110, 59, 32768, 261, 102, 59, 32896, 55349, 56658, 1792, 59, 69, 97, 101, 105, 111, 112, 6458, 6460, 6463, 6469, 6472, 6476, 6480, 32768, 8776, 59, 32768, 10864, 99, 105, 114, 59, 32768, 10863, 59, 32768, 8778, 100, 59, 32768, 8779, 115, 59, 32768, 39, 114, 111, 120, 512, 59, 101, 6488, 6490, 32768, 8776, 113, 59, 32768, 8778, 105, 110, 103, 33024, 229, 59, 32768, 229, 768, 99, 116, 121, 6509, 6514, 6517, 114, 59, 32896, 55349, 56502, 59, 32768, 42, 109, 112, 512, 59, 101, 6524, 6526, 32768, 8776, 113, 59, 32768, 8781, 105, 108, 100, 101, 33024, 227, 59, 32768, 227, 109, 108, 33024, 228, 59, 32768, 228, 512, 99, 105, 6551, 6559, 111, 110, 105, 110, 116, 59, 32768, 8755, 110, 116, 59, 32768, 10769, 4096, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112, 114, 115, 117, 6597, 6602, 6673, 6688, 6701, 6707, 6768, 6773, 6891, 6898, 6999, 7023, 7309, 7316, 7334, 7383, 111, 116, 59, 32768, 10989, 512, 99, 114, 6607, 6652, 107, 1024, 99, 101, 112, 115, 6617, 6623, 6632, 6639, 111, 110, 103, 59, 32768, 8780, 112, 115, 105, 108, 111, 110, 59, 32768, 1014, 114, 105, 109, 101, 59, 32768, 8245, 105, 109, 512, 59, 101, 6646, 6648, 32768, 8765, 113, 59, 32768, 8909, 583, 6656, 6661, 101, 101, 59, 32768, 8893, 101, 100, 512, 59, 103, 6667, 6669, 32768, 8965, 101, 59, 32768, 8965, 114, 107, 512, 59, 116, 6680, 6682, 32768, 9141, 98, 114, 107, 59, 32768, 9142, 512, 111, 121, 6693, 6698, 110, 103, 59, 32768, 8780, 59, 32768, 1073, 113, 117, 111, 59, 32768, 8222, 1280, 99, 109, 112, 114, 116, 6718, 6731, 6738, 6743, 6749, 97, 117, 115, 512, 59, 101, 6726, 6728, 32768, 8757, 59, 32768, 8757, 112, 116, 121, 118, 59, 32768, 10672, 115, 105, 59, 32768, 1014, 110, 111, 117, 59, 32768, 8492, 768, 97, 104, 119, 6756, 6759, 6762, 59, 32768, 946, 59, 32768, 8502, 101, 101, 110, 59, 32768, 8812, 114, 59, 32896, 55349, 56607, 103, 1792, 99, 111, 115, 116, 117, 118, 119, 6789, 6809, 6834, 6850, 6872, 6879, 6884, 768, 97, 105, 117, 6796, 6800, 6805, 112, 59, 32768, 8898, 114, 99, 59, 32768, 9711, 112, 59, 32768, 8899, 768, 100, 112, 116, 6816, 6821, 6827, 111, 116, 59, 32768, 10752, 108, 117, 115, 59, 32768, 10753, 105, 109, 101, 115, 59, 32768, 10754, 1090, 6840, 0, 0, 6846, 99, 117, 112, 59, 32768, 10758, 97, 114, 59, 32768, 9733, 114, 105, 97, 110, 103, 108, 101, 512, 100, 117, 6862, 6868, 111, 119, 110, 59, 32768, 9661, 112, 59, 32768, 9651, 112, 108, 117, 115, 59, 32768, 10756, 101, 101, 59, 32768, 8897, 101, 100, 103, 101, 59, 32768, 8896, 97, 114, 111, 119, 59, 32768, 10509, 768, 97, 107, 111, 6905, 6976, 6994, 512, 99, 110, 6910, 6972, 107, 768, 108, 115, 116, 6918, 6927, 6935, 111, 122, 101, 110, 103, 101, 59, 32768, 10731, 113, 117, 97, 114, 101, 59, 32768, 9642, 114, 105, 97, 110, 103, 108, 101, 1024, 59, 100, 108, 114, 6951, 6953, 6959, 6965, 32768, 9652, 111, 119, 110, 59, 32768, 9662, 101, 102, 116, 59, 32768, 9666, 105, 103, 104, 116, 59, 32768, 9656, 107, 59, 32768, 9251, 770, 6981, 0, 6991, 771, 6985, 0, 6988, 59, 32768, 9618, 59, 32768, 9617, 52, 59, 32768, 9619, 99, 107, 59, 32768, 9608, 512, 101, 111, 7004, 7019, 512, 59, 113, 7009, 7012, 32896, 61, 8421, 117, 105, 118, 59, 32896, 8801, 8421, 116, 59, 32768, 8976, 1024, 112, 116, 119, 120, 7032, 7037, 7049, 7055, 102, 59, 32896, 55349, 56659, 512, 59, 116, 7042, 7044, 32768, 8869, 111, 109, 59, 32768, 8869, 116, 105, 101, 59, 32768, 8904, 3072, 68, 72, 85, 86, 98, 100, 104, 109, 112, 116, 117, 118, 7080, 7101, 7126, 7147, 7182, 7187, 7208, 7233, 7240, 7246, 7253, 7274, 1024, 76, 82, 108, 114, 7089, 7092, 7095, 7098, 59, 32768, 9559, 59, 32768, 9556, 59, 32768, 9558, 59, 32768, 9555, 1280, 59, 68, 85, 100, 117, 7112, 7114, 7117, 7120, 7123, 32768, 9552, 59, 32768, 9574, 59, 32768, 9577, 59, 32768, 9572, 59, 32768, 9575, 1024, 76, 82, 108, 114, 7135, 7138, 7141, 7144, 59, 32768, 9565, 59, 32768, 9562, 59, 32768, 9564, 59, 32768, 9561, 1792, 59, 72, 76, 82, 104, 108, 114, 7162, 7164, 7167, 7170, 7173, 7176, 7179, 32768, 9553, 59, 32768, 9580, 59, 32768, 9571, 59, 32768, 9568, 59, 32768, 9579, 59, 32768, 9570, 59, 32768, 9567, 111, 120, 59, 32768, 10697, 1024, 76, 82, 108, 114, 7196, 7199, 7202, 7205, 59, 32768, 9557, 59, 32768, 9554, 59, 32768, 9488, 59, 32768, 9484, 1280, 59, 68, 85, 100, 117, 7219, 7221, 7224, 7227, 7230, 32768, 9472, 59, 32768, 9573, 59, 32768, 9576, 59, 32768, 9516, 59, 32768, 9524, 105, 110, 117, 115, 59, 32768, 8863, 108, 117, 115, 59, 32768, 8862, 105, 109, 101, 115, 59, 32768, 8864, 1024, 76, 82, 108, 114, 7262, 7265, 7268, 7271, 59, 32768, 9563, 59, 32768, 9560, 59, 32768, 9496, 59, 32768, 9492, 1792, 59, 72, 76, 82, 104, 108, 114, 7289, 7291, 7294, 7297, 7300, 7303, 7306, 32768, 9474, 59, 32768, 9578, 59, 32768, 9569, 59, 32768, 9566, 59, 32768, 9532, 59, 32768, 9508, 59, 32768, 9500, 114, 105, 109, 101, 59, 32768, 8245, 512, 101, 118, 7321, 7326, 118, 101, 59, 32768, 728, 98, 97, 114, 33024, 166, 59, 32768, 166, 1024, 99, 101, 105, 111, 7343, 7348, 7353, 7364, 114, 59, 32896, 55349, 56503, 109, 105, 59, 32768, 8271, 109, 512, 59, 101, 7359, 7361, 32768, 8765, 59, 32768, 8909, 108, 768, 59, 98, 104, 7372, 7374, 7377, 32768, 92, 59, 32768, 10693, 115, 117, 98, 59, 32768, 10184, 573, 7387, 7399, 108, 512, 59, 101, 7392, 7394, 32768, 8226, 116, 59, 32768, 8226, 112, 768, 59, 69, 101, 7406, 7408, 7411, 32768, 8782, 59, 32768, 10926, 512, 59, 113, 7416, 7418, 32768, 8783, 59, 32768, 8783, 6450, 7448, 0, 7523, 7571, 7576, 7613, 0, 7618, 7647, 0, 0, 7764, 0, 0, 7779, 0, 0, 7899, 7914, 7949, 7955, 0, 8158, 0, 8176, 768, 99, 112, 114, 7454, 7460, 7509, 117, 116, 101, 59, 32768, 263, 1536, 59, 97, 98, 99, 100, 115, 7473, 7475, 7480, 7487, 7500, 7505, 32768, 8745, 110, 100, 59, 32768, 10820, 114, 99, 117, 112, 59, 32768, 10825, 512, 97, 117, 7492, 7496, 112, 59, 32768, 10827, 112, 59, 32768, 10823, 111, 116, 59, 32768, 10816, 59, 32896, 8745, 65024, 512, 101, 111, 7514, 7518, 116, 59, 32768, 8257, 110, 59, 32768, 711, 1024, 97, 101, 105, 117, 7531, 7544, 7552, 7557, 833, 7536, 0, 7540, 115, 59, 32768, 10829, 111, 110, 59, 32768, 269, 100, 105, 108, 33024, 231, 59, 32768, 231, 114, 99, 59, 32768, 265, 112, 115, 512, 59, 115, 7564, 7566, 32768, 10828, 109, 59, 32768, 10832, 111, 116, 59, 32768, 267, 768, 100, 109, 110, 7582, 7589, 7596, 105, 108, 33024, 184, 59, 32768, 184, 112, 116, 121, 118, 59, 32768, 10674, 116, 33280, 162, 59, 101, 7603, 7605, 32768, 162, 114, 100, 111, 116, 59, 32768, 183, 114, 59, 32896, 55349, 56608, 768, 99, 101, 105, 7624, 7628, 7643, 121, 59, 32768, 1095, 99, 107, 512, 59, 109, 7635, 7637, 32768, 10003, 97, 114, 107, 59, 32768, 10003, 59, 32768, 967, 114, 1792, 59, 69, 99, 101, 102, 109, 115, 7662, 7664, 7667, 7742, 7745, 7752, 7757, 32768, 9675, 59, 32768, 10691, 768, 59, 101, 108, 7674, 7676, 7680, 32768, 710, 113, 59, 32768, 8791, 101, 1074, 7687, 0, 0, 7709, 114, 114, 111, 119, 512, 108, 114, 7695, 7701, 101, 102, 116, 59, 32768, 8634, 105, 103, 104, 116, 59, 32768, 8635, 1280, 82, 83, 97, 99, 100, 7719, 7722, 7725, 7730, 7736, 59, 32768, 174, 59, 32768, 9416, 115, 116, 59, 32768, 8859, 105, 114, 99, 59, 32768, 8858, 97, 115, 104, 59, 32768, 8861, 59, 32768, 8791, 110, 105, 110, 116, 59, 32768, 10768, 105, 100, 59, 32768, 10991, 99, 105, 114, 59, 32768, 10690, 117, 98, 115, 512, 59, 117, 7771, 7773, 32768, 9827, 105, 116, 59, 32768, 9827, 1341, 7785, 7804, 7850, 0, 7871, 111, 110, 512, 59, 101, 7791, 7793, 32768, 58, 512, 59, 113, 7798, 7800, 32768, 8788, 59, 32768, 8788, 1086, 7809, 0, 0, 7820, 97, 512, 59, 116, 7814, 7816, 32768, 44, 59, 32768, 64, 768, 59, 102, 108, 7826, 7828, 7832, 32768, 8705, 110, 59, 32768, 8728, 101, 512, 109, 120, 7838, 7844, 101, 110, 116, 59, 32768, 8705, 101, 115, 59, 32768, 8450, 824, 7854, 0, 7866, 512, 59, 100, 7858, 7860, 32768, 8773, 111, 116, 59, 32768, 10861, 110, 116, 59, 32768, 8750, 768, 102, 114, 121, 7877, 7881, 7886, 59, 32896, 55349, 56660, 111, 100, 59, 32768, 8720, 33280, 169, 59, 115, 7892, 7894, 32768, 169, 114, 59, 32768, 8471, 512, 97, 111, 7903, 7908, 114, 114, 59, 32768, 8629, 115, 115, 59, 32768, 10007, 512, 99, 117, 7918, 7923, 114, 59, 32896, 55349, 56504, 512, 98, 112, 7928, 7938, 512, 59, 101, 7933, 7935, 32768, 10959, 59, 32768, 10961, 512, 59, 101, 7943, 7945, 32768, 10960, 59, 32768, 10962, 100, 111, 116, 59, 32768, 8943, 1792, 100, 101, 108, 112, 114, 118, 119, 7969, 7983, 7996, 8009, 8057, 8147, 8152, 97, 114, 114, 512, 108, 114, 7977, 7980, 59, 32768, 10552, 59, 32768, 10549, 1089, 7989, 0, 0, 7993, 114, 59, 32768, 8926, 99, 59, 32768, 8927, 97, 114, 114, 512, 59, 112, 8004, 8006, 32768, 8630, 59, 32768, 10557, 1536, 59, 98, 99, 100, 111, 115, 8022, 8024, 8031, 8044, 8049, 8053, 32768, 8746, 114, 99, 97, 112, 59, 32768, 10824, 512, 97, 117, 8036, 8040, 112, 59, 32768, 10822, 112, 59, 32768, 10826, 111, 116, 59, 32768, 8845, 114, 59, 32768, 10821, 59, 32896, 8746, 65024, 1024, 97, 108, 114, 118, 8066, 8078, 8116, 8123, 114, 114, 512, 59, 109, 8073, 8075, 32768, 8631, 59, 32768, 10556, 121, 768, 101, 118, 119, 8086, 8104, 8109, 113, 1089, 8093, 0, 0, 8099, 114, 101, 99, 59, 32768, 8926, 117, 99, 99, 59, 32768, 8927, 101, 101, 59, 32768, 8910, 101, 100, 103, 101, 59, 32768, 8911, 101, 110, 33024, 164, 59, 32768, 164, 101, 97, 114, 114, 111, 119, 512, 108, 114, 8134, 8140, 101, 102, 116, 59, 32768, 8630, 105, 103, 104, 116, 59, 32768, 8631, 101, 101, 59, 32768, 8910, 101, 100, 59, 32768, 8911, 512, 99, 105, 8162, 8170, 111, 110, 105, 110, 116, 59, 32768, 8754, 110, 116, 59, 32768, 8753, 108, 99, 116, 121, 59, 32768, 9005, 4864, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106, 108, 111, 114, 115, 116, 117, 119, 122, 8221, 8226, 8231, 8267, 8282, 8296, 8327, 8351, 8366, 8379, 8466, 8471, 8487, 8621, 8647, 8676, 8697, 8712, 8720, 114, 114, 59, 32768, 8659, 97, 114, 59, 32768, 10597, 1024, 103, 108, 114, 115, 8240, 8246, 8252, 8256, 103, 101, 114, 59, 32768, 8224, 101, 116, 104, 59, 32768, 8504, 114, 59, 32768, 8595, 104, 512, 59, 118, 8262, 8264, 32768, 8208, 59, 32768, 8867, 572, 8271, 8278, 97, 114, 111, 119, 59, 32768, 10511, 97, 99, 59, 32768, 733, 512, 97, 121, 8287, 8293, 114, 111, 110, 59, 32768, 271, 59, 32768, 1076, 768, 59, 97, 111, 8303, 8305, 8320, 32768, 8518, 512, 103, 114, 8310, 8316, 103, 101, 114, 59, 32768, 8225, 114, 59, 32768, 8650, 116, 115, 101, 113, 59, 32768, 10871, 768, 103, 108, 109, 8334, 8339, 8344, 33024, 176, 59, 32768, 176, 116, 97, 59, 32768, 948, 112, 116, 121, 118, 59, 32768, 10673, 512, 105, 114, 8356, 8362, 115, 104, 116, 59, 32768, 10623, 59, 32896, 55349, 56609, 97, 114, 512, 108, 114, 8373, 8376, 59, 32768, 8643, 59, 32768, 8642, 1280, 97, 101, 103, 115, 118, 8390, 8418, 8421, 8428, 8433, 109, 768, 59, 111, 115, 8398, 8400, 8415, 32768, 8900, 110, 100, 512, 59, 115, 8407, 8409, 32768, 8900, 117, 105, 116, 59, 32768, 9830, 59, 32768, 9830, 59, 32768, 168, 97, 109, 109, 97, 59, 32768, 989, 105, 110, 59, 32768, 8946, 768, 59, 105, 111, 8440, 8442, 8461, 32768, 247, 100, 101, 33280, 247, 59, 111, 8450, 8452, 32768, 247, 110, 116, 105, 109, 101, 115, 59, 32768, 8903, 110, 120, 59, 32768, 8903, 99, 121, 59, 32768, 1106, 99, 1088, 8478, 0, 0, 8483, 114, 110, 59, 32768, 8990, 111, 112, 59, 32768, 8973, 1280, 108, 112, 116, 117, 119, 8498, 8504, 8509, 8556, 8570, 108, 97, 114, 59, 32768, 36, 102, 59, 32896, 55349, 56661, 1280, 59, 101, 109, 112, 115, 8520, 8522, 8535, 8542, 8548, 32768, 729, 113, 512, 59, 100, 8528, 8530, 32768, 8784, 111, 116, 59, 32768, 8785, 105, 110, 117, 115, 59, 32768, 8760, 108, 117, 115, 59, 32768, 8724, 113, 117, 97, 114, 101, 59, 32768, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101, 59, 32768, 8966, 110, 768, 97, 100, 104, 8578, 8585, 8597, 114, 114, 111, 119, 59, 32768, 8595, 111, 119, 110, 97, 114, 114, 111, 119, 115, 59, 32768, 8650, 97, 114, 112, 111, 111, 110, 512, 108, 114, 8608, 8614, 101, 102, 116, 59, 32768, 8643, 105, 103, 104, 116, 59, 32768, 8642, 563, 8625, 8633, 107, 97, 114, 111, 119, 59, 32768, 10512, 1088, 8638, 0, 0, 8643, 114, 110, 59, 32768, 8991, 111, 112, 59, 32768, 8972, 768, 99, 111, 116, 8654, 8666, 8670, 512, 114, 121, 8659, 8663, 59, 32896, 55349, 56505, 59, 32768, 1109, 108, 59, 32768, 10742, 114, 111, 107, 59, 32768, 273, 512, 100, 114, 8681, 8686, 111, 116, 59, 32768, 8945, 105, 512, 59, 102, 8692, 8694, 32768, 9663, 59, 32768, 9662, 512, 97, 104, 8702, 8707, 114, 114, 59, 32768, 8693, 97, 114, 59, 32768, 10607, 97, 110, 103, 108, 101, 59, 32768, 10662, 512, 99, 105, 8725, 8729, 121, 59, 32768, 1119, 103, 114, 97, 114, 114, 59, 32768, 10239, 4608, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 120, 8774, 8788, 8807, 8844, 8849, 8852, 8866, 8895, 8929, 8977, 8989, 9004, 9046, 9136, 9151, 9171, 9184, 9199, 512, 68, 111, 8779, 8784, 111, 116, 59, 32768, 10871, 116, 59, 32768, 8785, 512, 99, 115, 8793, 8801, 117, 116, 101, 33024, 233, 59, 32768, 233, 116, 101, 114, 59, 32768, 10862, 1024, 97, 105, 111, 121, 8816, 8822, 8835, 8841, 114, 111, 110, 59, 32768, 283, 114, 512, 59, 99, 8828, 8830, 32768, 8790, 33024, 234, 59, 32768, 234, 108, 111, 110, 59, 32768, 8789, 59, 32768, 1101, 111, 116, 59, 32768, 279, 59, 32768, 8519, 512, 68, 114, 8857, 8862, 111, 116, 59, 32768, 8786, 59, 32896, 55349, 56610, 768, 59, 114, 115, 8873, 8875, 8883, 32768, 10906, 97, 118, 101, 33024, 232, 59, 32768, 232, 512, 59, 100, 8888, 8890, 32768, 10902, 111, 116, 59, 32768, 10904, 1024, 59, 105, 108, 115, 8904, 8906, 8914, 8917, 32768, 10905, 110, 116, 101, 114, 115, 59, 32768, 9191, 59, 32768, 8467, 512, 59, 100, 8922, 8924, 32768, 10901, 111, 116, 59, 32768, 10903, 768, 97, 112, 115, 8936, 8941, 8960, 99, 114, 59, 32768, 275, 116, 121, 768, 59, 115, 118, 8950, 8952, 8957, 32768, 8709, 101, 116, 59, 32768, 8709, 59, 32768, 8709, 112, 512, 49, 59, 8966, 8975, 516, 8970, 8973, 59, 32768, 8196, 59, 32768, 8197, 32768, 8195, 512, 103, 115, 8982, 8985, 59, 32768, 331, 112, 59, 32768, 8194, 512, 103, 112, 8994, 8999, 111, 110, 59, 32768, 281, 102, 59, 32896, 55349, 56662, 768, 97, 108, 115, 9011, 9023, 9028, 114, 512, 59, 115, 9017, 9019, 32768, 8917, 108, 59, 32768, 10723, 117, 115, 59, 32768, 10865, 105, 768, 59, 108, 118, 9036, 9038, 9043, 32768, 949, 111, 110, 59, 32768, 949, 59, 32768, 1013, 1024, 99, 115, 117, 118, 9055, 9071, 9099, 9128, 512, 105, 111, 9060, 9065, 114, 99, 59, 32768, 8790, 108, 111, 110, 59, 32768, 8789, 1082, 9077, 0, 0, 9081, 109, 59, 32768, 8770, 97, 110, 116, 512, 103, 108, 9088, 9093, 116, 114, 59, 32768, 10902, 101, 115, 115, 59, 32768, 10901, 768, 97, 101, 105, 9106, 9111, 9116, 108, 115, 59, 32768, 61, 115, 116, 59, 32768, 8799, 118, 512, 59, 68, 9122, 9124, 32768, 8801, 68, 59, 32768, 10872, 112, 97, 114, 115, 108, 59, 32768, 10725, 512, 68, 97, 9141, 9146, 111, 116, 59, 32768, 8787, 114, 114, 59, 32768, 10609, 768, 99, 100, 105, 9158, 9162, 9167, 114, 59, 32768, 8495, 111, 116, 59, 32768, 8784, 109, 59, 32768, 8770, 512, 97, 104, 9176, 9179, 59, 32768, 951, 33024, 240, 59, 32768, 240, 512, 109, 114, 9189, 9195, 108, 33024, 235, 59, 32768, 235, 111, 59, 32768, 8364, 768, 99, 105, 112, 9206, 9210, 9215, 108, 59, 32768, 33, 115, 116, 59, 32768, 8707, 512, 101, 111, 9220, 9230, 99, 116, 97, 116, 105, 111, 110, 59, 32768, 8496, 110, 101, 110, 116, 105, 97, 108, 101, 59, 32768, 8519, 4914, 9262, 0, 9276, 0, 9280, 9287, 0, 0, 9318, 9324, 0, 9331, 0, 9352, 9357, 9386, 0, 9395, 9497, 108, 108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 32768, 8786, 121, 59, 32768, 1092, 109, 97, 108, 101, 59, 32768, 9792, 768, 105, 108, 114, 9293, 9299, 9313, 108, 105, 103, 59, 32768, 64259, 1082, 9305, 0, 0, 9309, 103, 59, 32768, 64256, 105, 103, 59, 32768, 64260, 59, 32896, 55349, 56611, 108, 105, 103, 59, 32768, 64257, 108, 105, 103, 59, 32896, 102, 106, 768, 97, 108, 116, 9337, 9341, 9346, 116, 59, 32768, 9837, 105, 103, 59, 32768, 64258, 110, 115, 59, 32768, 9649, 111, 102, 59, 32768, 402, 833, 9361, 0, 9366, 102, 59, 32896, 55349, 56663, 512, 97, 107, 9370, 9375, 108, 108, 59, 32768, 8704, 512, 59, 118, 9380, 9382, 32768, 8916, 59, 32768, 10969, 97, 114, 116, 105, 110, 116, 59, 32768, 10765, 512, 97, 111, 9399, 9491, 512, 99, 115, 9404, 9487, 1794, 9413, 9443, 9453, 9470, 9474, 0, 9484, 1795, 9421, 9426, 9429, 9434, 9437, 0, 9440, 33024, 189, 59, 32768, 189, 59, 32768, 8531, 33024, 188, 59, 32768, 188, 59, 32768, 8533, 59, 32768, 8537, 59, 32768, 8539, 772, 9447, 0, 9450, 59, 32768, 8532, 59, 32768, 8534, 1285, 9459, 9464, 0, 0, 9467, 33024, 190, 59, 32768, 190, 59, 32768, 8535, 59, 32768, 8540, 53, 59, 32768, 8536, 775, 9478, 0, 9481, 59, 32768, 8538, 59, 32768, 8541, 56, 59, 32768, 8542, 108, 59, 32768, 8260, 119, 110, 59, 32768, 8994, 99, 114, 59, 32896, 55349, 56507, 4352, 69, 97, 98, 99, 100, 101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 9537, 9547, 9575, 9582, 9595, 9600, 9679, 9684, 9694, 9700, 9705, 9725, 9773, 9779, 9785, 9810, 9917, 512, 59, 108, 9542, 9544, 32768, 8807, 59, 32768, 10892, 768, 99, 109, 112, 9554, 9560, 9572, 117, 116, 101, 59, 32768, 501, 109, 97, 512, 59, 100, 9567, 9569, 32768, 947, 59, 32768, 989, 59, 32768, 10886, 114, 101, 118, 101, 59, 32768, 287, 512, 105, 121, 9587, 9592, 114, 99, 59, 32768, 285, 59, 32768, 1075, 111, 116, 59, 32768, 289, 1024, 59, 108, 113, 115, 9609, 9611, 9614, 9633, 32768, 8805, 59, 32768, 8923, 768, 59, 113, 115, 9621, 9623, 9626, 32768, 8805, 59, 32768, 8807, 108, 97, 110, 116, 59, 32768, 10878, 1024, 59, 99, 100, 108, 9642, 9644, 9648, 9667, 32768, 10878, 99, 59, 32768, 10921, 111, 116, 512, 59, 111, 9655, 9657, 32768, 10880, 512, 59, 108, 9662, 9664, 32768, 10882, 59, 32768, 10884, 512, 59, 101, 9672, 9675, 32896, 8923, 65024, 115, 59, 32768, 10900, 114, 59, 32896, 55349, 56612, 512, 59, 103, 9689, 9691, 32768, 8811, 59, 32768, 8921, 109, 101, 108, 59, 32768, 8503, 99, 121, 59, 32768, 1107, 1024, 59, 69, 97, 106, 9714, 9716, 9719, 9722, 32768, 8823, 59, 32768, 10898, 59, 32768, 10917, 59, 32768, 10916, 1024, 69, 97, 101, 115, 9734, 9737, 9751, 9768, 59, 32768, 8809, 112, 512, 59, 112, 9743, 9745, 32768, 10890, 114, 111, 120, 59, 32768, 10890, 512, 59, 113, 9756, 9758, 32768, 10888, 512, 59, 113, 9763, 9765, 32768, 10888, 59, 32768, 8809, 105, 109, 59, 32768, 8935, 112, 102, 59, 32896, 55349, 56664, 97, 118, 101, 59, 32768, 96, 512, 99, 105, 9790, 9794, 114, 59, 32768, 8458, 109, 768, 59, 101, 108, 9802, 9804, 9807, 32768, 8819, 59, 32768, 10894, 59, 32768, 10896, 34304, 62, 59, 99, 100, 108, 113, 114, 9824, 9826, 9838, 9843, 9849, 9856, 32768, 62, 512, 99, 105, 9831, 9834, 59, 32768, 10919, 114, 59, 32768, 10874, 111, 116, 59, 32768, 8919, 80, 97, 114, 59, 32768, 10645, 117, 101, 115, 116, 59, 32768, 10876, 1280, 97, 100, 101, 108, 115, 9867, 9882, 9887, 9906, 9912, 833, 9872, 0, 9879, 112, 114, 111, 120, 59, 32768, 10886, 114, 59, 32768, 10616, 111, 116, 59, 32768, 8919, 113, 512, 108, 113, 9893, 9899, 101, 115, 115, 59, 32768, 8923, 108, 101, 115, 115, 59, 32768, 10892, 101, 115, 115, 59, 32768, 8823, 105, 109, 59, 32768, 8819, 512, 101, 110, 9922, 9932, 114, 116, 110, 101, 113, 113, 59, 32896, 8809, 65024, 69, 59, 32896, 8809, 65024, 2560, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 9958, 9963, 10015, 10020, 10026, 10060, 10065, 10085, 10147, 10171, 114, 114, 59, 32768, 8660, 1024, 105, 108, 109, 114, 9972, 9978, 9982, 9988, 114, 115, 112, 59, 32768, 8202, 102, 59, 32768, 189, 105, 108, 116, 59, 32768, 8459, 512, 100, 114, 9993, 9998, 99, 121, 59, 32768, 1098, 768, 59, 99, 119, 10005, 10007, 10012, 32768, 8596, 105, 114, 59, 32768, 10568, 59, 32768, 8621, 97, 114, 59, 32768, 8463, 105, 114, 99, 59, 32768, 293, 768, 97, 108, 114, 10033, 10048, 10054, 114, 116, 115, 512, 59, 117, 10041, 10043, 32768, 9829, 105, 116, 59, 32768, 9829, 108, 105, 112, 59, 32768, 8230, 99, 111, 110, 59, 32768, 8889, 114, 59, 32896, 55349, 56613, 115, 512, 101, 119, 10071, 10078, 97, 114, 111, 119, 59, 32768, 10533, 97, 114, 111, 119, 59, 32768, 10534, 1280, 97, 109, 111, 112, 114, 10096, 10101, 10107, 10136, 10141, 114, 114, 59, 32768, 8703, 116, 104, 116, 59, 32768, 8763, 107, 512, 108, 114, 10113, 10124, 101, 102, 116, 97, 114, 114, 111, 119, 59, 32768, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8618, 102, 59, 32896, 55349, 56665, 98, 97, 114, 59, 32768, 8213, 768, 99, 108, 116, 10154, 10159, 10165, 114, 59, 32896, 55349, 56509, 97, 115, 104, 59, 32768, 8463, 114, 111, 107, 59, 32768, 295, 512, 98, 112, 10176, 10182, 117, 108, 108, 59, 32768, 8259, 104, 101, 110, 59, 32768, 8208, 5426, 10211, 0, 10220, 0, 10239, 10255, 10267, 0, 10276, 10312, 0, 0, 10318, 10371, 10458, 10485, 10491, 0, 10500, 10545, 10558, 99, 117, 116, 101, 33024, 237, 59, 32768, 237, 768, 59, 105, 121, 10226, 10228, 10235, 32768, 8291, 114, 99, 33024, 238, 59, 32768, 238, 59, 32768, 1080, 512, 99, 120, 10243, 10247, 121, 59, 32768, 1077, 99, 108, 33024, 161, 59, 32768, 161, 512, 102, 114, 10259, 10262, 59, 32768, 8660, 59, 32896, 55349, 56614, 114, 97, 118, 101, 33024, 236, 59, 32768, 236, 1024, 59, 105, 110, 111, 10284, 10286, 10300, 10306, 32768, 8520, 512, 105, 110, 10291, 10296, 110, 116, 59, 32768, 10764, 116, 59, 32768, 8749, 102, 105, 110, 59, 32768, 10716, 116, 97, 59, 32768, 8489, 108, 105, 103, 59, 32768, 307, 768, 97, 111, 112, 10324, 10361, 10365, 768, 99, 103, 116, 10331, 10335, 10357, 114, 59, 32768, 299, 768, 101, 108, 112, 10342, 10345, 10351, 59, 32768, 8465, 105, 110, 101, 59, 32768, 8464, 97, 114, 116, 59, 32768, 8465, 104, 59, 32768, 305, 102, 59, 32768, 8887, 101, 100, 59, 32768, 437, 1280, 59, 99, 102, 111, 116, 10381, 10383, 10389, 10403, 10409, 32768, 8712, 97, 114, 101, 59, 32768, 8453, 105, 110, 512, 59, 116, 10396, 10398, 32768, 8734, 105, 101, 59, 32768, 10717, 100, 111, 116, 59, 32768, 305, 1280, 59, 99, 101, 108, 112, 10420, 10422, 10427, 10444, 10451, 32768, 8747, 97, 108, 59, 32768, 8890, 512, 103, 114, 10432, 10438, 101, 114, 115, 59, 32768, 8484, 99, 97, 108, 59, 32768, 8890, 97, 114, 104, 107, 59, 32768, 10775, 114, 111, 100, 59, 32768, 10812, 1024, 99, 103, 112, 116, 10466, 10470, 10475, 10480, 121, 59, 32768, 1105, 111, 110, 59, 32768, 303, 102, 59, 32896, 55349, 56666, 97, 59, 32768, 953, 114, 111, 100, 59, 32768, 10812, 117, 101, 115, 116, 33024, 191, 59, 32768, 191, 512, 99, 105, 10504, 10509, 114, 59, 32896, 55349, 56510, 110, 1280, 59, 69, 100, 115, 118, 10521, 10523, 10526, 10531, 10541, 32768, 8712, 59, 32768, 8953, 111, 116, 59, 32768, 8949, 512, 59, 118, 10536, 10538, 32768, 8948, 59, 32768, 8947, 59, 32768, 8712, 512, 59, 105, 10549, 10551, 32768, 8290, 108, 100, 101, 59, 32768, 297, 828, 10562, 0, 10567, 99, 121, 59, 32768, 1110, 108, 33024, 239, 59, 32768, 239, 1536, 99, 102, 109, 111, 115, 117, 10585, 10598, 10603, 10609, 10615, 10630, 512, 105, 121, 10590, 10595, 114, 99, 59, 32768, 309, 59, 32768, 1081, 114, 59, 32896, 55349, 56615, 97, 116, 104, 59, 32768, 567, 112, 102, 59, 32896, 55349, 56667, 820, 10620, 0, 10625, 114, 59, 32896, 55349, 56511, 114, 99, 121, 59, 32768, 1112, 107, 99, 121, 59, 32768, 1108, 2048, 97, 99, 102, 103, 104, 106, 111, 115, 10653, 10666, 10680, 10685, 10692, 10697, 10702, 10708, 112, 112, 97, 512, 59, 118, 10661, 10663, 32768, 954, 59, 32768, 1008, 512, 101, 121, 10671, 10677, 100, 105, 108, 59, 32768, 311, 59, 32768, 1082, 114, 59, 32896, 55349, 56616, 114, 101, 101, 110, 59, 32768, 312, 99, 121, 59, 32768, 1093, 99, 121, 59, 32768, 1116, 112, 102, 59, 32896, 55349, 56668, 99, 114, 59, 32896, 55349, 56512, 5888, 65, 66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116, 117, 118, 10761, 10783, 10789, 10799, 10804, 10957, 11011, 11047, 11094, 11349, 11372, 11382, 11409, 11414, 11451, 11478, 11526, 11698, 11711, 11755, 11823, 11910, 11929, 768, 97, 114, 116, 10768, 10773, 10777, 114, 114, 59, 32768, 8666, 114, 59, 32768, 8656, 97, 105, 108, 59, 32768, 10523, 97, 114, 114, 59, 32768, 10510, 512, 59, 103, 10794, 10796, 32768, 8806, 59, 32768, 10891, 97, 114, 59, 32768, 10594, 4660, 10824, 0, 10830, 0, 10838, 0, 0, 0, 0, 0, 10844, 10850, 0, 10867, 10870, 10877, 0, 10933, 117, 116, 101, 59, 32768, 314, 109, 112, 116, 121, 118, 59, 32768, 10676, 114, 97, 110, 59, 32768, 8466, 98, 100, 97, 59, 32768, 955, 103, 768, 59, 100, 108, 10857, 10859, 10862, 32768, 10216, 59, 32768, 10641, 101, 59, 32768, 10216, 59, 32768, 10885, 117, 111, 33024, 171, 59, 32768, 171, 114, 2048, 59, 98, 102, 104, 108, 112, 115, 116, 10894, 10896, 10907, 10911, 10915, 10919, 10923, 10928, 32768, 8592, 512, 59, 102, 10901, 10903, 32768, 8676, 115, 59, 32768, 10527, 115, 59, 32768, 10525, 107, 59, 32768, 8617, 112, 59, 32768, 8619, 108, 59, 32768, 10553, 105, 109, 59, 32768, 10611, 108, 59, 32768, 8610, 768, 59, 97, 101, 10939, 10941, 10946, 32768, 10923, 105, 108, 59, 32768, 10521, 512, 59, 115, 10951, 10953, 32768, 10925, 59, 32896, 10925, 65024, 768, 97, 98, 114, 10964, 10969, 10974, 114, 114, 59, 32768, 10508, 114, 107, 59, 32768, 10098, 512, 97, 107, 10979, 10991, 99, 512, 101, 107, 10985, 10988, 59, 32768, 123, 59, 32768, 91, 512, 101, 115, 10996, 10999, 59, 32768, 10635, 108, 512, 100, 117, 11005, 11008, 59, 32768, 10639, 59, 32768, 10637, 1024, 97, 101, 117, 121, 11020, 11026, 11040, 11044, 114, 111, 110, 59, 32768, 318, 512, 100, 105, 11031, 11036, 105, 108, 59, 32768, 316, 108, 59, 32768, 8968, 98, 59, 32768, 123, 59, 32768, 1083, 1024, 99, 113, 114, 115, 11056, 11060, 11072, 11090, 97, 59, 32768, 10550, 117, 111, 512, 59, 114, 11067, 11069, 32768, 8220, 59, 32768, 8222, 512, 100, 117, 11077, 11083, 104, 97, 114, 59, 32768, 10599, 115, 104, 97, 114, 59, 32768, 10571, 104, 59, 32768, 8626, 1280, 59, 102, 103, 113, 115, 11105, 11107, 11228, 11231, 11250, 32768, 8804, 116, 1280, 97, 104, 108, 114, 116, 11119, 11136, 11157, 11169, 11216, 114, 114, 111, 119, 512, 59, 116, 11128, 11130, 32768, 8592, 97, 105, 108, 59, 32768, 8610, 97, 114, 112, 111, 111, 110, 512, 100, 117, 11147, 11153, 111, 119, 110, 59, 32768, 8637, 112, 59, 32768, 8636, 101, 102, 116, 97, 114, 114, 111, 119, 115, 59, 32768, 8647, 105, 103, 104, 116, 768, 97, 104, 115, 11180, 11194, 11204, 114, 114, 111, 119, 512, 59, 115, 11189, 11191, 32768, 8596, 59, 32768, 8646, 97, 114, 112, 111, 111, 110, 115, 59, 32768, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 32768, 8621, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 32768, 8907, 59, 32768, 8922, 768, 59, 113, 115, 11238, 11240, 11243, 32768, 8804, 59, 32768, 8806, 108, 97, 110, 116, 59, 32768, 10877, 1280, 59, 99, 100, 103, 115, 11261, 11263, 11267, 11286, 11298, 32768, 10877, 99, 59, 32768, 10920, 111, 116, 512, 59, 111, 11274, 11276, 32768, 10879, 512, 59, 114, 11281, 11283, 32768, 10881, 59, 32768, 10883, 512, 59, 101, 11291, 11294, 32896, 8922, 65024, 115, 59, 32768, 10899, 1280, 97, 100, 101, 103, 115, 11309, 11317, 11322, 11339, 11344, 112, 112, 114, 111, 120, 59, 32768, 10885, 111, 116, 59, 32768, 8918, 113, 512, 103, 113, 11328, 11333, 116, 114, 59, 32768, 8922, 103, 116, 114, 59, 32768, 10891, 116, 114, 59, 32768, 8822, 105, 109, 59, 32768, 8818, 768, 105, 108, 114, 11356, 11362, 11368, 115, 104, 116, 59, 32768, 10620, 111, 111, 114, 59, 32768, 8970, 59, 32896, 55349, 56617, 512, 59, 69, 11377, 11379, 32768, 8822, 59, 32768, 10897, 562, 11386, 11405, 114, 512, 100, 117, 11391, 11394, 59, 32768, 8637, 512, 59, 108, 11399, 11401, 32768, 8636, 59, 32768, 10602, 108, 107, 59, 32768, 9604, 99, 121, 59, 32768, 1113, 1280, 59, 97, 99, 104, 116, 11425, 11427, 11432, 11440, 11446, 32768, 8810, 114, 114, 59, 32768, 8647, 111, 114, 110, 101, 114, 59, 32768, 8990, 97, 114, 100, 59, 32768, 10603, 114, 105, 59, 32768, 9722, 512, 105, 111, 11456, 11462, 100, 111, 116, 59, 32768, 320, 117, 115, 116, 512, 59, 97, 11470, 11472, 32768, 9136, 99, 104, 101, 59, 32768, 9136, 1024, 69, 97, 101, 115, 11487, 11490, 11504, 11521, 59, 32768, 8808, 112, 512, 59, 112, 11496, 11498, 32768, 10889, 114, 111, 120, 59, 32768, 10889, 512, 59, 113, 11509, 11511, 32768, 10887, 512, 59, 113, 11516, 11518, 32768, 10887, 59, 32768, 8808, 105, 109, 59, 32768, 8934, 2048, 97, 98, 110, 111, 112, 116, 119, 122, 11543, 11556, 11561, 11616, 11640, 11660, 11667, 11680, 512, 110, 114, 11548, 11552, 103, 59, 32768, 10220, 114, 59, 32768, 8701, 114, 107, 59, 32768, 10214, 103, 768, 108, 109, 114, 11569, 11596, 11604, 101, 102, 116, 512, 97, 114, 11577, 11584, 114, 114, 111, 119, 59, 32768, 10229, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10231, 97, 112, 115, 116, 111, 59, 32768, 10236, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 10230, 112, 97, 114, 114, 111, 119, 512, 108, 114, 11627, 11633, 101, 102, 116, 59, 32768, 8619, 105, 103, 104, 116, 59, 32768, 8620, 768, 97, 102, 108, 11647, 11651, 11655, 114, 59, 32768, 10629, 59, 32896, 55349, 56669, 117, 115, 59, 32768, 10797, 105, 109, 101, 115, 59, 32768, 10804, 562, 11671, 11676, 115, 116, 59, 32768, 8727, 97, 114, 59, 32768, 95, 768, 59, 101, 102, 11687, 11689, 11695, 32768, 9674, 110, 103, 101, 59, 32768, 9674, 59, 32768, 10731, 97, 114, 512, 59, 108, 11705, 11707, 32768, 40, 116, 59, 32768, 10643, 1280, 97, 99, 104, 109, 116, 11722, 11727, 11735, 11747, 11750, 114, 114, 59, 32768, 8646, 111, 114, 110, 101, 114, 59, 32768, 8991, 97, 114, 512, 59, 100, 11742, 11744, 32768, 8651, 59, 32768, 10605, 59, 32768, 8206, 114, 105, 59, 32768, 8895, 1536, 97, 99, 104, 105, 113, 116, 11768, 11774, 11779, 11782, 11798, 11817, 113, 117, 111, 59, 32768, 8249, 114, 59, 32896, 55349, 56513, 59, 32768, 8624, 109, 768, 59, 101, 103, 11790, 11792, 11795, 32768, 8818, 59, 32768, 10893, 59, 32768, 10895, 512, 98, 117, 11803, 11806, 59, 32768, 91, 111, 512, 59, 114, 11812, 11814, 32768, 8216, 59, 32768, 8218, 114, 111, 107, 59, 32768, 322, 34816, 60, 59, 99, 100, 104, 105, 108, 113, 114, 11841, 11843, 11855, 11860, 11866, 11872, 11878, 11885, 32768, 60, 512, 99, 105, 11848, 11851, 59, 32768, 10918, 114, 59, 32768, 10873, 111, 116, 59, 32768, 8918, 114, 101, 101, 59, 32768, 8907, 109, 101, 115, 59, 32768, 8905, 97, 114, 114, 59, 32768, 10614, 117, 101, 115, 116, 59, 32768, 10875, 512, 80, 105, 11890, 11895, 97, 114, 59, 32768, 10646, 768, 59, 101, 102, 11902, 11904, 11907, 32768, 9667, 59, 32768, 8884, 59, 32768, 9666, 114, 512, 100, 117, 11916, 11923, 115, 104, 97, 114, 59, 32768, 10570, 104, 97, 114, 59, 32768, 10598, 512, 101, 110, 11934, 11944, 114, 116, 110, 101, 113, 113, 59, 32896, 8808, 65024, 69, 59, 32896, 8808, 65024, 3584, 68, 97, 99, 100, 101, 102, 104, 105, 108, 110, 111, 112, 115, 117, 11978, 11984, 12061, 12075, 12081, 12095, 12100, 12104, 12170, 12181, 12188, 12204, 12207, 12223, 68, 111, 116, 59, 32768, 8762, 1024, 99, 108, 112, 114, 11993, 11999, 12019, 12055, 114, 33024, 175, 59, 32768, 175, 512, 101, 116, 12004, 12007, 59, 32768, 9794, 512, 59, 101, 12012, 12014, 32768, 10016, 115, 101, 59, 32768, 10016, 512, 59, 115, 12024, 12026, 32768, 8614, 116, 111, 1024, 59, 100, 108, 117, 12037, 12039, 12045, 12051, 32768, 8614, 111, 119, 110, 59, 32768, 8615, 101, 102, 116, 59, 32768, 8612, 112, 59, 32768, 8613, 107, 101, 114, 59, 32768, 9646, 512, 111, 121, 12066, 12072, 109, 109, 97, 59, 32768, 10793, 59, 32768, 1084, 97, 115, 104, 59, 32768, 8212, 97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 32768, 8737, 114, 59, 32896, 55349, 56618, 111, 59, 32768, 8487, 768, 99, 100, 110, 12111, 12118, 12146, 114, 111, 33024, 181, 59, 32768, 181, 1024, 59, 97, 99, 100, 12127, 12129, 12134, 12139, 32768, 8739, 115, 116, 59, 32768, 42, 105, 114, 59, 32768, 10992, 111, 116, 33024, 183, 59, 32768, 183, 117, 115, 768, 59, 98, 100, 12155, 12157, 12160, 32768, 8722, 59, 32768, 8863, 512, 59, 117, 12165, 12167, 32768, 8760, 59, 32768, 10794, 564, 12174, 12178, 112, 59, 32768, 10971, 114, 59, 32768, 8230, 112, 108, 117, 115, 59, 32768, 8723, 512, 100, 112, 12193, 12199, 101, 108, 115, 59, 32768, 8871, 102, 59, 32896, 55349, 56670, 59, 32768, 8723, 512, 99, 116, 12212, 12217, 114, 59, 32896, 55349, 56514, 112, 111, 115, 59, 32768, 8766, 768, 59, 108, 109, 12230, 12232, 12240, 32768, 956, 116, 105, 109, 97, 112, 59, 32768, 8888, 97, 112, 59, 32768, 8888, 6144, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111, 112, 114, 115, 116, 117, 118, 119, 12294, 12315, 12364, 12376, 12393, 12472, 12496, 12547, 12553, 12636, 12641, 12703, 12725, 12747, 12752, 12876, 12881, 12957, 13033, 13089, 13294, 13359, 13384, 13499, 512, 103, 116, 12299, 12303, 59, 32896, 8921, 824, 512, 59, 118, 12308, 12311, 32896, 8811, 8402, 59, 32896, 8811, 824, 768, 101, 108, 116, 12322, 12348, 12352, 102, 116, 512, 97, 114, 12329, 12336, 114, 114, 111, 119, 59, 32768, 8653, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8654, 59, 32896, 8920, 824, 512, 59, 118, 12357, 12360, 32896, 8810, 8402, 59, 32896, 8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8655, 512, 68, 100, 12381, 12387, 97, 115, 104, 59, 32768, 8879, 97, 115, 104, 59, 32768, 8878, 1280, 98, 99, 110, 112, 116, 12404, 12409, 12415, 12420, 12452, 108, 97, 59, 32768, 8711, 117, 116, 101, 59, 32768, 324, 103, 59, 32896, 8736, 8402, 1280, 59, 69, 105, 111, 112, 12431, 12433, 12437, 12442, 12446, 32768, 8777, 59, 32896, 10864, 824, 100, 59, 32896, 8779, 824, 115, 59, 32768, 329, 114, 111, 120, 59, 32768, 8777, 117, 114, 512, 59, 97, 12459, 12461, 32768, 9838, 108, 512, 59, 115, 12467, 12469, 32768, 9838, 59, 32768, 8469, 836, 12477, 0, 12483, 112, 33024, 160, 59, 32768, 160, 109, 112, 512, 59, 101, 12489, 12492, 32896, 8782, 824, 59, 32896, 8783, 824, 1280, 97, 101, 111, 117, 121, 12507, 12519, 12525, 12540, 12544, 833, 12512, 0, 12515, 59, 32768, 10819, 111, 110, 59, 32768, 328, 100, 105, 108, 59, 32768, 326, 110, 103, 512, 59, 100, 12532, 12534, 32768, 8775, 111, 116, 59, 32896, 10861, 824, 112, 59, 32768, 10818, 59, 32768, 1085, 97, 115, 104, 59, 32768, 8211, 1792, 59, 65, 97, 100, 113, 115, 120, 12568, 12570, 12575, 12596, 12602, 12608, 12623, 32768, 8800, 114, 114, 59, 32768, 8663, 114, 512, 104, 114, 12581, 12585, 107, 59, 32768, 10532, 512, 59, 111, 12590, 12592, 32768, 8599, 119, 59, 32768, 8599, 111, 116, 59, 32896, 8784, 824, 117, 105, 118, 59, 32768, 8802, 512, 101, 105, 12613, 12618, 97, 114, 59, 32768, 10536, 109, 59, 32896, 8770, 824, 105, 115, 116, 512, 59, 115, 12631, 12633, 32768, 8708, 59, 32768, 8708, 114, 59, 32896, 55349, 56619, 1024, 69, 101, 115, 116, 12650, 12654, 12688, 12693, 59, 32896, 8807, 824, 768, 59, 113, 115, 12661, 12663, 12684, 32768, 8817, 768, 59, 113, 115, 12670, 12672, 12676, 32768, 8817, 59, 32896, 8807, 824, 108, 97, 110, 116, 59, 32896, 10878, 824, 59, 32896, 10878, 824, 105, 109, 59, 32768, 8821, 512, 59, 114, 12698, 12700, 32768, 8815, 59, 32768, 8815, 768, 65, 97, 112, 12710, 12715, 12720, 114, 114, 59, 32768, 8654, 114, 114, 59, 32768, 8622, 97, 114, 59, 32768, 10994, 768, 59, 115, 118, 12732, 12734, 12744, 32768, 8715, 512, 59, 100, 12739, 12741, 32768, 8956, 59, 32768, 8954, 59, 32768, 8715, 99, 121, 59, 32768, 1114, 1792, 65, 69, 97, 100, 101, 115, 116, 12767, 12772, 12776, 12781, 12785, 12853, 12858, 114, 114, 59, 32768, 8653, 59, 32896, 8806, 824, 114, 114, 59, 32768, 8602, 114, 59, 32768, 8229, 1024, 59, 102, 113, 115, 12794, 12796, 12821, 12842, 32768, 8816, 116, 512, 97, 114, 12802, 12809, 114, 114, 111, 119, 59, 32768, 8602, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8622, 768, 59, 113, 115, 12828, 12830, 12834, 32768, 8816, 59, 32896, 8806, 824, 108, 97, 110, 116, 59, 32896, 10877, 824, 512, 59, 115, 12847, 12850, 32896, 10877, 824, 59, 32768, 8814, 105, 109, 59, 32768, 8820, 512, 59, 114, 12863, 12865, 32768, 8814, 105, 512, 59, 101, 12871, 12873, 32768, 8938, 59, 32768, 8940, 105, 100, 59, 32768, 8740, 512, 112, 116, 12886, 12891, 102, 59, 32896, 55349, 56671, 33536, 172, 59, 105, 110, 12899, 12901, 12936, 32768, 172, 110, 1024, 59, 69, 100, 118, 12911, 12913, 12917, 12923, 32768, 8713, 59, 32896, 8953, 824, 111, 116, 59, 32896, 8949, 824, 818, 12928, 12931, 12934, 59, 32768, 8713, 59, 32768, 8951, 59, 32768, 8950, 105, 512, 59, 118, 12942, 12944, 32768, 8716, 818, 12949, 12952, 12955, 59, 32768, 8716, 59, 32768, 8958, 59, 32768, 8957, 768, 97, 111, 114, 12964, 12992, 12999, 114, 1024, 59, 97, 115, 116, 12974, 12976, 12983, 12988, 32768, 8742, 108, 108, 101, 108, 59, 32768, 8742, 108, 59, 32896, 11005, 8421, 59, 32896, 8706, 824, 108, 105, 110, 116, 59, 32768, 10772, 768, 59, 99, 101, 13006, 13008, 13013, 32768, 8832, 117, 101, 59, 32768, 8928, 512, 59, 99, 13018, 13021, 32896, 10927, 824, 512, 59, 101, 13026, 13028, 32768, 8832, 113, 59, 32896, 10927, 824, 1024, 65, 97, 105, 116, 13042, 13047, 13066, 13077, 114, 114, 59, 32768, 8655, 114, 114, 768, 59, 99, 119, 13056, 13058, 13062, 32768, 8603, 59, 32896, 10547, 824, 59, 32896, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8603, 114, 105, 512, 59, 101, 13084, 13086, 32768, 8939, 59, 32768, 8941, 1792, 99, 104, 105, 109, 112, 113, 117, 13104, 13128, 13151, 13169, 13174, 13179, 13194, 1024, 59, 99, 101, 114, 13113, 13115, 13120, 13124, 32768, 8833, 117, 101, 59, 32768, 8929, 59, 32896, 10928, 824, 59, 32896, 55349, 56515, 111, 114, 116, 1086, 13137, 0, 0, 13142, 105, 100, 59, 32768, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 32768, 8742, 109, 512, 59, 101, 13157, 13159, 32768, 8769, 512, 59, 113, 13164, 13166, 32768, 8772, 59, 32768, 8772, 105, 100, 59, 32768, 8740, 97, 114, 59, 32768, 8742, 115, 117, 512, 98, 112, 13186, 13190, 101, 59, 32768, 8930, 101, 59, 32768, 8931, 768, 98, 99, 112, 13201, 13241, 13254, 1024, 59, 69, 101, 115, 13210, 13212, 13216, 13219, 32768, 8836, 59, 32896, 10949, 824, 59, 32768, 8840, 101, 116, 512, 59, 101, 13226, 13229, 32896, 8834, 8402, 113, 512, 59, 113, 13235, 13237, 32768, 8840, 59, 32896, 10949, 824, 99, 512, 59, 101, 13247, 13249, 32768, 8833, 113, 59, 32896, 10928, 824, 1024, 59, 69, 101, 115, 13263, 13265, 13269, 13272, 32768, 8837, 59, 32896, 10950, 824, 59, 32768, 8841, 101, 116, 512, 59, 101, 13279, 13282, 32896, 8835, 8402, 113, 512, 59, 113, 13288, 13290, 32768, 8841, 59, 32896, 10950, 824, 1024, 103, 105, 108, 114, 13303, 13307, 13315, 13319, 108, 59, 32768, 8825, 108, 100, 101, 33024, 241, 59, 32768, 241, 103, 59, 32768, 8824, 105, 97, 110, 103, 108, 101, 512, 108, 114, 13330, 13344, 101, 102, 116, 512, 59, 101, 13338, 13340, 32768, 8938, 113, 59, 32768, 8940, 105, 103, 104, 116, 512, 59, 101, 13353, 13355, 32768, 8939, 113, 59, 32768, 8941, 512, 59, 109, 13364, 13366, 32768, 957, 768, 59, 101, 115, 13373, 13375, 13380, 32768, 35, 114, 111, 59, 32768, 8470, 112, 59, 32768, 8199, 2304, 68, 72, 97, 100, 103, 105, 108, 114, 115, 13403, 13409, 13415, 13420, 13426, 13439, 13446, 13476, 13493, 97, 115, 104, 59, 32768, 8877, 97, 114, 114, 59, 32768, 10500, 112, 59, 32896, 8781, 8402, 97, 115, 104, 59, 32768, 8876, 512, 101, 116, 13431, 13435, 59, 32896, 8805, 8402, 59, 32896, 62, 8402, 110, 102, 105, 110, 59, 32768, 10718, 768, 65, 101, 116, 13453, 13458, 13462, 114, 114, 59, 32768, 10498, 59, 32896, 8804, 8402, 512, 59, 114, 13467, 13470, 32896, 60, 8402, 105, 101, 59, 32896, 8884, 8402, 512, 65, 116, 13481, 13486, 114, 114, 59, 32768, 10499, 114, 105, 101, 59, 32896, 8885, 8402, 105, 109, 59, 32896, 8764, 8402, 768, 65, 97, 110, 13506, 13511, 13532, 114, 114, 59, 32768, 8662, 114, 512, 104, 114, 13517, 13521, 107, 59, 32768, 10531, 512, 59, 111, 13526, 13528, 32768, 8598, 119, 59, 32768, 8598, 101, 97, 114, 59, 32768, 10535, 9252, 13576, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13579, 0, 13596, 13617, 13653, 13659, 13673, 13695, 13708, 0, 0, 13713, 13750, 0, 13788, 13794, 0, 13815, 13890, 13913, 13937, 13944, 59, 32768, 9416, 512, 99, 115, 13583, 13591, 117, 116, 101, 33024, 243, 59, 32768, 243, 116, 59, 32768, 8859, 512, 105, 121, 13600, 13613, 114, 512, 59, 99, 13606, 13608, 32768, 8858, 33024, 244, 59, 32768, 244, 59, 32768, 1086, 1280, 97, 98, 105, 111, 115, 13627, 13632, 13638, 13642, 13646, 115, 104, 59, 32768, 8861, 108, 97, 99, 59, 32768, 337, 118, 59, 32768, 10808, 116, 59, 32768, 8857, 111, 108, 100, 59, 32768, 10684, 108, 105, 103, 59, 32768, 339, 512, 99, 114, 13663, 13668, 105, 114, 59, 32768, 10687, 59, 32896, 55349, 56620, 1600, 13680, 0, 0, 13684, 0, 13692, 110, 59, 32768, 731, 97, 118, 101, 33024, 242, 59, 32768, 242, 59, 32768, 10689, 512, 98, 109, 13699, 13704, 97, 114, 59, 32768, 10677, 59, 32768, 937, 110, 116, 59, 32768, 8750, 1024, 97, 99, 105, 116, 13721, 13726, 13741, 13746, 114, 114, 59, 32768, 8634, 512, 105, 114, 13731, 13735, 114, 59, 32768, 10686, 111, 115, 115, 59, 32768, 10683, 110, 101, 59, 32768, 8254, 59, 32768, 10688, 768, 97, 101, 105, 13756, 13761, 13766, 99, 114, 59, 32768, 333, 103, 97, 59, 32768, 969, 768, 99, 100, 110, 13773, 13779, 13782, 114, 111, 110, 59, 32768, 959, 59, 32768, 10678, 117, 115, 59, 32768, 8854, 112, 102, 59, 32896, 55349, 56672, 768, 97, 101, 108, 13800, 13804, 13809, 114, 59, 32768, 10679, 114, 112, 59, 32768, 10681, 117, 115, 59, 32768, 8853, 1792, 59, 97, 100, 105, 111, 115, 118, 13829, 13831, 13836, 13869, 13875, 13879, 13886, 32768, 8744, 114, 114, 59, 32768, 8635, 1024, 59, 101, 102, 109, 13845, 13847, 13859, 13864, 32768, 10845, 114, 512, 59, 111, 13853, 13855, 32768, 8500, 102, 59, 32768, 8500, 33024, 170, 59, 32768, 170, 33024, 186, 59, 32768, 186, 103, 111, 102, 59, 32768, 8886, 114, 59, 32768, 10838, 108, 111, 112, 101, 59, 32768, 10839, 59, 32768, 10843, 768, 99, 108, 111, 13896, 13900, 13908, 114, 59, 32768, 8500, 97, 115, 104, 33024, 248, 59, 32768, 248, 108, 59, 32768, 8856, 105, 573, 13917, 13924, 100, 101, 33024, 245, 59, 32768, 245, 101, 115, 512, 59, 97, 13930, 13932, 32768, 8855, 115, 59, 32768, 10806, 109, 108, 33024, 246, 59, 32768, 246, 98, 97, 114, 59, 32768, 9021, 5426, 13972, 0, 14013, 0, 14017, 14053, 0, 14058, 14086, 0, 0, 14107, 14199, 0, 14202, 0, 0, 14229, 14425, 0, 14438, 114, 1024, 59, 97, 115, 116, 13981, 13983, 13997, 14009, 32768, 8741, 33280, 182, 59, 108, 13989, 13991, 32768, 182, 108, 101, 108, 59, 32768, 8741, 1082, 14003, 0, 0, 14007, 109, 59, 32768, 10995, 59, 32768, 11005, 59, 32768, 8706, 121, 59, 32768, 1087, 114, 1280, 99, 105, 109, 112, 116, 14028, 14033, 14038, 14043, 14046, 110, 116, 59, 32768, 37, 111, 100, 59, 32768, 46, 105, 108, 59, 32768, 8240, 59, 32768, 8869, 101, 110, 107, 59, 32768, 8241, 114, 59, 32896, 55349, 56621, 768, 105, 109, 111, 14064, 14074, 14080, 512, 59, 118, 14069, 14071, 32768, 966, 59, 32768, 981, 109, 97, 116, 59, 32768, 8499, 110, 101, 59, 32768, 9742, 768, 59, 116, 118, 14092, 14094, 14103, 32768, 960, 99, 104, 102, 111, 114, 107, 59, 32768, 8916, 59, 32768, 982, 512, 97, 117, 14111, 14132, 110, 512, 99, 107, 14117, 14128, 107, 512, 59, 104, 14123, 14125, 32768, 8463, 59, 32768, 8462, 118, 59, 32768, 8463, 115, 2304, 59, 97, 98, 99, 100, 101, 109, 115, 116, 14152, 14154, 14160, 14163, 14168, 14179, 14182, 14188, 14193, 32768, 43, 99, 105, 114, 59, 32768, 10787, 59, 32768, 8862, 105, 114, 59, 32768, 10786, 512, 111, 117, 14173, 14176, 59, 32768, 8724, 59, 32768, 10789, 59, 32768, 10866, 110, 33024, 177, 59, 32768, 177, 105, 109, 59, 32768, 10790, 119, 111, 59, 32768, 10791, 59, 32768, 177, 768, 105, 112, 117, 14208, 14216, 14221, 110, 116, 105, 110, 116, 59, 32768, 10773, 102, 59, 32896, 55349, 56673, 110, 100, 33024, 163, 59, 32768, 163, 2560, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117, 14249, 14251, 14254, 14258, 14263, 14336, 14348, 14367, 14413, 14418, 32768, 8826, 59, 32768, 10931, 112, 59, 32768, 10935, 117, 101, 59, 32768, 8828, 512, 59, 99, 14268, 14270, 32768, 10927, 1536, 59, 97, 99, 101, 110, 115, 14283, 14285, 14293, 14302, 14306, 14331, 32768, 8826, 112, 112, 114, 111, 120, 59, 32768, 10935, 117, 114, 108, 121, 101, 113, 59, 32768, 8828, 113, 59, 32768, 10927, 768, 97, 101, 115, 14313, 14321, 14326, 112, 112, 114, 111, 120, 59, 32768, 10937, 113, 113, 59, 32768, 10933, 105, 109, 59, 32768, 8936, 105, 109, 59, 32768, 8830, 109, 101, 512, 59, 115, 14343, 14345, 32768, 8242, 59, 32768, 8473, 768, 69, 97, 115, 14355, 14358, 14362, 59, 32768, 10933, 112, 59, 32768, 10937, 105, 109, 59, 32768, 8936, 768, 100, 102, 112, 14374, 14377, 14402, 59, 32768, 8719, 768, 97, 108, 115, 14384, 14390, 14396, 108, 97, 114, 59, 32768, 9006, 105, 110, 101, 59, 32768, 8978, 117, 114, 102, 59, 32768, 8979, 512, 59, 116, 14407, 14409, 32768, 8733, 111, 59, 32768, 8733, 105, 109, 59, 32768, 8830, 114, 101, 108, 59, 32768, 8880, 512, 99, 105, 14429, 14434, 114, 59, 32896, 55349, 56517, 59, 32768, 968, 110, 99, 115, 112, 59, 32768, 8200, 1536, 102, 105, 111, 112, 115, 117, 14457, 14462, 14467, 14473, 14480, 14486, 114, 59, 32896, 55349, 56622, 110, 116, 59, 32768, 10764, 112, 102, 59, 32896, 55349, 56674, 114, 105, 109, 101, 59, 32768, 8279, 99, 114, 59, 32896, 55349, 56518, 768, 97, 101, 111, 14493, 14513, 14526, 116, 512, 101, 105, 14499, 14508, 114, 110, 105, 111, 110, 115, 59, 32768, 8461, 110, 116, 59, 32768, 10774, 115, 116, 512, 59, 101, 14520, 14522, 32768, 63, 113, 59, 32768, 8799, 116, 33024, 34, 59, 32768, 34, 5376, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111, 112, 114, 115, 116, 117, 120, 14575, 14597, 14603, 14608, 14775, 14829, 14865, 14901, 14943, 14966, 15e3, 15139, 15159, 15176, 15182, 15236, 15261, 15267, 15309, 15352, 15360, 768, 97, 114, 116, 14582, 14587, 14591, 114, 114, 59, 32768, 8667, 114, 59, 32768, 8658, 97, 105, 108, 59, 32768, 10524, 97, 114, 114, 59, 32768, 10511, 97, 114, 59, 32768, 10596, 1792, 99, 100, 101, 110, 113, 114, 116, 14623, 14637, 14642, 14650, 14672, 14679, 14751, 512, 101, 117, 14628, 14632, 59, 32896, 8765, 817, 116, 101, 59, 32768, 341, 105, 99, 59, 32768, 8730, 109, 112, 116, 121, 118, 59, 32768, 10675, 103, 1024, 59, 100, 101, 108, 14660, 14662, 14665, 14668, 32768, 10217, 59, 32768, 10642, 59, 32768, 10661, 101, 59, 32768, 10217, 117, 111, 33024, 187, 59, 32768, 187, 114, 2816, 59, 97, 98, 99, 102, 104, 108, 112, 115, 116, 119, 14703, 14705, 14709, 14720, 14723, 14727, 14731, 14735, 14739, 14744, 14748, 32768, 8594, 112, 59, 32768, 10613, 512, 59, 102, 14714, 14716, 32768, 8677, 115, 59, 32768, 10528, 59, 32768, 10547, 115, 59, 32768, 10526, 107, 59, 32768, 8618, 112, 59, 32768, 8620, 108, 59, 32768, 10565, 105, 109, 59, 32768, 10612, 108, 59, 32768, 8611, 59, 32768, 8605, 512, 97, 105, 14756, 14761, 105, 108, 59, 32768, 10522, 111, 512, 59, 110, 14767, 14769, 32768, 8758, 97, 108, 115, 59, 32768, 8474, 768, 97, 98, 114, 14782, 14787, 14792, 114, 114, 59, 32768, 10509, 114, 107, 59, 32768, 10099, 512, 97, 107, 14797, 14809, 99, 512, 101, 107, 14803, 14806, 59, 32768, 125, 59, 32768, 93, 512, 101, 115, 14814, 14817, 59, 32768, 10636, 108, 512, 100, 117, 14823, 14826, 59, 32768, 10638, 59, 32768, 10640, 1024, 97, 101, 117, 121, 14838, 14844, 14858, 14862, 114, 111, 110, 59, 32768, 345, 512, 100, 105, 14849, 14854, 105, 108, 59, 32768, 343, 108, 59, 32768, 8969, 98, 59, 32768, 125, 59, 32768, 1088, 1024, 99, 108, 113, 115, 14874, 14878, 14885, 14897, 97, 59, 32768, 10551, 100, 104, 97, 114, 59, 32768, 10601, 117, 111, 512, 59, 114, 14892, 14894, 32768, 8221, 59, 32768, 8221, 104, 59, 32768, 8627, 768, 97, 99, 103, 14908, 14934, 14938, 108, 1024, 59, 105, 112, 115, 14918, 14920, 14925, 14931, 32768, 8476, 110, 101, 59, 32768, 8475, 97, 114, 116, 59, 32768, 8476, 59, 32768, 8477, 116, 59, 32768, 9645, 33024, 174, 59, 32768, 174, 768, 105, 108, 114, 14950, 14956, 14962, 115, 104, 116, 59, 32768, 10621, 111, 111, 114, 59, 32768, 8971, 59, 32896, 55349, 56623, 512, 97, 111, 14971, 14990, 114, 512, 100, 117, 14977, 14980, 59, 32768, 8641, 512, 59, 108, 14985, 14987, 32768, 8640, 59, 32768, 10604, 512, 59, 118, 14995, 14997, 32768, 961, 59, 32768, 1009, 768, 103, 110, 115, 15007, 15123, 15127, 104, 116, 1536, 97, 104, 108, 114, 115, 116, 15022, 15039, 15060, 15086, 15099, 15111, 114, 114, 111, 119, 512, 59, 116, 15031, 15033, 32768, 8594, 97, 105, 108, 59, 32768, 8611, 97, 114, 112, 111, 111, 110, 512, 100, 117, 15050, 15056, 111, 119, 110, 59, 32768, 8641, 112, 59, 32768, 8640, 101, 102, 116, 512, 97, 104, 15068, 15076, 114, 114, 111, 119, 115, 59, 32768, 8644, 97, 114, 112, 111, 111, 110, 115, 59, 32768, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 32768, 8649, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 32768, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 32768, 8908, 103, 59, 32768, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 32768, 8787, 768, 97, 104, 109, 15146, 15151, 15156, 114, 114, 59, 32768, 8644, 97, 114, 59, 32768, 8652, 59, 32768, 8207, 111, 117, 115, 116, 512, 59, 97, 15168, 15170, 32768, 9137, 99, 104, 101, 59, 32768, 9137, 109, 105, 100, 59, 32768, 10990, 1024, 97, 98, 112, 116, 15191, 15204, 15209, 15229, 512, 110, 114, 15196, 15200, 103, 59, 32768, 10221, 114, 59, 32768, 8702, 114, 107, 59, 32768, 10215, 768, 97, 102, 108, 15216, 15220, 15224, 114, 59, 32768, 10630, 59, 32896, 55349, 56675, 117, 115, 59, 32768, 10798, 105, 109, 101, 115, 59, 32768, 10805, 512, 97, 112, 15241, 15253, 114, 512, 59, 103, 15247, 15249, 32768, 41, 116, 59, 32768, 10644, 111, 108, 105, 110, 116, 59, 32768, 10770, 97, 114, 114, 59, 32768, 8649, 1024, 97, 99, 104, 113, 15276, 15282, 15287, 15290, 113, 117, 111, 59, 32768, 8250, 114, 59, 32896, 55349, 56519, 59, 32768, 8625, 512, 98, 117, 15295, 15298, 59, 32768, 93, 111, 512, 59, 114, 15304, 15306, 32768, 8217, 59, 32768, 8217, 768, 104, 105, 114, 15316, 15322, 15328, 114, 101, 101, 59, 32768, 8908, 109, 101, 115, 59, 32768, 8906, 105, 1024, 59, 101, 102, 108, 15338, 15340, 15343, 15346, 32768, 9657, 59, 32768, 8885, 59, 32768, 9656, 116, 114, 105, 59, 32768, 10702, 108, 117, 104, 97, 114, 59, 32768, 10600, 59, 32768, 8478, 6706, 15391, 15398, 15404, 15499, 15516, 15592, 0, 15606, 15660, 0, 0, 15752, 15758, 0, 15827, 15863, 15886, 16e3, 16006, 16038, 16086, 0, 16467, 0, 0, 16506, 99, 117, 116, 101, 59, 32768, 347, 113, 117, 111, 59, 32768, 8218, 2560, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 15424, 15426, 15429, 15441, 15446, 15458, 15463, 15482, 15490, 15495, 32768, 8827, 59, 32768, 10932, 833, 15434, 0, 15437, 59, 32768, 10936, 111, 110, 59, 32768, 353, 117, 101, 59, 32768, 8829, 512, 59, 100, 15451, 15453, 32768, 10928, 105, 108, 59, 32768, 351, 114, 99, 59, 32768, 349, 768, 69, 97, 115, 15470, 15473, 15477, 59, 32768, 10934, 112, 59, 32768, 10938, 105, 109, 59, 32768, 8937, 111, 108, 105, 110, 116, 59, 32768, 10771, 105, 109, 59, 32768, 8831, 59, 32768, 1089, 111, 116, 768, 59, 98, 101, 15507, 15509, 15512, 32768, 8901, 59, 32768, 8865, 59, 32768, 10854, 1792, 65, 97, 99, 109, 115, 116, 120, 15530, 15535, 15556, 15562, 15566, 15572, 15587, 114, 114, 59, 32768, 8664, 114, 512, 104, 114, 15541, 15545, 107, 59, 32768, 10533, 512, 59, 111, 15550, 15552, 32768, 8600, 119, 59, 32768, 8600, 116, 33024, 167, 59, 32768, 167, 105, 59, 32768, 59, 119, 97, 114, 59, 32768, 10537, 109, 512, 105, 110, 15578, 15584, 110, 117, 115, 59, 32768, 8726, 59, 32768, 8726, 116, 59, 32768, 10038, 114, 512, 59, 111, 15597, 15600, 32896, 55349, 56624, 119, 110, 59, 32768, 8994, 1024, 97, 99, 111, 121, 15614, 15619, 15632, 15654, 114, 112, 59, 32768, 9839, 512, 104, 121, 15624, 15629, 99, 121, 59, 32768, 1097, 59, 32768, 1096, 114, 116, 1086, 15640, 0, 0, 15645, 105, 100, 59, 32768, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 32768, 8741, 33024, 173, 59, 32768, 173, 512, 103, 109, 15664, 15681, 109, 97, 768, 59, 102, 118, 15673, 15675, 15678, 32768, 963, 59, 32768, 962, 59, 32768, 962, 2048, 59, 100, 101, 103, 108, 110, 112, 114, 15698, 15700, 15705, 15715, 15725, 15735, 15739, 15745, 32768, 8764, 111, 116, 59, 32768, 10858, 512, 59, 113, 15710, 15712, 32768, 8771, 59, 32768, 8771, 512, 59, 69, 15720, 15722, 32768, 10910, 59, 32768, 10912, 512, 59, 69, 15730, 15732, 32768, 10909, 59, 32768, 10911, 101, 59, 32768, 8774, 108, 117, 115, 59, 32768, 10788, 97, 114, 114, 59, 32768, 10610, 97, 114, 114, 59, 32768, 8592, 1024, 97, 101, 105, 116, 15766, 15788, 15796, 15808, 512, 108, 115, 15771, 15783, 108, 115, 101, 116, 109, 105, 110, 117, 115, 59, 32768, 8726, 104, 112, 59, 32768, 10803, 112, 97, 114, 115, 108, 59, 32768, 10724, 512, 100, 108, 15801, 15804, 59, 32768, 8739, 101, 59, 32768, 8995, 512, 59, 101, 15813, 15815, 32768, 10922, 512, 59, 115, 15820, 15822, 32768, 10924, 59, 32896, 10924, 65024, 768, 102, 108, 112, 15833, 15839, 15857, 116, 99, 121, 59, 32768, 1100, 512, 59, 98, 15844, 15846, 32768, 47, 512, 59, 97, 15851, 15853, 32768, 10692, 114, 59, 32768, 9023, 102, 59, 32896, 55349, 56676, 97, 512, 100, 114, 15868, 15882, 101, 115, 512, 59, 117, 15875, 15877, 32768, 9824, 105, 116, 59, 32768, 9824, 59, 32768, 8741, 768, 99, 115, 117, 15892, 15921, 15977, 512, 97, 117, 15897, 15909, 112, 512, 59, 115, 15903, 15905, 32768, 8851, 59, 32896, 8851, 65024, 112, 512, 59, 115, 15915, 15917, 32768, 8852, 59, 32896, 8852, 65024, 117, 512, 98, 112, 15927, 15952, 768, 59, 101, 115, 15934, 15936, 15939, 32768, 8847, 59, 32768, 8849, 101, 116, 512, 59, 101, 15946, 15948, 32768, 8847, 113, 59, 32768, 8849, 768, 59, 101, 115, 15959, 15961, 15964, 32768, 8848, 59, 32768, 8850, 101, 116, 512, 59, 101, 15971, 15973, 32768, 8848, 113, 59, 32768, 8850, 768, 59, 97, 102, 15984, 15986, 15996, 32768, 9633, 114, 566, 15991, 15994, 59, 32768, 9633, 59, 32768, 9642, 59, 32768, 9642, 97, 114, 114, 59, 32768, 8594, 1024, 99, 101, 109, 116, 16014, 16019, 16025, 16031, 114, 59, 32896, 55349, 56520, 116, 109, 110, 59, 32768, 8726, 105, 108, 101, 59, 32768, 8995, 97, 114, 102, 59, 32768, 8902, 512, 97, 114, 16042, 16053, 114, 512, 59, 102, 16048, 16050, 32768, 9734, 59, 32768, 9733, 512, 97, 110, 16058, 16081, 105, 103, 104, 116, 512, 101, 112, 16067, 16076, 112, 115, 105, 108, 111, 110, 59, 32768, 1013, 104, 105, 59, 32768, 981, 115, 59, 32768, 175, 1280, 98, 99, 109, 110, 112, 16096, 16221, 16288, 16291, 16295, 2304, 59, 69, 100, 101, 109, 110, 112, 114, 115, 16115, 16117, 16120, 16125, 16137, 16143, 16154, 16160, 16166, 32768, 8834, 59, 32768, 10949, 111, 116, 59, 32768, 10941, 512, 59, 100, 16130, 16132, 32768, 8838, 111, 116, 59, 32768, 10947, 117, 108, 116, 59, 32768, 10945, 512, 69, 101, 16148, 16151, 59, 32768, 10955, 59, 32768, 8842, 108, 117, 115, 59, 32768, 10943, 97, 114, 114, 59, 32768, 10617, 768, 101, 105, 117, 16173, 16206, 16210, 116, 768, 59, 101, 110, 16181, 16183, 16194, 32768, 8834, 113, 512, 59, 113, 16189, 16191, 32768, 8838, 59, 32768, 10949, 101, 113, 512, 59, 113, 16201, 16203, 32768, 8842, 59, 32768, 10955, 109, 59, 32768, 10951, 512, 98, 112, 16215, 16218, 59, 32768, 10965, 59, 32768, 10963, 99, 1536, 59, 97, 99, 101, 110, 115, 16235, 16237, 16245, 16254, 16258, 16283, 32768, 8827, 112, 112, 114, 111, 120, 59, 32768, 10936, 117, 114, 108, 121, 101, 113, 59, 32768, 8829, 113, 59, 32768, 10928, 768, 97, 101, 115, 16265, 16273, 16278, 112, 112, 114, 111, 120, 59, 32768, 10938, 113, 113, 59, 32768, 10934, 105, 109, 59, 32768, 8937, 105, 109, 59, 32768, 8831, 59, 32768, 8721, 103, 59, 32768, 9834, 3328, 49, 50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 16322, 16327, 16332, 16337, 16339, 16342, 16356, 16368, 16382, 16388, 16394, 16405, 16411, 33024, 185, 59, 32768, 185, 33024, 178, 59, 32768, 178, 33024, 179, 59, 32768, 179, 32768, 8835, 59, 32768, 10950, 512, 111, 115, 16347, 16351, 116, 59, 32768, 10942, 117, 98, 59, 32768, 10968, 512, 59, 100, 16361, 16363, 32768, 8839, 111, 116, 59, 32768, 10948, 115, 512, 111, 117, 16374, 16378, 108, 59, 32768, 10185, 98, 59, 32768, 10967, 97, 114, 114, 59, 32768, 10619, 117, 108, 116, 59, 32768, 10946, 512, 69, 101, 16399, 16402, 59, 32768, 10956, 59, 32768, 8843, 108, 117, 115, 59, 32768, 10944, 768, 101, 105, 117, 16418, 16451, 16455, 116, 768, 59, 101, 110, 16426, 16428, 16439, 32768, 8835, 113, 512, 59, 113, 16434, 16436, 32768, 8839, 59, 32768, 10950, 101, 113, 512, 59, 113, 16446, 16448, 32768, 8843, 59, 32768, 10956, 109, 59, 32768, 10952, 512, 98, 112, 16460, 16463, 59, 32768, 10964, 59, 32768, 10966, 768, 65, 97, 110, 16473, 16478, 16499, 114, 114, 59, 32768, 8665, 114, 512, 104, 114, 16484, 16488, 107, 59, 32768, 10534, 512, 59, 111, 16493, 16495, 32768, 8601, 119, 59, 32768, 8601, 119, 97, 114, 59, 32768, 10538, 108, 105, 103, 33024, 223, 59, 32768, 223, 5938, 16538, 16552, 16557, 16579, 16584, 16591, 0, 16596, 16692, 0, 0, 0, 0, 0, 16731, 16780, 0, 16787, 16908, 0, 0, 0, 16938, 1091, 16543, 0, 0, 16549, 103, 101, 116, 59, 32768, 8982, 59, 32768, 964, 114, 107, 59, 32768, 9140, 768, 97, 101, 121, 16563, 16569, 16575, 114, 111, 110, 59, 32768, 357, 100, 105, 108, 59, 32768, 355, 59, 32768, 1090, 111, 116, 59, 32768, 8411, 108, 114, 101, 99, 59, 32768, 8981, 114, 59, 32896, 55349, 56625, 1024, 101, 105, 107, 111, 16604, 16641, 16670, 16684, 835, 16609, 0, 16624, 101, 512, 52, 102, 16614, 16617, 59, 32768, 8756, 111, 114, 101, 59, 32768, 8756, 97, 768, 59, 115, 118, 16631, 16633, 16638, 32768, 952, 121, 109, 59, 32768, 977, 59, 32768, 977, 512, 99, 110, 16646, 16665, 107, 512, 97, 115, 16652, 16660, 112, 112, 114, 111, 120, 59, 32768, 8776, 105, 109, 59, 32768, 8764, 115, 112, 59, 32768, 8201, 512, 97, 115, 16675, 16679, 112, 59, 32768, 8776, 105, 109, 59, 32768, 8764, 114, 110, 33024, 254, 59, 32768, 254, 829, 16696, 16701, 16727, 100, 101, 59, 32768, 732, 101, 115, 33536, 215, 59, 98, 100, 16710, 16712, 16723, 32768, 215, 512, 59, 97, 16717, 16719, 32768, 8864, 114, 59, 32768, 10801, 59, 32768, 10800, 116, 59, 32768, 8749, 768, 101, 112, 115, 16737, 16741, 16775, 97, 59, 32768, 10536, 1024, 59, 98, 99, 102, 16750, 16752, 16757, 16762, 32768, 8868, 111, 116, 59, 32768, 9014, 105, 114, 59, 32768, 10993, 512, 59, 111, 16767, 16770, 32896, 55349, 56677, 114, 107, 59, 32768, 10970, 97, 59, 32768, 10537, 114, 105, 109, 101, 59, 32768, 8244, 768, 97, 105, 112, 16793, 16798, 16899, 100, 101, 59, 32768, 8482, 1792, 97, 100, 101, 109, 112, 115, 116, 16813, 16868, 16873, 16876, 16883, 16889, 16893, 110, 103, 108, 101, 1280, 59, 100, 108, 113, 114, 16828, 16830, 16836, 16850, 16853, 32768, 9653, 111, 119, 110, 59, 32768, 9663, 101, 102, 116, 512, 59, 101, 16844, 16846, 32768, 9667, 113, 59, 32768, 8884, 59, 32768, 8796, 105, 103, 104, 116, 512, 59, 101, 16862, 16864, 32768, 9657, 113, 59, 32768, 8885, 111, 116, 59, 32768, 9708, 59, 32768, 8796, 105, 110, 117, 115, 59, 32768, 10810, 108, 117, 115, 59, 32768, 10809, 98, 59, 32768, 10701, 105, 109, 101, 59, 32768, 10811, 101, 122, 105, 117, 109, 59, 32768, 9186, 768, 99, 104, 116, 16914, 16926, 16931, 512, 114, 121, 16919, 16923, 59, 32896, 55349, 56521, 59, 32768, 1094, 99, 121, 59, 32768, 1115, 114, 111, 107, 59, 32768, 359, 512, 105, 111, 16942, 16947, 120, 116, 59, 32768, 8812, 104, 101, 97, 100, 512, 108, 114, 16956, 16967, 101, 102, 116, 97, 114, 114, 111, 119, 59, 32768, 8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 32768, 8608, 4608, 65, 72, 97, 98, 99, 100, 102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 17016, 17021, 17026, 17043, 17057, 17072, 17095, 17110, 17119, 17139, 17172, 17187, 17202, 17290, 17330, 17336, 17365, 17381, 114, 114, 59, 32768, 8657, 97, 114, 59, 32768, 10595, 512, 99, 114, 17031, 17039, 117, 116, 101, 33024, 250, 59, 32768, 250, 114, 59, 32768, 8593, 114, 820, 17049, 0, 17053, 121, 59, 32768, 1118, 118, 101, 59, 32768, 365, 512, 105, 121, 17062, 17069, 114, 99, 33024, 251, 59, 32768, 251, 59, 32768, 1091, 768, 97, 98, 104, 17079, 17084, 17090, 114, 114, 59, 32768, 8645, 108, 97, 99, 59, 32768, 369, 97, 114, 59, 32768, 10606, 512, 105, 114, 17100, 17106, 115, 104, 116, 59, 32768, 10622, 59, 32896, 55349, 56626, 114, 97, 118, 101, 33024, 249, 59, 32768, 249, 562, 17123, 17135, 114, 512, 108, 114, 17128, 17131, 59, 32768, 8639, 59, 32768, 8638, 108, 107, 59, 32768, 9600, 512, 99, 116, 17144, 17167, 1088, 17150, 0, 0, 17163, 114, 110, 512, 59, 101, 17156, 17158, 32768, 8988, 114, 59, 32768, 8988, 111, 112, 59, 32768, 8975, 114, 105, 59, 32768, 9720, 512, 97, 108, 17177, 17182, 99, 114, 59, 32768, 363, 33024, 168, 59, 32768, 168, 512, 103, 112, 17192, 17197, 111, 110, 59, 32768, 371, 102, 59, 32896, 55349, 56678, 1536, 97, 100, 104, 108, 115, 117, 17215, 17222, 17233, 17257, 17262, 17280, 114, 114, 111, 119, 59, 32768, 8593, 111, 119, 110, 97, 114, 114, 111, 119, 59, 32768, 8597, 97, 114, 112, 111, 111, 110, 512, 108, 114, 17244, 17250, 101, 102, 116, 59, 32768, 8639, 105, 103, 104, 116, 59, 32768, 8638, 117, 115, 59, 32768, 8846, 105, 768, 59, 104, 108, 17270, 17272, 17275, 32768, 965, 59, 32768, 978, 111, 110, 59, 32768, 965, 112, 97, 114, 114, 111, 119, 115, 59, 32768, 8648, 768, 99, 105, 116, 17297, 17320, 17325, 1088, 17303, 0, 0, 17316, 114, 110, 512, 59, 101, 17309, 17311, 32768, 8989, 114, 59, 32768, 8989, 111, 112, 59, 32768, 8974, 110, 103, 59, 32768, 367, 114, 105, 59, 32768, 9721, 99, 114, 59, 32896, 55349, 56522, 768, 100, 105, 114, 17343, 17348, 17354, 111, 116, 59, 32768, 8944, 108, 100, 101, 59, 32768, 361, 105, 512, 59, 102, 17360, 17362, 32768, 9653, 59, 32768, 9652, 512, 97, 109, 17370, 17375, 114, 114, 59, 32768, 8648, 108, 33024, 252, 59, 32768, 252, 97, 110, 103, 108, 101, 59, 32768, 10663, 3840, 65, 66, 68, 97, 99, 100, 101, 102, 108, 110, 111, 112, 114, 115, 122, 17420, 17425, 17437, 17443, 17613, 17617, 17623, 17667, 17672, 17678, 17693, 17699, 17705, 17711, 17754, 114, 114, 59, 32768, 8661, 97, 114, 512, 59, 118, 17432, 17434, 32768, 10984, 59, 32768, 10985, 97, 115, 104, 59, 32768, 8872, 512, 110, 114, 17448, 17454, 103, 114, 116, 59, 32768, 10652, 1792, 101, 107, 110, 112, 114, 115, 116, 17469, 17478, 17485, 17494, 17515, 17526, 17578, 112, 115, 105, 108, 111, 110, 59, 32768, 1013, 97, 112, 112, 97, 59, 32768, 1008, 111, 116, 104, 105, 110, 103, 59, 32768, 8709, 768, 104, 105, 114, 17501, 17505, 17508, 105, 59, 32768, 981, 59, 32768, 982, 111, 112, 116, 111, 59, 32768, 8733, 512, 59, 104, 17520, 17522, 32768, 8597, 111, 59, 32768, 1009, 512, 105, 117, 17531, 17537, 103, 109, 97, 59, 32768, 962, 512, 98, 112, 17542, 17560, 115, 101, 116, 110, 101, 113, 512, 59, 113, 17553, 17556, 32896, 8842, 65024, 59, 32896, 10955, 65024, 115, 101, 116, 110, 101, 113, 512, 59, 113, 17571, 17574, 32896, 8843, 65024, 59, 32896, 10956, 65024, 512, 104, 114, 17583, 17589, 101, 116, 97, 59, 32768, 977, 105, 97, 110, 103, 108, 101, 512, 108, 114, 17600, 17606, 101, 102, 116, 59, 32768, 8882, 105, 103, 104, 116, 59, 32768, 8883, 121, 59, 32768, 1074, 97, 115, 104, 59, 32768, 8866, 768, 101, 108, 114, 17630, 17648, 17654, 768, 59, 98, 101, 17637, 17639, 17644, 32768, 8744, 97, 114, 59, 32768, 8891, 113, 59, 32768, 8794, 108, 105, 112, 59, 32768, 8942, 512, 98, 116, 17659, 17664, 97, 114, 59, 32768, 124, 59, 32768, 124, 114, 59, 32896, 55349, 56627, 116, 114, 105, 59, 32768, 8882, 115, 117, 512, 98, 112, 17685, 17689, 59, 32896, 8834, 8402, 59, 32896, 8835, 8402, 112, 102, 59, 32896, 55349, 56679, 114, 111, 112, 59, 32768, 8733, 116, 114, 105, 59, 32768, 8883, 512, 99, 117, 17716, 17721, 114, 59, 32896, 55349, 56523, 512, 98, 112, 17726, 17740, 110, 512, 69, 101, 17732, 17736, 59, 32896, 10955, 65024, 59, 32896, 8842, 65024, 110, 512, 69, 101, 17746, 17750, 59, 32896, 10956, 65024, 59, 32896, 8843, 65024, 105, 103, 122, 97, 103, 59, 32768, 10650, 1792, 99, 101, 102, 111, 112, 114, 115, 17777, 17783, 17815, 17820, 17826, 17829, 17842, 105, 114, 99, 59, 32768, 373, 512, 100, 105, 17788, 17809, 512, 98, 103, 17793, 17798, 97, 114, 59, 32768, 10847, 101, 512, 59, 113, 17804, 17806, 32768, 8743, 59, 32768, 8793, 101, 114, 112, 59, 32768, 8472, 114, 59, 32896, 55349, 56628, 112, 102, 59, 32896, 55349, 56680, 59, 32768, 8472, 512, 59, 101, 17834, 17836, 32768, 8768, 97, 116, 104, 59, 32768, 8768, 99, 114, 59, 32896, 55349, 56524, 5428, 17871, 17891, 0, 17897, 0, 17902, 17917, 0, 0, 17920, 17935, 17940, 17945, 0, 0, 17977, 17992, 0, 18008, 18024, 18029, 768, 97, 105, 117, 17877, 17881, 17886, 112, 59, 32768, 8898, 114, 99, 59, 32768, 9711, 112, 59, 32768, 8899, 116, 114, 105, 59, 32768, 9661, 114, 59, 32896, 55349, 56629, 512, 65, 97, 17906, 17911, 114, 114, 59, 32768, 10234, 114, 114, 59, 32768, 10231, 59, 32768, 958, 512, 65, 97, 17924, 17929, 114, 114, 59, 32768, 10232, 114, 114, 59, 32768, 10229, 97, 112, 59, 32768, 10236, 105, 115, 59, 32768, 8955, 768, 100, 112, 116, 17951, 17956, 17970, 111, 116, 59, 32768, 10752, 512, 102, 108, 17961, 17965, 59, 32896, 55349, 56681, 117, 115, 59, 32768, 10753, 105, 109, 101, 59, 32768, 10754, 512, 65, 97, 17981, 17986, 114, 114, 59, 32768, 10233, 114, 114, 59, 32768, 10230, 512, 99, 113, 17996, 18001, 114, 59, 32896, 55349, 56525, 99, 117, 112, 59, 32768, 10758, 512, 112, 116, 18012, 18018, 108, 117, 115, 59, 32768, 10756, 114, 105, 59, 32768, 9651, 101, 101, 59, 32768, 8897, 101, 100, 103, 101, 59, 32768, 8896, 2048, 97, 99, 101, 102, 105, 111, 115, 117, 18052, 18068, 18081, 18087, 18092, 18097, 18103, 18109, 99, 512, 117, 121, 18058, 18065, 116, 101, 33024, 253, 59, 32768, 253, 59, 32768, 1103, 512, 105, 121, 18073, 18078, 114, 99, 59, 32768, 375, 59, 32768, 1099, 110, 33024, 165, 59, 32768, 165, 114, 59, 32896, 55349, 56630, 99, 121, 59, 32768, 1111, 112, 102, 59, 32896, 55349, 56682, 99, 114, 59, 32896, 55349, 56526, 512, 99, 109, 18114, 18118, 121, 59, 32768, 1102, 108, 33024, 255, 59, 32768, 255, 2560, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 18145, 18152, 18166, 18171, 18186, 18191, 18196, 18204, 18210, 18216, 99, 117, 116, 101, 59, 32768, 378, 512, 97, 121, 18157, 18163, 114, 111, 110, 59, 32768, 382, 59, 32768, 1079, 111, 116, 59, 32768, 380, 512, 101, 116, 18176, 18182, 116, 114, 102, 59, 32768, 8488, 97, 59, 32768, 950, 114, 59, 32896, 55349, 56631, 99, 121, 59, 32768, 1078, 103, 114, 97, 114, 114, 59, 32768, 8669, 112, 102, 59, 32896, 55349, 56683, 99, 114, 59, 32896, 55349, 56527, 512, 106, 110, 18221, 18224, 59, 32768, 8205, 106, 59, 32768, 8204]);
  }
});

// node_modules/htmlnorm/node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "node_modules/htmlnorm/node_modules/entities/lib/generated/decode-data-xml.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = new Uint16Array([1024, 97, 103, 108, 113, 9, 23, 27, 31, 1086, 15, 0, 0, 19, 112, 59, 32768, 38, 111, 115, 59, 32768, 39, 116, 59, 32768, 62, 116, 59, 32768, 60, 117, 111, 116, 59, 32768, 34]);
  }
});

// node_modules/htmlnorm/node_modules/entities/lib/decode.js
var require_decode2 = __commonJS({
  "node_modules/htmlnorm/node_modules/entities/lib/decode.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXML = exports.decodeHTMLStrict = exports.decodeHTML = exports.determineBranch = exports.JUMP_OFFSET_BASE = exports.BinTrieFlags = exports.xmlDecodeTree = exports.htmlDecodeTree = void 0;
    var decode_data_html_1 = __importDefault(require_decode_data_html());
    exports.htmlDecodeTree = decode_data_html_1.default;
    var decode_data_xml_1 = __importDefault(require_decode_data_xml());
    exports.xmlDecodeTree = decode_data_xml_1.default;
    var decode_codepoint_1 = __importDefault(require_decode_codepoint());
    var BinTrieFlags2;
    (function(BinTrieFlags3) {
      BinTrieFlags3[BinTrieFlags3["HAS_VALUE"] = 32768] = "HAS_VALUE";
      BinTrieFlags3[BinTrieFlags3["BRANCH_LENGTH"] = 32512] = "BRANCH_LENGTH";
      BinTrieFlags3[BinTrieFlags3["MULTI_BYTE"] = 128] = "MULTI_BYTE";
      BinTrieFlags3[BinTrieFlags3["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags2 = exports.BinTrieFlags || (exports.BinTrieFlags = {}));
    exports.JUMP_OFFSET_BASE = 48 - 1;
    function getDecoder2(decodeTree) {
      return function decodeHTMLBinary(str, strict) {
        var ret = "";
        var lastIdx = 0;
        var strIdx = 0;
        while ((strIdx = str.indexOf("&", strIdx)) >= 0) {
          ret += str.slice(lastIdx, strIdx);
          lastIdx = strIdx;
          strIdx += 1;
          if (str.charCodeAt(strIdx) === 35) {
            var start = strIdx + 1;
            var base = 10;
            var cp = str.charCodeAt(start);
            if ((cp | 32) === 120) {
              base = 16;
              strIdx += 1;
              start += 1;
            }
            while ((cp = str.charCodeAt(++strIdx)) >= 48 && cp <= 57 || base === 16 && (cp | 32) >= 97 && (cp | 32) <= 102)
              ;
            if (start !== strIdx) {
              var entity = str.substring(start, strIdx);
              var parsed = parseInt(entity, base);
              if (str.charCodeAt(strIdx) === 59) {
                strIdx += 1;
              } else if (strict) {
                continue;
              }
              ret += decode_codepoint_1.default(parsed);
              lastIdx = strIdx;
            }
            continue;
          }
          var result = null;
          var excess = 1;
          var treeIdx = 0;
          var current = decodeTree[treeIdx];
          for (; strIdx < str.length; strIdx++, excess++) {
            treeIdx = determineBranch2(decodeTree, current, treeIdx + 1, str.charCodeAt(strIdx));
            if (treeIdx < 0)
              break;
            current = decodeTree[treeIdx];
            if (current & BinTrieFlags2.HAS_VALUE) {
              if (strict && str.charCodeAt(strIdx) !== 59) {
                treeIdx += 1;
              } else {
                result = current & BinTrieFlags2.MULTI_BYTE ? String.fromCharCode(decodeTree[++treeIdx], decodeTree[++treeIdx]) : String.fromCharCode(decodeTree[++treeIdx]);
                excess = 0;
              }
            }
          }
          if (result != null) {
            ret += result;
            lastIdx = strIdx - excess + 1;
          }
        }
        return ret + str.slice(lastIdx);
      };
    }
    function determineBranch2(decodeTree, current, nodeIdx, char) {
      if (current <= 128) {
        return char === current ? nodeIdx : -1;
      }
      var branchCount = (current & BinTrieFlags2.BRANCH_LENGTH) >> 8;
      if (branchCount === 0) {
        return -1;
      }
      if (branchCount === 1) {
        return char === decodeTree[nodeIdx] ? nodeIdx + 1 : -1;
      }
      var jumpOffset = current & BinTrieFlags2.JUMP_TABLE;
      if (jumpOffset) {
        var value = char - exports.JUMP_OFFSET_BASE - jumpOffset;
        return value < 0 || value > branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports.determineBranch = determineBranch2;
    var htmlDecoder2 = getDecoder2(decode_data_html_1.default);
    var xmlDecoder2 = getDecoder2(decode_data_xml_1.default);
    function decodeHTML2(str) {
      return htmlDecoder2(str, false);
    }
    exports.decodeHTML = decodeHTML2;
    function decodeHTMLStrict(str) {
      return htmlDecoder2(str, true);
    }
    exports.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str) {
      return xmlDecoder2(str, true);
    }
    exports.decodeXML = decodeXML;
  }
});

// node_modules/htmlnorm/node_modules/htmlparser2/lib/Tokenizer.js
var require_Tokenizer = __commonJS({
  "node_modules/htmlnorm/node_modules/htmlparser2/lib/Tokenizer.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var decode_codepoint_1 = __importDefault(require_decode_codepoint());
    var decode_1 = require_decode2();
    function isWhitespace2(c) {
      return c === 32 || c === 10 || c === 9 || c === 12 || c === 13;
    }
    function isEndOfTagSection(c) {
      return c === 47 || c === 62 || isWhitespace2(c);
    }
    function isNumber2(c) {
      return c >= 48 && c <= 57;
    }
    function isASCIIAlpha(c) {
      return c >= 97 && c <= 122 || c >= 65 && c <= 90;
    }
    var Sequences = {
      Cdata: new Uint16Array([67, 68, 65, 84, 65, 91]),
      CdataEnd: new Uint16Array([93, 93, 62]),
      CommentEnd: new Uint16Array([45, 45, 62]),
      ScriptEnd: new Uint16Array([
        60,
        47,
        115,
        99,
        114,
        105,
        112,
        116
      ]),
      StyleEnd: new Uint16Array([60, 47, 115, 116, 121, 108, 101]),
      TitleEnd: new Uint16Array([60, 47, 116, 105, 116, 108, 101])
      // `</title`
    };
    var Tokenizer = (
      /** @class */
      function() {
        function Tokenizer2(_a3, cbs) {
          var _b = _a3.xmlMode, xmlMode = _b === void 0 ? false : _b, _c = _a3.decodeEntities, decodeEntities = _c === void 0 ? true : _c;
          this.cbs = cbs;
          this._state = 1;
          this.buffer = "";
          this.sectionStart = 0;
          this._index = 0;
          this.bufferOffset = 0;
          this.baseState = 1;
          this.isSpecial = false;
          this.running = true;
          this.ended = false;
          this.sequenceIndex = 0;
          this.trieIndex = 0;
          this.trieCurrent = 0;
          this.trieResult = null;
          this.entityExcess = 0;
          this.xmlMode = xmlMode;
          this.decodeEntities = decodeEntities;
          this.entityTrie = xmlMode ? decode_1.xmlDecodeTree : decode_1.htmlDecodeTree;
        }
        Tokenizer2.prototype.reset = function() {
          this._state = 1;
          this.buffer = "";
          this.sectionStart = 0;
          this._index = 0;
          this.bufferOffset = 0;
          this.baseState = 1;
          this.currentSequence = void 0;
          this.running = true;
          this.ended = false;
        };
        Tokenizer2.prototype.write = function(chunk) {
          if (this.ended)
            return this.cbs.onerror(Error(".write() after done!"));
          this.buffer += chunk;
          this.parse();
        };
        Tokenizer2.prototype.end = function(chunk) {
          if (this.ended)
            return this.cbs.onerror(Error(".end() after done!"));
          if (chunk)
            this.write(chunk);
          this.ended = true;
          if (this.running)
            this.finish();
        };
        Tokenizer2.prototype.pause = function() {
          this.running = false;
        };
        Tokenizer2.prototype.resume = function() {
          this.running = true;
          if (this._index < this.buffer.length) {
            this.parse();
          }
          if (this.ended) {
            this.finish();
          }
        };
        Tokenizer2.prototype.getAbsoluteSectionStart = function() {
          return this.sectionStart + this.bufferOffset;
        };
        Tokenizer2.prototype.getAbsoluteIndex = function() {
          return this.bufferOffset + this._index;
        };
        Tokenizer2.prototype.stateText = function(c) {
          if (c === 60 || !this.decodeEntities && this.fastForwardTo(
            60
            /* Lt */
          )) {
            if (this._index > this.sectionStart) {
              this.cbs.ontext(this.getSection());
            }
            this._state = 2;
            this.sectionStart = this._index;
          } else if (this.decodeEntities && c === 38) {
            this._state = 25;
          }
        };
        Tokenizer2.prototype.stateSpecialStartSequence = function(c) {
          var isEnd = this.sequenceIndex === this.currentSequence.length;
          var isMatch = isEnd ? (
            // If we are at the end of the sequence, make sure the tag name has ended
            isEndOfTagSection(c)
          ) : (
            // Otherwise, do a case-insensitive comparison
            (c | 32) === this.currentSequence[this.sequenceIndex]
          );
          if (!isMatch) {
            this.isSpecial = false;
          } else if (!isEnd) {
            this.sequenceIndex++;
            return;
          }
          this.sequenceIndex = 0;
          this._state = 3;
          this.stateInTagName(c);
        };
        Tokenizer2.prototype.stateInSpecialTag = function(c) {
          if (this.sequenceIndex === this.currentSequence.length) {
            if (c === 62 || isWhitespace2(c)) {
              var endOfText = this._index - this.currentSequence.length;
              if (this.sectionStart < endOfText) {
                var actualIndex = this._index;
                this._index = endOfText;
                this.cbs.ontext(this.getSection());
                this._index = actualIndex;
              }
              this.isSpecial = false;
              this.sectionStart = endOfText + 2;
              this.stateInClosingTagName(c);
              return;
            }
            this.sequenceIndex = 0;
          }
          if ((c | 32) === this.currentSequence[this.sequenceIndex]) {
            this.sequenceIndex += 1;
          } else if (this.sequenceIndex === 0) {
            if (this.currentSequence === Sequences.TitleEnd) {
              if (this.decodeEntities && c === 38) {
                this._state = 25;
              }
            } else if (this.fastForwardTo(
              60
              /* Lt */
            )) {
              this.sequenceIndex = 1;
            }
          } else {
            this.sequenceIndex = Number(
              c === 60
              /* Lt */
            );
          }
        };
        Tokenizer2.prototype.stateCDATASequence = function(c) {
          if (c === Sequences.Cdata[this.sequenceIndex]) {
            if (++this.sequenceIndex === Sequences.Cdata.length) {
              this._state = 21;
              this.currentSequence = Sequences.CdataEnd;
              this.sequenceIndex = 0;
              this.sectionStart = this._index + 1;
            }
          } else {
            this.sequenceIndex = 0;
            this._state = 16;
            this.stateInDeclaration(c);
          }
        };
        Tokenizer2.prototype.fastForwardTo = function(c) {
          while (++this._index < this.buffer.length) {
            if (this.buffer.charCodeAt(this._index) === c) {
              return true;
            }
          }
          this._index = this.buffer.length - 1;
          return false;
        };
        Tokenizer2.prototype.stateInCommentLike = function(c) {
          if (c === this.currentSequence[this.sequenceIndex]) {
            if (++this.sequenceIndex === this.currentSequence.length) {
              var section = this.buffer.slice(this.sectionStart, this._index - 2);
              if (this.currentSequence === Sequences.CdataEnd) {
                this.cbs.oncdata(section);
              } else {
                this.cbs.oncomment(section);
              }
              this.sequenceIndex = 0;
              this.sectionStart = this._index + 1;
              this._state = 1;
            }
          } else if (this.sequenceIndex === 0) {
            if (this.fastForwardTo(this.currentSequence[0])) {
              this.sequenceIndex = 1;
            }
          } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {
            this.sequenceIndex = 0;
          }
        };
        Tokenizer2.prototype.isTagStartChar = function(c) {
          return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);
        };
        Tokenizer2.prototype.startSpecial = function(sequence, offset) {
          this.isSpecial = true;
          this.currentSequence = sequence;
          this.sequenceIndex = offset;
          this._state = 23;
        };
        Tokenizer2.prototype.stateBeforeTagName = function(c) {
          if (c === 33) {
            this._state = 15;
            this.sectionStart = this._index + 1;
          } else if (c === 63) {
            this._state = 17;
            this.sectionStart = this._index + 1;
          } else if (this.isTagStartChar(c)) {
            var lower = c | 32;
            this.sectionStart = this._index;
            if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {
              this.startSpecial(Sequences.TitleEnd, 3);
            } else {
              this._state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? 22 : 3;
            }
          } else if (c === 47) {
            this._state = 5;
          } else {
            this._state = 1;
            this.stateText(c);
          }
        };
        Tokenizer2.prototype.stateInTagName = function(c) {
          if (isEndOfTagSection(c)) {
            this.cbs.onopentagname(this.getSection());
            this.sectionStart = -1;
            this._state = 8;
            this.stateBeforeAttributeName(c);
          }
        };
        Tokenizer2.prototype.stateBeforeClosingTagName = function(c) {
          if (isWhitespace2(c)) {
          } else if (c === 62) {
            this._state = 1;
          } else {
            this._state = this.isTagStartChar(c) ? 6 : 20;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateInClosingTagName = function(c) {
          if (c === 62 || isWhitespace2(c)) {
            this.cbs.onclosetag(this.getSection());
            this.sectionStart = -1;
            this._state = 7;
            this.stateAfterClosingTagName(c);
          }
        };
        Tokenizer2.prototype.stateAfterClosingTagName = function(c) {
          if (c === 62 || this.fastForwardTo(
            62
            /* Gt */
          )) {
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeName = function(c) {
          if (c === 62) {
            this.cbs.onopentagend();
            if (this.isSpecial) {
              this._state = 24;
              this.sequenceIndex = 0;
            } else {
              this._state = 1;
            }
            this.baseState = this._state;
            this.sectionStart = this._index + 1;
          } else if (c === 47) {
            this._state = 4;
          } else if (!isWhitespace2(c)) {
            this._state = 9;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateInSelfClosingTag = function(c) {
          if (c === 62) {
            this.cbs.onselfclosingtag();
            this._state = 1;
            this.baseState = 1;
            this.sectionStart = this._index + 1;
            this.isSpecial = false;
          } else if (!isWhitespace2(c)) {
            this._state = 8;
            this.stateBeforeAttributeName(c);
          }
        };
        Tokenizer2.prototype.stateInAttributeName = function(c) {
          if (c === 61 || isEndOfTagSection(c)) {
            this.cbs.onattribname(this.getSection());
            this.sectionStart = -1;
            this._state = 10;
            this.stateAfterAttributeName(c);
          }
        };
        Tokenizer2.prototype.stateAfterAttributeName = function(c) {
          if (c === 61) {
            this._state = 11;
          } else if (c === 47 || c === 62) {
            this.cbs.onattribend(void 0);
            this._state = 8;
            this.stateBeforeAttributeName(c);
          } else if (!isWhitespace2(c)) {
            this.cbs.onattribend(void 0);
            this._state = 9;
            this.sectionStart = this._index;
          }
        };
        Tokenizer2.prototype.stateBeforeAttributeValue = function(c) {
          if (c === 34) {
            this._state = 12;
            this.sectionStart = this._index + 1;
          } else if (c === 39) {
            this._state = 13;
            this.sectionStart = this._index + 1;
          } else if (!isWhitespace2(c)) {
            this.sectionStart = this._index;
            this._state = 14;
            this.stateInAttributeValueNoQuotes(c);
          }
        };
        Tokenizer2.prototype.handleInAttributeValue = function(c, quote) {
          if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {
            this.cbs.onattribdata(this.getSection());
            this.sectionStart = -1;
            this.cbs.onattribend(String.fromCharCode(quote));
            this._state = 8;
          } else if (this.decodeEntities && c === 38) {
            this.baseState = this._state;
            this._state = 25;
          }
        };
        Tokenizer2.prototype.stateInAttributeValueDoubleQuotes = function(c) {
          this.handleInAttributeValue(
            c,
            34
            /* DoubleQuote */
          );
        };
        Tokenizer2.prototype.stateInAttributeValueSingleQuotes = function(c) {
          this.handleInAttributeValue(
            c,
            39
            /* SingleQuote */
          );
        };
        Tokenizer2.prototype.stateInAttributeValueNoQuotes = function(c) {
          if (isWhitespace2(c) || c === 62) {
            this.cbs.onattribdata(this.getSection());
            this.sectionStart = -1;
            this.cbs.onattribend(null);
            this._state = 8;
            this.stateBeforeAttributeName(c);
          } else if (this.decodeEntities && c === 38) {
            this.baseState = this._state;
            this._state = 25;
          }
        };
        Tokenizer2.prototype.stateBeforeDeclaration = function(c) {
          if (c === 91) {
            this._state = 19;
            this.sequenceIndex = 0;
          } else {
            this._state = c === 45 ? 18 : 16;
          }
        };
        Tokenizer2.prototype.stateInDeclaration = function(c) {
          if (c === 62 || this.fastForwardTo(
            62
            /* Gt */
          )) {
            this.cbs.ondeclaration(this.getSection());
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateInProcessingInstruction = function(c) {
          if (c === 62 || this.fastForwardTo(
            62
            /* Gt */
          )) {
            this.cbs.onprocessinginstruction(this.getSection());
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeComment = function(c) {
          if (c === 45) {
            this._state = 21;
            this.currentSequence = Sequences.CommentEnd;
            this.sequenceIndex = 2;
            this.sectionStart = this._index + 1;
          } else {
            this._state = 16;
          }
        };
        Tokenizer2.prototype.stateInSpecialComment = function(c) {
          if (c === 62 || this.fastForwardTo(
            62
            /* Gt */
          )) {
            this.cbs.oncomment(this.getSection());
            this._state = 1;
            this.sectionStart = this._index + 1;
          }
        };
        Tokenizer2.prototype.stateBeforeSpecialS = function(c) {
          var lower = c | 32;
          if (lower === Sequences.ScriptEnd[3]) {
            this.startSpecial(Sequences.ScriptEnd, 4);
          } else if (lower === Sequences.StyleEnd[3]) {
            this.startSpecial(Sequences.StyleEnd, 4);
          } else {
            this._state = 3;
            this.stateInTagName(c);
          }
        };
        Tokenizer2.prototype.stateBeforeEntity = function(c) {
          this.entityExcess = 1;
          if (c === 35) {
            this._state = 26;
          } else if (c === 38) {
          } else {
            this.trieIndex = 0;
            this.trieCurrent = this.entityTrie[0];
            this.trieResult = null;
            this._state = 27;
            this.stateInNamedEntity(c);
          }
        };
        Tokenizer2.prototype.stateInNamedEntity = function(c) {
          this.entityExcess += 1;
          this.trieIndex = (0, decode_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);
          if (this.trieIndex < 0) {
            this.emitNamedEntity();
            this._index--;
            return;
          }
          this.trieCurrent = this.entityTrie[this.trieIndex];
          if (this.trieCurrent & decode_1.BinTrieFlags.HAS_VALUE) {
            if (!this.allowLegacyEntity() && c !== 59) {
              this.trieIndex += 1;
            } else {
              var entityStart = this._index - this.entityExcess + 1;
              if (entityStart > this.sectionStart) {
                this.emitPartial(this.buffer.substring(this.sectionStart, entityStart));
              }
              this.trieResult = this.trieCurrent & decode_1.BinTrieFlags.MULTI_BYTE ? String.fromCharCode(this.entityTrie[++this.trieIndex], this.entityTrie[++this.trieIndex]) : String.fromCharCode(this.entityTrie[++this.trieIndex]);
              this.entityExcess = 0;
              this.sectionStart = this._index + 1;
            }
          }
        };
        Tokenizer2.prototype.emitNamedEntity = function() {
          if (this.trieResult) {
            this.emitPartial(this.trieResult);
          }
          this._state = this.baseState;
        };
        Tokenizer2.prototype.stateBeforeNumericEntity = function(c) {
          if ((c | 32) === 120) {
            this.entityExcess++;
            this._state = 29;
          } else {
            this._state = 28;
            this.stateInNumericEntity(c);
          }
        };
        Tokenizer2.prototype.decodeNumericEntity = function(base, strict) {
          var entityStart = this._index - this.entityExcess - 1;
          var numberStart = entityStart + 2 + (base >> 4);
          if (numberStart !== this._index) {
            if (entityStart > this.sectionStart) {
              this.emitPartial(this.buffer.substring(this.sectionStart, entityStart));
            }
            var entity = this.buffer.substring(numberStart, this._index);
            var parsed = parseInt(entity, base);
            this.emitPartial((0, decode_codepoint_1.default)(parsed));
            this.sectionStart = this._index + Number(strict);
          }
          this._state = this.baseState;
        };
        Tokenizer2.prototype.stateInNumericEntity = function(c) {
          if (c === 59) {
            this.decodeNumericEntity(10, true);
          } else if (!isNumber2(c)) {
            if (this.allowLegacyEntity()) {
              this.decodeNumericEntity(10, false);
            } else {
              this._state = this.baseState;
            }
            this._index--;
          } else {
            this.entityExcess++;
          }
        };
        Tokenizer2.prototype.stateInHexEntity = function(c) {
          if (c === 59) {
            this.decodeNumericEntity(16, true);
          } else if ((c < 97 || c > 102) && (c < 65 || c > 70) && !isNumber2(c)) {
            if (this.allowLegacyEntity()) {
              this.decodeNumericEntity(16, false);
            } else {
              this._state = this.baseState;
            }
            this._index--;
          } else {
            this.entityExcess++;
          }
        };
        Tokenizer2.prototype.allowLegacyEntity = function() {
          return !this.xmlMode && (this.baseState === 1 || this.baseState === 24);
        };
        Tokenizer2.prototype.cleanup = function() {
          if (this.running && this.sectionStart !== this._index && (this._state === 1 || this._state === 24 && this.sequenceIndex === 0)) {
            this.cbs.ontext(this.buffer.substr(this.sectionStart));
            this.sectionStart = this._index;
          }
          var start = this.sectionStart < 0 ? this._index : this.sectionStart;
          this.buffer = start === this.buffer.length ? "" : this.buffer.substr(start);
          this._index -= start;
          this.bufferOffset += start;
          if (this.sectionStart > 0) {
            this.sectionStart = 0;
          }
        };
        Tokenizer2.prototype.shouldContinue = function() {
          return this._index < this.buffer.length && this.running;
        };
        Tokenizer2.prototype.parse = function() {
          while (this.shouldContinue()) {
            var c = this.buffer.charCodeAt(this._index);
            if (this._state === 1) {
              this.stateText(c);
            } else if (this._state === 23) {
              this.stateSpecialStartSequence(c);
            } else if (this._state === 24) {
              this.stateInSpecialTag(c);
            } else if (this._state === 19) {
              this.stateCDATASequence(c);
            } else if (this._state === 12) {
              this.stateInAttributeValueDoubleQuotes(c);
            } else if (this._state === 9) {
              this.stateInAttributeName(c);
            } else if (this._state === 21) {
              this.stateInCommentLike(c);
            } else if (this._state === 20) {
              this.stateInSpecialComment(c);
            } else if (this._state === 8) {
              this.stateBeforeAttributeName(c);
            } else if (this._state === 3) {
              this.stateInTagName(c);
            } else if (this._state === 6) {
              this.stateInClosingTagName(c);
            } else if (this._state === 2) {
              this.stateBeforeTagName(c);
            } else if (this._state === 10) {
              this.stateAfterAttributeName(c);
            } else if (this._state === 13) {
              this.stateInAttributeValueSingleQuotes(c);
            } else if (this._state === 11) {
              this.stateBeforeAttributeValue(c);
            } else if (this._state === 5) {
              this.stateBeforeClosingTagName(c);
            } else if (this._state === 7) {
              this.stateAfterClosingTagName(c);
            } else if (this._state === 22) {
              this.stateBeforeSpecialS(c);
            } else if (this._state === 14) {
              this.stateInAttributeValueNoQuotes(c);
            } else if (this._state === 4) {
              this.stateInSelfClosingTag(c);
            } else if (this._state === 16) {
              this.stateInDeclaration(c);
            } else if (this._state === 15) {
              this.stateBeforeDeclaration(c);
            } else if (this._state === 18) {
              this.stateBeforeComment(c);
            } else if (this._state === 17) {
              this.stateInProcessingInstruction(c);
            } else if (this._state === 27) {
              this.stateInNamedEntity(c);
            } else if (this._state === 25) {
              this.stateBeforeEntity(c);
            } else if (this._state === 29) {
              this.stateInHexEntity(c);
            } else if (this._state === 28) {
              this.stateInNumericEntity(c);
            } else {
              this.stateBeforeNumericEntity(c);
            }
            this._index++;
          }
          this.cleanup();
        };
        Tokenizer2.prototype.finish = function() {
          if (this._state === 27) {
            this.emitNamedEntity();
          }
          if (this.sectionStart < this._index) {
            this.handleTrailingData();
          }
          this.cbs.onend();
        };
        Tokenizer2.prototype.handleTrailingData = function() {
          var data = this.buffer.substr(this.sectionStart);
          if (this._state === 21) {
            if (this.currentSequence === Sequences.CdataEnd) {
              this.cbs.oncdata(data);
            } else {
              this.cbs.oncomment(data);
            }
          } else if (this._state === 28 && this.allowLegacyEntity()) {
            this.decodeNumericEntity(10, false);
          } else if (this._state === 29 && this.allowLegacyEntity()) {
            this.decodeNumericEntity(16, false);
          } else if (this._state === 3 || this._state === 8 || this._state === 11 || this._state === 10 || this._state === 9 || this._state === 13 || this._state === 12 || this._state === 14 || this._state === 6) {
          } else {
            this.cbs.ontext(data);
          }
        };
        Tokenizer2.prototype.getSection = function() {
          return this.buffer.substring(this.sectionStart, this._index);
        };
        Tokenizer2.prototype.emitPartial = function(value) {
          if (this.baseState !== 1 && this.baseState !== 24) {
            this.cbs.onattribdata(value);
          } else {
            this.cbs.ontext(value);
          }
        };
        return Tokenizer2;
      }()
    );
    exports.default = Tokenizer;
  }
});

// node_modules/htmlnorm/node_modules/htmlparser2/lib/Parser.js
var require_Parser = __commonJS({
  "node_modules/htmlnorm/node_modules/htmlparser2/lib/Parser.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = void 0;
    var Tokenizer_1 = __importDefault(require_Tokenizer());
    var formTags = /* @__PURE__ */ new Set([
      "input",
      "option",
      "optgroup",
      "select",
      "button",
      "datalist",
      "textarea"
    ]);
    var pTag = /* @__PURE__ */ new Set(["p"]);
    var tableSectionTags = /* @__PURE__ */ new Set(["thead", "tbody"]);
    var ddtTags = /* @__PURE__ */ new Set(["dd", "dt"]);
    var rtpTags = /* @__PURE__ */ new Set(["rt", "rp"]);
    var openImpliesClose = /* @__PURE__ */ new Map([
      ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
      ["th", /* @__PURE__ */ new Set(["th"])],
      ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
      ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
      ["li", /* @__PURE__ */ new Set(["li"])],
      ["p", pTag],
      ["h1", pTag],
      ["h2", pTag],
      ["h3", pTag],
      ["h4", pTag],
      ["h5", pTag],
      ["h6", pTag],
      ["select", formTags],
      ["input", formTags],
      ["output", formTags],
      ["button", formTags],
      ["datalist", formTags],
      ["textarea", formTags],
      ["option", /* @__PURE__ */ new Set(["option"])],
      ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
      ["dd", ddtTags],
      ["dt", ddtTags],
      ["address", pTag],
      ["article", pTag],
      ["aside", pTag],
      ["blockquote", pTag],
      ["details", pTag],
      ["div", pTag],
      ["dl", pTag],
      ["fieldset", pTag],
      ["figcaption", pTag],
      ["figure", pTag],
      ["footer", pTag],
      ["form", pTag],
      ["header", pTag],
      ["hr", pTag],
      ["main", pTag],
      ["nav", pTag],
      ["ol", pTag],
      ["pre", pTag],
      ["section", pTag],
      ["table", pTag],
      ["ul", pTag],
      ["rt", rtpTags],
      ["rp", rtpTags],
      ["tbody", tableSectionTags],
      ["tfoot", tableSectionTags]
    ]);
    var voidElements = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    var foreignContextElements = /* @__PURE__ */ new Set(["math", "svg"]);
    var htmlIntegrationElements = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignobject",
      "desc",
      "title"
    ]);
    var reNameEnd = /\s|\//;
    var Parser3 = (
      /** @class */
      function() {
        function Parser4(cbs, options) {
          if (options === void 0) {
            options = {};
          }
          var _a3, _b, _c, _d, _e;
          this.options = options;
          this.startIndex = 0;
          this.endIndex = 0;
          this.openTagStart = 0;
          this.tagname = "";
          this.attribname = "";
          this.attribvalue = "";
          this.attribs = null;
          this.stack = [];
          this.foreignContext = [];
          this.cbs = cbs !== null && cbs !== void 0 ? cbs : {};
          this.lowerCaseTagNames = (_a3 = options.lowerCaseTags) !== null && _a3 !== void 0 ? _a3 : !options.xmlMode;
          this.lowerCaseAttributeNames = (_b = options.lowerCaseAttributeNames) !== null && _b !== void 0 ? _b : !options.xmlMode;
          this.tokenizer = new ((_c = options.Tokenizer) !== null && _c !== void 0 ? _c : Tokenizer_1.default)(this.options, this);
          (_e = (_d = this.cbs).onparserinit) === null || _e === void 0 ? void 0 : _e.call(_d, this);
        }
        Parser4.prototype.ontext = function(data) {
          var _a3, _b;
          var idx = this.tokenizer.getAbsoluteIndex();
          this.endIndex = idx - 1;
          (_b = (_a3 = this.cbs).ontext) === null || _b === void 0 ? void 0 : _b.call(_a3, data);
          this.startIndex = idx;
        };
        Parser4.prototype.isVoidElement = function(name) {
          return !this.options.xmlMode && voidElements.has(name);
        };
        Parser4.prototype.onopentagname = function(name) {
          this.endIndex = this.tokenizer.getAbsoluteIndex();
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          this.emitOpenTag(name);
        };
        Parser4.prototype.emitOpenTag = function(name) {
          var _a3, _b, _c, _d;
          this.openTagStart = this.startIndex;
          this.tagname = name;
          var impliesClose = !this.options.xmlMode && openImpliesClose.get(name);
          if (impliesClose) {
            while (this.stack.length > 0 && impliesClose.has(this.stack[this.stack.length - 1])) {
              var el = this.stack.pop();
              (_b = (_a3 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a3, el, true);
            }
          }
          if (!this.isVoidElement(name)) {
            this.stack.push(name);
            if (foreignContextElements.has(name)) {
              this.foreignContext.push(true);
            } else if (htmlIntegrationElements.has(name)) {
              this.foreignContext.push(false);
            }
          }
          (_d = (_c = this.cbs).onopentagname) === null || _d === void 0 ? void 0 : _d.call(_c, name);
          if (this.cbs.onopentag)
            this.attribs = {};
        };
        Parser4.prototype.endOpenTag = function(isImplied) {
          var _a3, _b;
          this.startIndex = this.openTagStart;
          this.endIndex = this.tokenizer.getAbsoluteIndex();
          if (this.attribs) {
            (_b = (_a3 = this.cbs).onopentag) === null || _b === void 0 ? void 0 : _b.call(_a3, this.tagname, this.attribs, isImplied);
            this.attribs = null;
          }
          if (this.cbs.onclosetag && this.isVoidElement(this.tagname)) {
            this.cbs.onclosetag(this.tagname, true);
          }
          this.tagname = "";
        };
        Parser4.prototype.onopentagend = function() {
          this.endOpenTag(false);
          this.startIndex = this.endIndex + 1;
        };
        Parser4.prototype.onclosetag = function(name) {
          var _a3, _b, _c, _d, _e, _f;
          this.endIndex = this.tokenizer.getAbsoluteIndex();
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          if (foreignContextElements.has(name) || htmlIntegrationElements.has(name)) {
            this.foreignContext.pop();
          }
          if (!this.isVoidElement(name)) {
            var pos = this.stack.lastIndexOf(name);
            if (pos !== -1) {
              if (this.cbs.onclosetag) {
                var count = this.stack.length - pos;
                while (count--) {
                  this.cbs.onclosetag(this.stack.pop(), count !== 0);
                }
              } else
                this.stack.length = pos;
            } else if (!this.options.xmlMode && name === "p") {
              this.emitOpenTag(name);
              this.closeCurrentTag(true);
            }
          } else if (!this.options.xmlMode && name === "br") {
            (_b = (_a3 = this.cbs).onopentagname) === null || _b === void 0 ? void 0 : _b.call(_a3, name);
            (_d = (_c = this.cbs).onopentag) === null || _d === void 0 ? void 0 : _d.call(_c, name, {}, true);
            (_f = (_e = this.cbs).onclosetag) === null || _f === void 0 ? void 0 : _f.call(_e, name, false);
          }
          this.startIndex = this.endIndex + 1;
        };
        Parser4.prototype.onselfclosingtag = function() {
          if (this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1]) {
            this.closeCurrentTag(false);
            this.startIndex = this.endIndex + 1;
          } else {
            this.onopentagend();
          }
        };
        Parser4.prototype.closeCurrentTag = function(isOpenImplied) {
          var _a3, _b;
          var name = this.tagname;
          this.endOpenTag(isOpenImplied);
          if (this.stack[this.stack.length - 1] === name) {
            (_b = (_a3 = this.cbs).onclosetag) === null || _b === void 0 ? void 0 : _b.call(_a3, name, !isOpenImplied);
            this.stack.pop();
          }
        };
        Parser4.prototype.onattribname = function(name) {
          this.startIndex = this.tokenizer.getAbsoluteSectionStart();
          if (this.lowerCaseAttributeNames) {
            name = name.toLowerCase();
          }
          this.attribname = name;
        };
        Parser4.prototype.onattribdata = function(value) {
          this.attribvalue += value;
        };
        Parser4.prototype.onattribend = function(quote) {
          var _a3, _b;
          this.endIndex = this.tokenizer.getAbsoluteIndex();
          (_b = (_a3 = this.cbs).onattribute) === null || _b === void 0 ? void 0 : _b.call(_a3, this.attribname, this.attribvalue, quote);
          if (this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname)) {
            this.attribs[this.attribname] = this.attribvalue;
          }
          this.attribname = "";
          this.attribvalue = "";
        };
        Parser4.prototype.getInstructionName = function(value) {
          var idx = value.search(reNameEnd);
          var name = idx < 0 ? value : value.substr(0, idx);
          if (this.lowerCaseTagNames) {
            name = name.toLowerCase();
          }
          return name;
        };
        Parser4.prototype.ondeclaration = function(value) {
          this.endIndex = this.tokenizer.getAbsoluteIndex();
          if (this.cbs.onprocessinginstruction) {
            var name_1 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("!" + name_1, "!" + value);
          }
          this.startIndex = this.endIndex + 1;
        };
        Parser4.prototype.onprocessinginstruction = function(value) {
          this.endIndex = this.tokenizer.getAbsoluteIndex();
          if (this.cbs.onprocessinginstruction) {
            var name_2 = this.getInstructionName(value);
            this.cbs.onprocessinginstruction("?" + name_2, "?" + value);
          }
          this.startIndex = this.endIndex + 1;
        };
        Parser4.prototype.oncomment = function(value) {
          var _a3, _b, _c, _d;
          this.endIndex = this.tokenizer.getAbsoluteIndex();
          (_b = (_a3 = this.cbs).oncomment) === null || _b === void 0 ? void 0 : _b.call(_a3, value);
          (_d = (_c = this.cbs).oncommentend) === null || _d === void 0 ? void 0 : _d.call(_c);
          this.startIndex = this.endIndex + 1;
        };
        Parser4.prototype.oncdata = function(value) {
          var _a3, _b, _c, _d, _e, _f, _g, _h, _j, _k;
          this.endIndex = this.tokenizer.getAbsoluteIndex();
          if (this.options.xmlMode || this.options.recognizeCDATA) {
            (_b = (_a3 = this.cbs).oncdatastart) === null || _b === void 0 ? void 0 : _b.call(_a3);
            (_d = (_c = this.cbs).ontext) === null || _d === void 0 ? void 0 : _d.call(_c, value);
            (_f = (_e = this.cbs).oncdataend) === null || _f === void 0 ? void 0 : _f.call(_e);
          } else {
            (_h = (_g = this.cbs).oncomment) === null || _h === void 0 ? void 0 : _h.call(_g, "[CDATA[" + value + "]]");
            (_k = (_j = this.cbs).oncommentend) === null || _k === void 0 ? void 0 : _k.call(_j);
          }
          this.startIndex = this.endIndex + 1;
        };
        Parser4.prototype.onerror = function(err) {
          var _a3, _b;
          (_b = (_a3 = this.cbs).onerror) === null || _b === void 0 ? void 0 : _b.call(_a3, err);
        };
        Parser4.prototype.onend = function() {
          var _a3, _b;
          if (this.cbs.onclosetag) {
            this.endIndex = this.startIndex;
            for (var i = this.stack.length; i > 0; this.cbs.onclosetag(this.stack[--i], true))
              ;
          }
          (_b = (_a3 = this.cbs).onend) === null || _b === void 0 ? void 0 : _b.call(_a3);
        };
        Parser4.prototype.reset = function() {
          var _a3, _b, _c, _d;
          (_b = (_a3 = this.cbs).onreset) === null || _b === void 0 ? void 0 : _b.call(_a3);
          this.tokenizer.reset();
          this.tagname = "";
          this.attribname = "";
          this.attribs = null;
          this.stack = [];
          this.startIndex = 0;
          this.endIndex = 0;
          (_d = (_c = this.cbs).onparserinit) === null || _d === void 0 ? void 0 : _d.call(_c, this);
        };
        Parser4.prototype.parseComplete = function(data) {
          this.reset();
          this.end(data);
        };
        Parser4.prototype.write = function(chunk) {
          this.tokenizer.write(chunk);
        };
        Parser4.prototype.end = function(chunk) {
          this.tokenizer.end(chunk);
        };
        Parser4.prototype.pause = function() {
          this.tokenizer.pause();
        };
        Parser4.prototype.resume = function() {
          this.tokenizer.resume();
        };
        Parser4.prototype.parseChunk = function(chunk) {
          this.write(chunk);
        };
        Parser4.prototype.done = function(chunk) {
          this.end(chunk);
        };
        return Parser4;
      }()
    );
    exports.Parser = Parser3;
  }
});

// node_modules/inline-style-parser/index.js
var require_inline_style_parser = __commonJS({
  "node_modules/inline-style-parser/index.js"(exports, module) {
    var COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
    var NEWLINE_REGEX = /\n/g;
    var WHITESPACE_REGEX = /^\s*/;
    var PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
    var COLON_REGEX = /^:\s*/;
    var VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
    var SEMICOLON_REGEX = /^[;\s]*/;
    var TRIM_REGEX = /^\s+|\s+$/g;
    var NEWLINE = "\n";
    var FORWARD_SLASH = "/";
    var ASTERISK2 = "*";
    var EMPTY_STRING = "";
    var TYPE_COMMENT = "comment";
    var TYPE_DECLARATION = "declaration";
    module.exports = function(style, options) {
      if (typeof style !== "string") {
        throw new TypeError("First argument must be a string");
      }
      if (!style)
        return [];
      options = options || {};
      var lineno = 1;
      var column = 1;
      function updatePosition(str) {
        var lines = str.match(NEWLINE_REGEX);
        if (lines)
          lineno += lines.length;
        var i = str.lastIndexOf(NEWLINE);
        column = ~i ? str.length - i : column + str.length;
      }
      function position() {
        var start = { line: lineno, column };
        return function(node) {
          node.position = new Position(start);
          whitespace2();
          return node;
        };
      }
      function Position(start) {
        this.start = start;
        this.end = { line: lineno, column };
        this.source = options.source;
      }
      Position.prototype.content = style;
      var errorsList = [];
      function error(msg) {
        var err = new Error(
          options.source + ":" + lineno + ":" + column + ": " + msg
        );
        err.reason = msg;
        err.filename = options.source;
        err.line = lineno;
        err.column = column;
        err.source = style;
        if (options.silent) {
          errorsList.push(err);
        } else {
          throw err;
        }
      }
      function match(re) {
        var m = re.exec(style);
        if (!m)
          return;
        var str = m[0];
        updatePosition(str);
        style = style.slice(str.length);
        return m;
      }
      function whitespace2() {
        match(WHITESPACE_REGEX);
      }
      function comments(rules) {
        var c;
        rules = rules || [];
        while (c = comment()) {
          if (c !== false) {
            rules.push(c);
          }
        }
        return rules;
      }
      function comment() {
        var pos = position();
        if (FORWARD_SLASH != style.charAt(0) || ASTERISK2 != style.charAt(1))
          return;
        var i = 2;
        while (EMPTY_STRING != style.charAt(i) && (ASTERISK2 != style.charAt(i) || FORWARD_SLASH != style.charAt(i + 1))) {
          ++i;
        }
        i += 2;
        if (EMPTY_STRING === style.charAt(i - 1)) {
          return error("End of comment missing");
        }
        var str = style.slice(2, i - 2);
        column += 2;
        updatePosition(str);
        style = style.slice(i);
        column += 2;
        return pos({
          type: TYPE_COMMENT,
          comment: str
        });
      }
      function declaration() {
        var pos = position();
        var prop = match(PROPERTY_REGEX);
        if (!prop)
          return;
        comment();
        if (!match(COLON_REGEX))
          return error("property missing ':'");
        var val = match(VALUE_REGEX);
        var ret = pos({
          type: TYPE_DECLARATION,
          property: trim(prop[0].replace(COMMENT_REGEX, EMPTY_STRING)),
          value: val ? trim(val[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
        });
        match(SEMICOLON_REGEX);
        return ret;
      }
      function declarations() {
        var decls = [];
        comments(decls);
        var decl;
        while (decl = declaration()) {
          if (decl !== false) {
            decls.push(decl);
            comments(decls);
          }
        }
        return decls;
      }
      whitespace2();
      return declarations();
    };
    function trim(str) {
      return str ? str.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
    }
  }
});

// node_modules/style-to-object/index.js
var require_style_to_object = __commonJS({
  "node_modules/style-to-object/index.js"(exports, module) {
    var parse = require_inline_style_parser();
    function StyleToObject(style, iterator) {
      var output = null;
      if (!style || typeof style !== "string") {
        return output;
      }
      var declaration;
      var declarations = parse(style);
      var hasIterator = typeof iterator === "function";
      var property;
      var value;
      for (var i = 0, len = declarations.length; i < len; i++) {
        declaration = declarations[i];
        property = declaration.property;
        value = declaration.value;
        if (hasIterator) {
          iterator(property, value, declaration);
        } else if (value) {
          output || (output = {});
          output[property] = value;
        }
      }
      return output;
    }
    module.exports = StyleToObject;
  }
});

// ptss-parser/index.ts
var ptss_parser_exports = {};
__export(ptss_parser_exports, {
  Parser: () => Parser,
  Stylesheet: () => Stylesheet,
  loadSheet: () => loadSheet
});

// stir/index.ts
var stir_exports = {};
__export(stir_exports, {
  Block: () => Block,
  Inline: () => Inline2,
  assignUniqueID: () => assignUniqueID,
  blockTypes: () => blockTypes,
  fromJSON: () => fromJSON,
  idPath: () => idPath,
  inlineBodyText: () => inlineBodyText,
  inlineTypes: () => inlineTypes,
  isBlock: () => isBlock,
  isBlockSequence: () => isBlockSequence,
  isInline: () => isInline,
  isInlineSequence: () => isInlineSequence,
  stirType: () => stirType,
  toJSON: () => toJSON,
  traverseInlineBodyTree: () => traverseInlineBodyTree
});

// stir/block.ts
function stirType(v) {
  if (v === void 0) {
    return void 0;
  }
  if (typeof v === "string") {
    return "iSeq";
  }
  if (Array.isArray(v)) {
    const elem = v[0];
    if (elem === void 0) {
      return "unknown";
    }
    if (typeof elem === "string" || "_type" in elem) {
      return "iSeq";
    }
    if (Array.isArray(elem)) {
      return "bTable";
    }
    return "bSeq";
  }
  if (typeof v === "object") {
    if ("_type" in v) {
      return "inline";
    }
    if ("type" in v) {
      return "block";
    }
  }
  return "unknown";
}
function isBlock(v) {
  return stirType(v) === "block";
}
function isInline(v) {
  return stirType(v) === "inline";
}
function isBlockSequence(v) {
  return stirType(v) === "bSeq";
}
function isInlineSequence(v) {
  return stirType(v) === "iSeq";
}
var sectioningRoots = /* @__PURE__ */ new Set(["list_item", "list", "block_quote", "interjection", "table"]);
function idPath(node) {
  let path = "";
  while (node !== void 0) {
    if (node.isSectioningRoot()) {
      return { path, sectioningRoot: node };
    }
    if (node.id !== void 0) {
      path = path === "" ? node.id : node.id + "/" + path;
      break;
    }
    node = node.parent;
  }
  return { path, sectioningRoot: void 0 };
}
function assignUniqueID(node, seenIDs) {
  let id = node.id;
  if (id !== void 0) {
    return;
  }
  if (node.type === "heading") {
    id = inlineBodyText(node.body);
  } else if (node.type === "section") {
    id = inlineBodyText(node.title);
  } else {
    throw new Error("not yet implemented");
  }
  if (id in seenIDs) {
    let newID;
    for (let i = 2; i < Number.MAX_VALUE; i++) {
      newID = `${id} ${i}`;
      if (!(newID in seenIDs)) {
        id = newID;
        break;
      }
    }
  }
  node.id = id;
  seenIDs[id] = true;
}
var Block = class {
  //todo[api] Maybe should just add a dictionary for the element type specific properties?
  //todo[api] all properties that are NOT part of the representation of the structured text,
  // e.g. all properties that are meta, should be prefix, e.g. with "_" or "$" or something
  // that is compatible with JSON (and other formats ideally).
  //
  // This will:
  //  - makes it clear which properties are part of the representation and which are meta
  //  - makes it easy to filter out meta when outputting the STIR, e.g. bin/ptss-parser
  //    should output the canonical STIR for the content without all the crap!
  //    - there can be an option for including sourceMap info, but all the other crap
  //      should be nixed.
  // todo![model] not sure I like `type` + `subtype`. It limits the hierarchy to two levels.
  //   - 🌈🌶 Also I think if instead of `subType` we have `parentType` or `extendsType`, then
  //     we end up with the gracefully degrading extensible STIR that we are aiming for.
  //     For example:
  //       - Interjection: `type: Interjection;  extends: Block` //🌶 built-in, but even if it weren't, would get fallback render from Block
  //       - Warning: `type: Warning;  extends: Interjection`    //🌶 built-in, but even if it weren't, would get fallback render from Interjection
  //       - Info: `type: Info;  extends: Interjection`          //🌶 built-in, but even if it weren't, would get fallback render from Interjection
  //       - Danger: `type: Danger;  extends: Warning`  // 🌈🌶🌈🌶 NOT built-in, more severe than Warning, but gets fallback render from Warning.
  /* e.g. paragraph, heading, item, block_quote, strong, image... */
  type;
  subType;
  //todo![now] rename to 'subtype'
  id;
  /**
   * The Block that contains this Block, i.e. it's parent Block
   * in the content hierarchy.
   *
   * todo![now] adding `parent` and associated methods:
   *
   *   MIGHT SIMPLIFY MANY THINGS:
   *    0. WOAH: DOES ParseContainer GO AWAY or get drastically simplified?
   *    1. tight list renderer won't need to pass any flags in
   *       HTMLOut... we can just check the containing list props.
   *    2. TOC gen might not need all the complexity i have
   *       to track levels.
   *    3. does it simplify some parsing logic, e.g. around content
   *       models and the like?
   *    4. Look at all code where I create a STACK as I process nodes.
   *    5. ???
   *
   *  SHOULD HAVE NEGLIGIBLE COST:
   *    - the cardinality of block elements is small
   *    - as long as we don't need to do this for Inline elements
   *
   *  BUT WON'T HELP WHEN WE DO NEED IT FOR INLINE ELEMENTS
   *    - so far at least one case:
   *      - calculating the section path of NamedValue declarations,
   *        since we want to support named Inline elements as well.
   *        There is an easy/free alternative for this case: we
   *        pass the current section hierarchy from ParseContainer
   *        as a parameter to NamedValues.define(...).
   *
   * todo[spec, API] Block.parent or Block.container?
   *
   * @type {Block | undefined} only root block has no parent.
   */
  parent;
  get isRoot() {
    return this.parent === void 0;
  }
  /**
   * The main content.
   *
   *! `body` is special.
   *    - the ***body tree*** forms the main content tree
   *      - it is the tree defined by all the body edges (links from
   *        parent nodes to `body` children, to their `body` children, and
   *        so on)
   *      - the primary content of Containers is in `body`
   *      - table cell content is its `body`
   *      - there may be other branches sprouting off from the main body
   *        tree (e.g. a table `footer` with complex content), but even within
   *        these "spurs" the body tree is primary.
   *
   *    - recurseBodyTree walks the block/inline tree defined by body.
   *
   *      It is used, for example, to:
   *      - recursively search for elements needing targeting IDs.
   *      - recursively search for InlineSequence fields needing parsing.
   *
   *      No other part of a content tree is recursed this way automatically.
   *      SEE notes under recurseBodyTree for how to expand the traversal
   *      to other parts of of a block's content tree.
   *
   *    - if a Container style declaration doesn't specify what to do with
   *      the container body, it is automatically mapped to the STIR element's
   *      body. This is not just a convenience; it's an intuitive assumption
   *      and it allows for terser definitions.
   *
   * todo[docs, RepoDoc] The above belongs in the user guide. But it is also
   *   useful here. "RepoDoc solves this and keeps your documentation DRY
   *   by allowing you to put it in one place and link to it from all others.
   *   If you decide, for example, that the project should be end-user
   *   documentation-driven, you can put more specification and explanation
   *   in the end-user docs and link to it from the parts of the code that
   *   implement it or must conform to it."
   */
  body;
  title;
  // for heading type
  level;
  // for table type
  head;
  tableMeta;
  // for list type
  listOrdered;
  listStartNum;
  // defaults to one
  /**
   * todo[spec] TEMP HACK. Need abstract info. This isn't arbitrary presentation,
   *   as certain types of documents (e.g. legal) expect certain kinds of numbering.
   *   THOUGH arguably that could be implemented/enforced in the renderer, rather than
   *   in the STIR? But the downside of that is said info will be lost if we ever support
   *   storage of the STIR, or if the user wants to use a third party renderer. But putting
   *   it in the STIR spec, we force all renderers to support all the numbering systems, or
   *   at least the default set.
   *   - we might use [HTML's list-style-type](https://www.w3.org/TR/CSS2/generate.html#propdef-list-style-type)
   *   - or we might see what DocBook, LaText or PDF does.
   *   - BUT i want to be able to do things like Chinese numbers.
   *   - perhaps even allow a style sheet to create an arbitrary sequence by providing a list of characters,
   *     long enough for the longest list it supports (more lists are short anyway).
   */
  listStyle;
  // for code block type
  info;
  // Hints are info that renderers are not required to support.
  /// See STIR spec.
  _hints;
  /**
   * This member is a private "hook" for parsers to store for each IR node
   * information about the corresponding source plain text. This is NOT part
   * of the Structured Text Intermediate Representation spec, and thus is
   * private to any particular parser implementation, not to be relied on by
   * any third-party downstream tool.
   *
   * For example, the reference PTSS parser implementation stores:
   *
   * 1. details about the corresponding plain text source used during the
   *    parse process, including a function that is called to check if the
   *    block continues on the next line.
   *
   * 2. the location of the corresponding plain text block within the source,
   *    which is then used to annotate the corresponding nodes in the rendered
   *    HTML.
   *
   * 3. Other information useful for debugging.
   *
   * todo[perf] in memory efficient mode should we could clear this field after
   *    the ParsedIrElement is fully parsed?
   *
   * todo[api] despite what I wrote above, if this can adhere to the sourceMap
   *    spec, then at least those parts represented here are NOT private, and
   *    could be an *optional* feature of a STIR fully defined by the spec.
   */
  source;
  constructor(type) {
    this.type = type;
  }
  get hints() {
    if (this._hints === void 0) {
      this._hints = {};
    }
    return this._hints;
  }
  appendToBody(content) {
    if (this.body === void 0) {
      this.body = [content];
    } else if (isBlockSequence(this.body)) {
      this.body.push(content);
    } else {
      throw new Error("internal error: attempting to add block to non-BlockSequence");
    }
    content.parent = this;
  }
  toString() {
    return toJSON(this, 2, true);
  }
  /**
   * Returns a string that uniquely identifies this Block
   * suitable for debugging or debug log purposes.
   *
   * todo[errors] consider using this, or an improved form of this, or
   *  something similar for end-user error messages, that uniquely
   *  identifies the source of the error in the source. *At the very
   *  least* it must include the source position as the value returned
   *  by this does.
   *
   * todo![now, references] replace all debug calls to toString with this.
   */
  toDebugString() {
    return this.toHierarchyString();
  }
  /**
   * Returns a single line representing the parent container (nesting)
   * hierarchy of this Block, along with the start line info for each
   * block in the hierarchy, if available.
   *
   * ! Used by ptss-parser's debug logging. Do not change unless the
   *    impact on said debug log is intentional.
   */
  toHierarchyString() {
    if (this.parent === void 0) {
      return "/";
    }
    let s = this.parent.toDebugString();
    if (s.length > 1)
      s += "/";
    s += this.type;
    if (this.source?.lineStart) {
      s += "(ln " + this.source?.lineStart + ")";
    }
    return s;
  }
  /**
   * @returns whether or not the block tree rooted in this block
   *   contains at least one `section` block. Excludes any nested
   *   sectioning roots from the search.
   */
  hasSections() {
    let result = false;
    this.traverseBodyTree(function(node) {
      if (node.type === "section") {
        result = true;
        return 2;
      }
      return node.isSectioningRoot() ? 1 : 0;
    });
    return result;
  }
  isSectioningRoot() {
    return sectioningRoots.has(this.type);
  }
  /**
   * Traverses the "body tree" rooted in this Block in preorder, calling
   * `blockFunc` for each node.
   *
   * ℹ️ If some other branches than body branches need to be included in the
   * traversal, the implementation of the `blockFunc` can do that based on
   * knowledge of the content model of the block in question. i.e. the
   * `blockFunc` can call this function for any non-body rooted branch.
   *   > # 🟧 but this doesn't cover used-defined custom block types. See below.
   *
   * ℹ️ If the body branches of Inlines need to be included in the
   * traversal, the implementation of the `blockFunc` can do that, calling
   * Inline.traverseInlineBodyTree for each desired inline component of the
   * block in question's content model.
   *
   * `blockFunc` return values
   * -------------------------
   * - `0`: continue traversal
   * - `1`: do not traverse the children of this node, but continue traversal
   * - `2`: abort traversal immediately
   *
   * todo[perf] an alternate solution is for the caller to also provide a
   *   `childFilter` function. The filter is applied to the node (after the
   *   `blockFunc`, and only those children returned by the filter are traversed.
   *   This will give both the greatest amount of control (i.e. not just "body tree")
   *   while remaining very efficient. If no filter is given, all `body`
   *   children will be traversed. PERHAPS, have both versions, `traverseBodyTree`
   *   and `traverseFilteredTree`.
   *
   * todo[arch] 🟧 Some client functions are themselves generic, e.g.
   *   `parseBlockInlines`. But that method has hardcoded logic to parse the inline
   *   values of the b.body and b.title, and will fail to parse the inline content
   *   values of fields of custom block types.
   *   Some approaches that could work:
   *     A. Iterate over all properties, looking for ones with values of a
   *        type that would need processing (e.g. BlockSequence)
   *     B. Each block type definition includes a list of field names that
   *        contain content, besides the standard `body` field.
   *
   * todo[arch, perf] would this method and its callers benefit if it supported
   *   both pre- and post-order traversal callbacks like textAssembly/travers.ts?
   *
   * todo![tables] we have hardcoded logic for type='table' below. See above notes
   */
  traverseBodyTree(blockFunc) {
    const stack = [this];
    let node;
    let body;
    while (stack.length > 0) {
      node = stack.pop();
      switch (blockFunc(node)) {
        case 0:
          body = node.body;
          if (body) {
            const type = stirType(body);
            if (type === "bSeq") {
              for (let i = body.length - 1; i >= 0; i--) {
                stack.push(body[i]);
              }
            } else if (type === "bTable") {
              const table = body;
              for (let i = table.length - 1; i >= 0; i--) {
                const row = table[i];
                for (let j = row.length - 1; j >= 0; j--) {
                  stack.push(row[j]);
                }
              }
            }
          }
          if (node.head) {
            const table = node.head;
            for (let i = table.length - 1; i >= 0; i--) {
              const row = table[i];
              for (let j = row.length - 1; j >= 0; j--) {
                stack.push(row[j]);
              }
            }
          }
          break;
        case 1:
          break;
        case 2:
          return;
      }
    }
  }
};

// stir/serialization.ts
var import_json5 = __toESM(require_dist(), 1);
var typeMap = {
  structured_text_intermediate_representation: "block",
  paragraph: "block",
  section: "block",
  heading: "block",
  list: "block",
  list_item: "block",
  table: "block",
  block_quote: "block",
  interjection: "block",
  code_block: "block",
  emph: "inline",
  strong: "inline",
  xref: "inline",
  code: "inline"
};
var blockTypes = Object.keys(typeMap).filter((k) => typeMap[k] === "block");
var inlineTypes = Object.keys(typeMap).filter((k) => typeMap[k] === "inline");
function toJSON(stir, space, isFragment = false) {
  return JSON.stringify(
    stir,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function(key, value) {
      if (key[0] === "~") {
        return void 0;
      }
      if (!isFragment && key === "" && value === stir) {
        if (!(value instanceof Block)) {
          throw new TypeError(`argument to stir.toJSON not a STIR. Expecting Block, encountered ${typeof value === "object" ? value.constructor ? value.constructor.name : typeof value : typeof value}`);
        }
        const r = {
          // todo[spec, stir, serialization] 'STIR' or 'structured_text_intermediate_representation' ?
          //   - adding 30-40 bytes isn't an issue.
          //   - we can be like most tech and use code like 'STIR'
          //   - or we can be more explicit (and also never have to worry about ambiguity/name collision)
          // todo[spec, stir, versioning]
          //   - using type and subtype as below ONLY makes sense if it is consistent with the semantics
          //     of those properties as used on non-root nodes.
          //   - consider these options:
          //     - version is part of type:
          //       ```
          //       type: 'structured_text_intermediate_representation,v1'
          //       subtype: 'basic_profile'
          //       ```
          //     - traditional separate version field:
          //       ```
          //       type: 'structured_text_intermediate_representation'
          //       subtype: 'technical'
          //       version: '1'
          //       ```
          type: "structured_text_intermediate_representation",
          subtype: "basic V1",
          // this is my idea of different STIR profiles
          types: {
            block: blockTypes,
            inline: inlineTypes
          }
        };
        for (const k in value) {
          if (k !== "source" && k !== "type") {
            r[k] = value[k];
          }
        }
        return r;
      }
      if (!value || typeof value !== "object" || Array.isArray(value)) {
        return value;
      }
      if (value instanceof Block || value.type === "cell") {
        const { parent, source, ...rest } = value;
        return rest;
      }
      if (value instanceof Inline2) {
        const r = {};
        for (const k in value) {
          if (k === "_type") {
            r["type"] = value[k];
          } else if (k === "referent") {
            const referent = value[k];
            if (typeof referent === "object") {
              r["referent"] = `@id:${referent.id}`;
            } else {
              r["referent"] = referent;
            }
          } else {
            r[k] = value[k];
          }
        }
        return r;
      }
      return value;
    },
    space
  );
}
function fromJSON(stirJSON) {
  const o = import_json5.default.parse(stirJSON, function(key, value) {
    if (!value || typeof value !== "object" || Array.isArray(value)) {
      return value;
    }
    const isRoot = key === "";
    if (value.type) {
      switch (typeMap[value.type]) {
        case "block": {
          const block = new Block(value.type);
          for (const k in value) {
            if (k === "body") {
              const body = value.body;
              if (Array.isArray(body) && body[0] instanceof Block) {
                body.forEach((b) => {
                  block.appendToBody(b);
                });
              } else {
                block.body = body;
              }
            } else if (!isRoot || k !== "subtype" && k !== "types") {
              block[k] = value[k];
            }
          }
          return block;
        }
        case "inline": {
          const inline = new Inline2(value.type);
          for (const k in value) {
            if (k !== "type") {
              inline[k] = value[k];
            }
          }
          return inline;
        }
        default:
          throw new TypeError(`unknown type "${value.type}"`);
      }
    }
    return value;
  });
  return o;
}

// stir/inline.ts
var Inline2 = class {
  /**
   * e.g. paragraph, heading, item, block_quote, strong, image...
   *
   * todo[api, arch] TEMP HACK: JSON deserialization code is currently using
   * the `_` prefix or lack thereof to distinguish between Block and Inline
   * elements in the JSON representation. See `fromJSON` and `fromObject`.
   */
  _type;
  subtype;
  id;
  /**
   * The main content.
   *
   *! `body` is special.
   *    - It is the main content tree
   *    - recurseInlineBodyTree walks the inline tree defined by body. It is used, for example, to:
   *      - recursively search for elements needing targeting IDs.
   *      No other part of a block's content model is recursively searched for these things.
   */
  body;
  // link, image
  referent;
  desc;
  constructor(type) {
    this._type = type;
  }
  get type() {
    return this._type;
  }
  bodyAppend(content) {
    if (this.body === void 0) {
      if (typeof content === "string" || Array.isArray(content)) {
        this.body = content;
      } else {
        this.body = [content];
      }
    } else if (typeof this.body === "string") {
      if (Array.isArray(content)) {
        this.body = [this.body, ...content];
      } else {
        this.body = [this.body, content];
      }
    } else {
      if (Array.isArray(content)) {
        this.body.push(...content);
      } else {
        this.body.push(content);
      }
    }
  }
  toString() {
    return toJSON(this, 2, true);
  }
  inlineBodyText() {
    return inlineBodyText([this]);
  }
  traverseBodyTree(func) {
    traverseInlineBodyTree([this], func);
  }
};
function inlineBodyText(seq) {
  if (!seq || seq === "") {
    return "";
  }
  let text = "";
  traverseInlineBodyTree(seq, function(inline) {
    if (typeof inline === "string") {
      text += inline;
    }
  });
  return text;
}
function traverseInlineBodyTree(seq, func) {
  if (typeof seq === "string") {
    func(seq);
  } else {
    for (const item of seq) {
      func(item);
      if (typeof item !== "string" && item.body) {
        traverseInlineBodyTree(item.body, func);
      }
    }
  }
}

// ptss-parser/ptss/namedValue.ts
function normalizeName(s) {
  return s.trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase().toLowerCase();
}
function stringifyNameAndValue(name, v) {
  return `${name} -> ${stringifyValue(v)}`;
}
function stringifyValue(v) {
  if (v.type === "href") {
    let s = `href (url="${v.url}"`;
    if (v.desc)
      s += `, desc="${v.desc}"`;
    return s + ")";
  } else if (v.type === "substitution") {
    return `substitution for "${JSON.stringify(v.content)}"`;
  } else {
    const element = v.element;
    if (element instanceof Inline2) {
      return `inline (${element.type} "${element.inlineBodyText()}")`;
    } else {
      return `block (${element.toDebugString()})`;
    }
  }
}

// node_modules/entities/lib/esm/generated/decode-data-html.js
var decode_data_html_default = new Uint16Array(
  // prettier-ignore
  '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/generated/decode-data-xml.js
var decode_data_xml_default = new Uint16Array(
  // prettier-ignore
  "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map((c) => c.charCodeAt(0))
);

// node_modules/entities/lib/esm/decode_codepoint.js
var _a;
var decodeMap = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var fromCodePoint = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
    let output = "";
    if (codePoint > 65535) {
      codePoint -= 65536;
      output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    output += String.fromCharCode(codePoint);
    return output;
  }
);
function replaceCodePoint(codePoint) {
  var _a3;
  if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
    return 65533;
  }
  return (_a3 = decodeMap.get(codePoint)) !== null && _a3 !== void 0 ? _a3 : codePoint;
}

// node_modules/entities/lib/esm/decode.js
var CharCodes;
(function(CharCodes2) {
  CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
  CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
  CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
  CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
  CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
  CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
  CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
  CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
  CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
  CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
  CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
  CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
})(CharCodes || (CharCodes = {}));
var TO_LOWER_BIT = 32;
var BinTrieFlags;
(function(BinTrieFlags2) {
  BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
  BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
  BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
})(BinTrieFlags || (BinTrieFlags = {}));
function isNumber(code) {
  return code >= CharCodes.ZERO && code <= CharCodes.NINE;
}
function isHexadecimalCharacter(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
}
function isAsciiAlphaNumeric(code) {
  return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
}
function isEntityInAttributeInvalidEnd(code) {
  return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
}
var EntityDecoderState;
(function(EntityDecoderState2) {
  EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
  EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
  EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
  EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
  EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
})(EntityDecoderState || (EntityDecoderState = {}));
var DecodingMode;
(function(DecodingMode2) {
  DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
  DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
  DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
})(DecodingMode || (DecodingMode = {}));
var EntityDecoder = class {
  constructor(decodeTree, emitCodePoint, errors) {
    this.decodeTree = decodeTree;
    this.emitCodePoint = emitCodePoint;
    this.errors = errors;
    this.state = EntityDecoderState.EntityStart;
    this.consumed = 1;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.decodeMode = DecodingMode.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(decodeMode) {
    this.decodeMode = decodeMode;
    this.state = EntityDecoderState.EntityStart;
    this.result = 0;
    this.treeIndex = 0;
    this.excess = 1;
    this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(str, offset) {
    switch (this.state) {
      case EntityDecoderState.EntityStart: {
        if (str.charCodeAt(offset) === CharCodes.NUM) {
          this.state = EntityDecoderState.NumericStart;
          this.consumed += 1;
          return this.stateNumericStart(str, offset + 1);
        }
        this.state = EntityDecoderState.NamedEntity;
        return this.stateNamedEntity(str, offset);
      }
      case EntityDecoderState.NumericStart: {
        return this.stateNumericStart(str, offset);
      }
      case EntityDecoderState.NumericDecimal: {
        return this.stateNumericDecimal(str, offset);
      }
      case EntityDecoderState.NumericHex: {
        return this.stateNumericHex(str, offset);
      }
      case EntityDecoderState.NamedEntity: {
        return this.stateNamedEntity(str, offset);
      }
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(str, offset) {
    if (offset >= str.length) {
      return -1;
    }
    if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
      this.state = EntityDecoderState.NumericHex;
      this.consumed += 1;
      return this.stateNumericHex(str, offset + 1);
    }
    this.state = EntityDecoderState.NumericDecimal;
    return this.stateNumericDecimal(str, offset);
  }
  addToNumericResult(str, start, end, base) {
    if (start !== end) {
      const digitCount = end - start;
      this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
      this.consumed += digitCount;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char) || isHexadecimalCharacter(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 16);
        return this.emitNumericEntity(char, 3);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 16);
    return -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(str, offset) {
    const startIdx = offset;
    while (offset < str.length) {
      const char = str.charCodeAt(offset);
      if (isNumber(char)) {
        offset += 1;
      } else {
        this.addToNumericResult(str, startIdx, offset, 10);
        return this.emitNumericEntity(char, 2);
      }
    }
    this.addToNumericResult(str, startIdx, offset, 10);
    return -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(lastCp, expectedLength) {
    var _a3;
    if (this.consumed <= expectedLength) {
      (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
      return 0;
    }
    if (lastCp === CharCodes.SEMI) {
      this.consumed += 1;
    } else if (this.decodeMode === DecodingMode.Strict) {
      return 0;
    }
    this.emitCodePoint(replaceCodePoint(this.result), this.consumed);
    if (this.errors) {
      if (lastCp !== CharCodes.SEMI) {
        this.errors.missingSemicolonAfterCharacterReference();
      }
      this.errors.validateNumericCharacterReference(this.result);
    }
    return this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(str, offset) {
    const { decodeTree } = this;
    let current = decodeTree[this.treeIndex];
    let valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
    for (; offset < str.length; offset++, this.excess++) {
      const char = str.charCodeAt(offset);
      this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
      if (this.treeIndex < 0) {
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
        (valueLength === 0 || // And there should be no invalid characters.
        isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
      }
      current = decodeTree[this.treeIndex];
      valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
      if (valueLength !== 0) {
        if (char === CharCodes.SEMI) {
          return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
        }
        if (this.decodeMode !== DecodingMode.Strict) {
          this.result = this.treeIndex;
          this.consumed += this.excess;
          this.excess = 0;
        }
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var _a3;
    const { result, decodeTree } = this;
    const valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
    this.emitNamedEntityData(result, valueLength, this.consumed);
    (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.missingSemicolonAfterCharacterReference();
    return this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(result, valueLength, consumed) {
    const { decodeTree } = this;
    this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
    if (valueLength === 3) {
      this.emitCodePoint(decodeTree[result + 2], consumed);
    }
    return consumed;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var _a3;
    switch (this.state) {
      case EntityDecoderState.NamedEntity: {
        return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      }
      case EntityDecoderState.NumericDecimal: {
        return this.emitNumericEntity(0, 2);
      }
      case EntityDecoderState.NumericHex: {
        return this.emitNumericEntity(0, 3);
      }
      case EntityDecoderState.NumericStart: {
        (_a3 = this.errors) === null || _a3 === void 0 ? void 0 : _a3.absenceOfDigitsInNumericCharacterReference(this.consumed);
        return 0;
      }
      case EntityDecoderState.EntityStart: {
        return 0;
      }
    }
  }
};
function getDecoder(decodeTree) {
  let ret = "";
  const decoder = new EntityDecoder(decodeTree, (str) => ret += fromCodePoint(str));
  return function decodeWithTrie(str, decodeMode) {
    let lastIndex = 0;
    let offset = 0;
    while ((offset = str.indexOf("&", offset)) >= 0) {
      ret += str.slice(lastIndex, offset);
      decoder.startEntity(decodeMode);
      const len = decoder.write(
        str,
        // Skip the "&"
        offset + 1
      );
      if (len < 0) {
        lastIndex = offset + decoder.end();
        break;
      }
      lastIndex = offset + len;
      offset = len === 0 ? lastIndex + 1 : lastIndex;
    }
    const result = ret + str.slice(lastIndex);
    ret = "";
    return result;
  };
}
function determineBranch(decodeTree, current, nodeIdx, char) {
  const branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
  const jumpOffset = current & BinTrieFlags.JUMP_TABLE;
  if (branchCount === 0) {
    return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
  }
  if (jumpOffset) {
    const value = char - jumpOffset;
    return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
  }
  let lo = nodeIdx;
  let hi = lo + branchCount - 1;
  while (lo <= hi) {
    const mid = lo + hi >>> 1;
    const midVal = decodeTree[mid];
    if (midVal < char) {
      lo = mid + 1;
    } else if (midVal > char) {
      hi = mid - 1;
    } else {
      return decodeTree[mid + branchCount];
    }
  }
  return -1;
}
var htmlDecoder = getDecoder(decode_data_html_default);
var xmlDecoder = getDecoder(decode_data_xml_default);
function decodeHTML(str, mode = DecodingMode.Legacy) {
  return htmlDecoder(str, mode);
}

// orphans/parseUtil.ts
var C_BACKSLASH = 92;
var ENTITY = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});";
var reBackslashOrAmp = /[\\&]/;
var ESCAPABLE = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]";
var reEntityOrEscapedChar = new RegExp("\\\\" + ESCAPABLE + "|" + ENTITY, "gi");
var reAttribSpecial = new RegExp('[&<>"]', "g");
var reTextSpecial = new RegExp("[&<>]", "g");
var reWhitespace = /\s/;
function isWhitespace(ch) {
  return reWhitespace.test(ch);
}
var unescapeChar = function(s) {
  if (s.charCodeAt(0) === C_BACKSLASH) {
    return s.charAt(1);
  } else {
    return decodeHTML(s);
  }
};
var unescapeString = function(s) {
  if (reBackslashOrAmp.test(s)) {
    return s.replace(reEntityOrEscapedChar, unescapeChar);
  } else {
    return s;
  }
};
var replaceUnsafeAttribChar = function(s) {
  switch (s) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return s;
  }
};
var escapeAttrib = function(s) {
  if (reAttribSpecial.test(s)) {
    return s.replace(reAttribSpecial, replaceUnsafeAttribChar);
  } else {
    return s;
  }
};
var escapeTextChar = function(s) {
  switch (s) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    default:
      return s;
  }
};
var escapeText = function(s) {
  if (reTextSpecial.test(s)) {
    return s.replace(reTextSpecial, escapeTextChar);
  } else {
    return s;
  }
};

// ptss-parser/ptss/elementalBlockStyle.ts
var RE_MARKDOWN_INDENT = /markdown\((\d+),(\d+)\)/;
function evalIRBlockPropertyExpr(expressions, irBlock, headMatch, tailMatch, bodyMatch, markerMatch, righterMatch) {
  for (const property in expressions) {
    const exp = expressions[property];
    irBlock[property] = exp.evaluate(headMatch, tailMatch, bodyMatch, markerMatch, righterMatch);
  }
}
function evalPTNamedValueExpr(expressions, irNode, headMatch, tailMatch, bodyMatch, markerMatch, righterMatch) {
  const name = expressions.name.evaluate(
    headMatch,
    tailMatch,
    bodyMatch,
    markerMatch,
    righterMatch
  );
  const normalizedName = normalizeName(name);
  if (normalizedName === "") {
    return void 0;
  }
  let nv, href, desc, content;
  switch (expressions.type) {
    case "element":
      if (expressions.value === "self" && irNode !== void 0) {
        nv = { name: normalizedName, value: { type: "element", element: irNode } };
      } else {
        throw new TypeError(`style sheet error: invalid referent-element Named Value declaration. value: ${expressions.value}, irNode:${irNode}}`);
      }
      break;
    case "href":
      href = expressions.value.evaluate(
        headMatch,
        tailMatch,
        bodyMatch,
        markerMatch,
        righterMatch
      );
      href = unescapeString(href);
      desc = expressions.description?.evaluate(
        headMatch,
        tailMatch,
        bodyMatch,
        markerMatch,
        righterMatch
      );
      if (desc !== void 0) {
        desc = unescapeString(desc);
      }
      nv = { name: normalizedName, value: { type: "href", url: href, desc } };
      break;
    case "substitution":
      content = expressions.value.evaluate(
        headMatch,
        tailMatch,
        bodyMatch,
        markerMatch,
        righterMatch
      );
      nv = { name: normalizedName, value: { type: "substitution", content } };
      break;
    case "metadata":
    case "counter":
      throw new TypeError(`${expressions.type} Named Value not yet supported`);
  }
  return nv;
}

// ptss-parser/ptss/block.ts
var defaultContinuesFunc = () => false;
var Block2 = class {
  style;
  // todo: do we really need/want sourcepos info?
  //   pandoc sourcepos extension
  //   https://github.com/commonmark/commonmark.js/issues/29
  lineStart;
  lineEnd;
  // CONTAINER META DATA
  // if the sloppiness limit of successive lines of a container
  // is different from the stylesheet limit, this
  // field will be set.
  sloppiness;
  indent = 0;
  padding;
  topBorderChar;
  topBorderLength;
  leftBorderChar;
  bottomBorderChar;
  // if whether the last line *attributed to this container* is a
  // blank line (within the context of the container, i.e. the text
  // belonging to the container's structure or to that if its parent
  // container structures are not counted). When during parsing, the
  // "ownership" of the blank line is transferred to a child or
  // parent container, this value will be updated.
  // todo[arch, performance] might be able to greatly simplify all the
  //  blank line attribution logic the way this PR did for CommonMark.js:
  //    https://github.com/commonmark/commonmark.js/pull/269
  //  Specifically, a blank line belongs to a container ONLY under the
  //  following conditions:
  //  - if there is a source position gap between two items *in* the
  //    container (item2.lineEnd - item1.lineStart), that is a blank line
  //    in the container.
  //  - if the container has a bottom border, and there is a source position
  //    gap between the list item in the and the bottom border, that is a
  //    blank line in the container. Likewise at the top border.
  //  - if the container has a left border, an the current parse line is
  //    blank, it belongs to the container.
  //  - otherwise if the current parse line is blank, whether it belongs to
  //    the current container depends on whether the container continues past
  //    the current line
  lastLineBlank = false;
  // LIST META DATA
  listBulletChar;
  listDelimiter;
  listContentIndent;
  //todo[lookahead] HACK to implement Markdown rule that list item can't only start
  //  with one blank. Continues method needs this info. Punt better solution
  //  as parsing architecture and continues method still in flux.
  endItemIfNextLineBlank = false;
  // html blocks
  _htmlBlockType = void 0;
  constructor(style) {
    this.style = style;
  }
  /**
   * This method only applicable if the ptss.Block is a container.
   *
   * If the element continues on the line, the line's parse state will
   * be advanced accordingly. Otherwise the line's parse state will remain
   * unchanged.
   *
   * todo[perf] delete after done this to save memory?
   *
   * todo[arch] do we really need this per ParsedIrElement? rather than per ElementalBlockStyle?
   */
  continues = defaultContinuesFunc;
  //todo[arch] consider moving continues to ParseContainer. Why?:
  //  - Don't have to look up parseContainer.irContainer.source.continues(), just parseContainer.continues()
  //  - The continues method often needs details about the source. In that case we can keep a reference to
  //    the source in ParseContainer, or just do parseContainer.irContainer.source
  //    BUT most of the time continues doesn't doesn't need anything?
  //    -- or do we create a closure over the needed source info?
  //  - whatever we attach to ParseContainer will get garbage collected sooner.
  toString() {
    const style = this.style.styleSheet.name;
    return JSON.stringify(this, function(k, v) {
      if (k === "style") {
        return style;
      } else if (v === void 0) {
        return void 0;
      }
      return v;
    });
  }
};

// ptss-parser/ptss/chunkStyle.ts
var ChunkStyle = class {
  name;
  baseType = 1 /* Chunk */;
  indent = "no";
  //structure
  headPattern;
  bodyPattern;
  tailPattern;
  // todo[spec] Ditch maxLines? Replace with 'single line' | 'multiline'
  //  Reasoning:
  //    - *Let Humans Decide* principle. Let the author of the content
  //      decide that a tail anchored chunk is too long to be seen as
  //      such by the human eye. Max lines should be a guideline, not
  //      a rule enforced by machines on humans.
  //  🥃 OTOH, what about a Setext heading that is 50 lines long?
  //    that's just crazy, and forward parsing that far is really
  //    expensive, and guess what? it's really expensive for the human
  //    eye too! So we have a maxLines too!!!  So I think we leave it
  //    in and strongly recommend that for any "natural style", it should
  //    be generous (for Always Be Recognizing principle), but that being
  //    too generous doesn't actually help that principle and it hurts
  //    alignment with the human eye AND it costs in performance (e.g.
  //    a document with long paragraphs with many soft breaks to stay
  //    within 60 cals is going to fwd parse EVERY LINE for many lines!
  maxLines;
  //todo[test] missing test cases covering styles with maxLines > 1
  canInterruptParagraph = false;
  canInterruptLazy = false;
  lazyContinuation = false;
  interruptibleBy = [];
  consumesBackChunk = false;
  styleSheet;
  // property expressions
  _irNode;
  _ptNamedValue;
  constructor(name, styleSheet) {
    this.name = name;
    this.styleSheet = styleSheet;
  }
  get irNode() {
    if (this._irNode === void 0) {
      this._irNode = {};
    }
    return this._irNode;
  }
  set ptNamedValue(value) {
    this._ptNamedValue = value;
  }
  //todo![validation] missing checks in some styles that i do in others. Need
  //  to implement the common ones in a shared function declared in Block.ts
  initAndValidate() {
    if (this._ptNamedValue?.value === "self" && this._irNode === void 0) {
      throw new Error(`ptNamedValue.value is set to ${this._ptNamedValue.value} but the style is not configured to generate one`);
    }
    this.interruptibleBy = this.styleSheet.blockStyles.filter((s) => s.canInterruptParagraph && s !== this);
    const match = RE_MARKDOWN_INDENT.exec(this.indent);
    if (match) {
      throw new Error(`markdown mode indent is not supported for chunks`);
    }
    if (this.maxLines === 1) {
      if (!this.headPattern) {
        throw new Error("single-line chunk styles require a head pattern");
      }
      if (this.tailPattern) {
        throw new Error("single-line chunk styles CANNOT have tail-pattern");
      }
    }
    if (!this.headPattern && !this.tailPattern) {
      throw new Error("chunk styles must have a head or tail pattern");
    }
    if (this.consumesBackChunk) {
      if (this.headPattern) {
        throw new Error("chunk styles with head pattern cannot match backwards");
      }
      if (!this.tailPattern) {
        throw new Error("chunk styles without tail pattern cannot match backwards");
      }
      if (this.maxLines === 1) {
        throw new Error("single line chunk styles cannot match backwards");
      }
    }
  }
  /**
   * Returns null if doesn't match
   *
   * todo[test] all variations of structure in Chunk docs
   *
   *  todo[perf] HOW TO AVOID REDUNDANT "FAIL" PARSES?
   *     - WE ALREADY avoid redundant success parses by opportunistically
   *       saving container continuation done for any fwd parse requests
   *       in the state of each Line.
   *     - what if we did that for FAILED parsing? e.g. that we already
   *       checked a line for a bottom border before?
   *       - we could attach the info to the Line
   *       - we could also save the info in the ContainerStyle instance,
   *         just a single number representing "we've already checked
   *         every line up to this line N for this particular feature,
   *         e.g. this instances bottom border.
   *  todo[fwd-parsing] IDEA: We save various fwd parse discoveries
   *   in Line or other:
   *     - We ALREADY save parsed container continuation
   *     - We CAN save new element start detection
   *       - this may have to be tentative if whether an element starts
   *         depends on adjacency rules with the previous element which we
   *         haven't yet determined
   *     - We can save indentation/whitespace parsing
   *       e.g. we have EOC (end of content), so we could add:
   *       - SOC (start of content), or perhaps pContainerSOC.
   *         if pContainerSOC:
   *             pContainerSOL < pContainerSOC < EOC
   *         > 📥❓ we have pContainerSOL, and it looks like we are setting
   *         > it correctly, but are we actually using it?
   *       - see similar note in tableStyle.
   */
  parse(firstLine, fromBackLine, lookahead = false) {
    const src = firstLine.src;
    let lastLine;
    const indent = firstLine.parseSpaces();
    if (indent === 0 && this.indent === "yes") {
      return null;
    }
    if (indent > 0 && this.indent === "no") {
      return null;
    }
    const startOffset = firstLine.ptr;
    let headMatch = null;
    let tailMatch = null;
    let bodyMatch = null;
    if (this.maxLines === 1) {
      const headPattern = this.headPattern;
      headPattern.lastIndex = startOffset;
      headMatch = headPattern.exec(src);
      if (!headMatch)
        return null;
      if (lookahead) {
        return {};
      }
      firstLine.ptr = headPattern.lastIndex;
      if (this.bodyPattern) {
        this.bodyPattern.lastIndex = firstLine.ptr;
        bodyMatch = this.bodyPattern.exec(src);
        if (bodyMatch) {
        } else {
          bodyMatch = [firstLine.remainingSlice()];
        }
      } else {
        bodyMatch = [firstLine.remainingSlice()];
      }
      lastLine = firstLine;
    } else if (this.headPattern) {
      this.headPattern.lastIndex = startOffset;
      headMatch = this.headPattern.exec(src);
      if (!headMatch)
        return null;
      firstLine.ptr = this.headPattern.lastIndex;
      const r = firstLine.fwdChunk(
        indent,
        this.bodyPattern,
        this.tailPattern,
        false,
        this.maxLines,
        //! interruption checks SHOULD NOT be recursive!
        lookahead ? void 0 : this.interruptibleBy,
        this.styleSheet.sloppyMargin,
        this.lazyContinuation
      );
      if (r === null) {
        return null;
      }
      [bodyMatch, tailMatch, lastLine] = r;
      if (this.tailPattern) {
      }
      if (lookahead) {
        return {};
      }
    } else if (!this.consumesBackChunk) {
      const tailPattern = this.tailPattern;
      const r = firstLine.fwdChunk(
        indent,
        this.bodyPattern,
        this.tailPattern,
        false,
        this.maxLines,
        //! interruption checks SHOULD NOT be recursive!
        lookahead ? void 0 : this.interruptibleBy,
        this.styleSheet.sloppyMargin,
        this.lazyContinuation
      );
      if (r === null) {
        return null;
      }
      [bodyMatch, tailMatch, lastLine] = r;
      if (bodyMatch[0].length === 0) {
        return null;
      }
      if (lookahead) {
        return {};
      }
    } else {
      if (fromBackLine === null) {
        return null;
      }
      lastLine = firstLine;
      firstLine = fromBackLine;
      if (this.maxLines) {
        if (lastLine.num - firstLine.num + 1 > this.maxLines)
          return null;
      }
      const tailPattern = this.tailPattern;
      tailPattern.lastIndex = startOffset;
      tailMatch = tailPattern.exec(src);
      if (!tailMatch)
        return null;
      bodyMatch = [src.slice(startOffset, tailMatch.index)];
      let l = fromBackLine;
      let u = "";
      while (l.num < lastLine.num) {
        u += l.remainingSlice();
        l = l.next;
      }
      if (u !== "") {
        bodyMatch[0] = u + bodyMatch[0];
      } else {
        return null;
      }
      if (lookahead) {
        return {};
      }
      if (this.bodyPattern) {
        this.bodyPattern.lastIndex = 0;
        bodyMatch = this.bodyPattern.exec(bodyMatch[0]);
      }
    }
    let irBlock = void 0;
    if (this._irNode !== void 0) {
      const ptBlock = new Block2(this);
      ptBlock.lineStart = firstLine.num;
      ptBlock.lineEnd = lastLine.num;
      irBlock = new Block("block");
      evalIRBlockPropertyExpr(this._irNode, irBlock, headMatch, tailMatch, bodyMatch, null, null);
      irBlock.source = ptBlock;
    }
    let ptNamedValue = void 0;
    if (this._ptNamedValue !== void 0) {
      ptNamedValue = evalPTNamedValueExpr(
        this._ptNamedValue,
        irBlock,
        headMatch,
        tailMatch,
        bodyMatch,
        null,
        null
      );
    }
    if (irBlock === void 0 && ptNamedValue === void 0) {
      return null;
    }
    return { irBlock, ptNamedValue, startLine: firstLine, endLine: lastLine };
  }
};

// ptss-parser/parseContainer.ts
var ParseContainer = class {
  parent;
  /** the ir.Block associated with this ParseContainer */
  irContainer;
  /**
   * Lists are "retroactive, virtual" containers in plain text: We can't
   * parse them; instead we parse list items and then retroactively create
   * a List container to wrap adjacent list items of the same style. If the
   * last item parsed in a container is a list item, the `openList` will
   * point to that item's containing list. Otherwise it will be null.
   *
   * An open list is closed in one of two ways:
   *  - we encounter a non-list item. The parser must set this to null
   *  - this ParseContainer ends (e.g. a block quote ends, or the parent
   *    list item for a nested list ends). When this happens, the parser
   *    will no longer point to this ParseContainer, so its openList value
   *    is no longer relevant.
   */
  openList = null;
  sectionStack = void 0;
  constructor(irContainer, parent = null) {
    this.irContainer = irContainer;
    this.parent = parent;
  }
  toString() {
    let hierarchy = this.tip().toHierarchyString();
    if (hierarchy.length > 50) {
      const i1 = hierarchy.indexOf("/") + 1;
      const i2 = hierarchy.slice(0, hierarchy.lastIndexOf("/")).lastIndexOf("/");
      hierarchy = hierarchy.slice(0, i1) + "..." + hierarchy.slice(i2);
    }
    return hierarchy;
  }
  hierarchy(tip) {
    let s;
    if (this.parent === null) {
      s = "";
    } else {
      s = this.parent.hierarchy(false) + "/" + this.irContainer.type;
      if (tip && this.irContainer.source?.lineStart) {
        s += "(ln " + this.irContainer.source?.lineStart + ")";
      }
    }
    if (this.sectionStack?.length) {
      let section;
      for (section of this.sectionStack) {
        s += "/section-L" + section.level;
      }
      if (tip && section && section.source?.lineStart) {
        s += "(ln " + section.source?.lineStart + ")";
      }
    }
    if (this.openList) {
      if (tip) {
        s += "/*list";
        if (this.openList.source?.lineStart) {
          s += "(ln " + this.openList.source?.lineStart + ")";
        }
      } else {
        s += "/list";
      }
    }
    return s === "" ? "/" : s;
  }
  root() {
    let root = this;
    while (root.parent !== null) {
      root = root.parent;
    }
    return root;
  }
  tip() {
    if (this.openList !== null) {
      return this.openList;
    }
    if (this.sectionStack !== void 0 && this.sectionStack.length > 0) {
      return this.sectionStack.at(-1);
    }
    return this.irContainer;
  }
  /**
   * See rules under {@link append}.
   *
   * *! This method assumes section structure is created from heading levels.
   *    If we decide to support a an implicit [[hierarchy syntax]], then
   *    sections would not have numbered levels (currently taken from the
   *    heading. Arguably, levels numbers are redundant in the STIR given
   *    that sections are nested (unless it is important to support skipped
   *    levels, e.g. an H4 child of an H2). In any case,
   *     1. this method would simple add the new section to the current
   *        section, and
   *     2. we'd need to add a `closeSection` method that gets called when
   *        we parse the explicit termination of the section as defined by
   *        the syntax.
   *
   * @param newSection
   */
  appendSection(newSection) {
    if (this.openList != null) {
      this.openList = null;
    }
    const stack = this.sectionStack;
    if (stack === void 0 || stack.length === 0) {
      this.irContainer.appendToBody(newSection);
      this.sectionStack = [newSection];
    } else {
      let curSection;
      for (let i = stack.length - 1; i >= 0; i--) {
        curSection = stack[i];
        if (curSection.level < newSection.level) {
          curSection.appendToBody(newSection);
          stack.push(newSection);
          return;
        }
        stack.pop();
      }
      this.irContainer.appendToBody(newSection);
      this.sectionStack = [newSection];
    }
  }
  /**
   * See rules under {@link append}.
   *
   * @param item
   * @param newList if given, this list will first be appended, then the item
   *                appended to it. if non is given, the item will be added to
   *                the existing open list.
   */
  appendListItem(item, newList) {
    let list;
    if (newList !== void 0) {
      this.append(newList);
      list = newList;
    } else {
      list = this.openList;
      if (this.irContainer.source.lastLineBlank) {
        list.hints["commonmark.list.tight"] = false;
        this.irContainer.source.lastLineBlank = false;
      }
    }
    const ptContainer = list.source;
    if (ptContainer.lastLineBlank && list.body) {
      list.hints["hints.commonmark.list.tight"] = false;
    }
    ptContainer.lastLineBlank = false;
    list.appendToBody(item);
  }
  /**
   * Rules for determining where exactly new block elements are added into
   * the nested container hierarchy managed by ParseContainer:
   *
   *   cpc = curParseContainer
   *
   *   The tip to add new elements in precedence order:
   *     - cpc.openList  (if list item, else close list)
   *     - section at head of cpc.sectionStack
   *     - cpc.irContainer
   *
   *   When a List is added:
   *     - sets cpc.openList to List
   *        (it will have been null since a nested List isn't
   *         ever a direct child of a List, but of a List Item)
   *     - list is appended as child of tip (see above)
   *        (and it thus becomes the tip)
   *
   *   When a List Item is added:
   *     - if this is the first item in a new list, that will have already
   *       been determined and the new List will be added first.
   *     - item added to cpc.openList
   *     - since it is a container, it will be associated
   *       with a new ParseContainer whose parent is cpc, and
   *       become the new cpc and tip
   *     - since the call site for adding list items is dedicated to
   *       list items, and since the add item logic is very unique, purely
   *       for performance purposes we have a separate {@link appendListItem}
   *       method. We could easily have merged that logic into this method
   *       inside of an if-else, but that doesn't make much sense.
   *
   *   When a new Section is encountered:
   *     - sets cpc.openList to null
   *     - pops sections off the cpc.sectionStack that are of same level or higher
   *       (THIS or closing of parent ParseContainer is how a Section terminates)
   *     - section is appended as child of tip (see above)
   *     - section pushed onto cpc.sectionStack
   *       (and thus is the new tip)
   *     - since the call site for adding sections items is dedicated to
   *       sections, and since the add section logic is very unique, purely
   *       for performance purposes we have a separate {@link appendSection}
   *       method. We could easily have merged that logic into this method
   *       inside of an if-else, but that doesn't make much sense.
   *
   *   When any other element is added:
   *     - sets cpc.openList to null
   *       (THIS or closing of parent ParseContainer is how a List terminates)
   *     - element appended as child of tip (see above)
   *     - if it is a container, it will be associated
   *       with a new ParseContainer whose parent is pc, and
   *       become the new cpc and tip
   *
   */
  append(content) {
    if (this.openList != null) {
      this.openList = null;
    }
    const irContainer = this.irContainer;
    const ptContainer = irContainer.source;
    if (content.type === "list") {
      this.openList = content;
    } else {
    }
    let tip = this.sectionStack?.at(-1);
    if (tip === void 0) {
      tip = irContainer;
      if (tip.type === "list_item" && ptContainer.lastLineBlank && tip.body) {
        const parent = this.parent;
        const enclosingContainer = parent.openList ? parent.openList : parent?.irContainer;
        enclosingContainer.hints["commonmark.list.tight"] = false;
      }
    }
    ptContainer.lastLineBlank = false;
    setLineEndUpTree(this, content.source.lineEnd);
    tip.appendToBody(content);
  }
};
function setLineEndUpTree(pContainer, lineEnd) {
  let c = pContainer;
  while (c !== null) {
    c.irContainer.source.lineEnd = lineEnd;
    if (c.openList !== null) {
      c.openList.source.lineEnd = lineEnd;
    }
    c = c.parent;
  }
  if (pContainer.sectionStack !== void 0) {
    for (const block of pContainer.sectionStack) {
      block.source.lineEnd = lineEnd;
    }
  }
}
function parseContinuation(pContainer, line) {
  if (line.pContainer === pContainer) {
    return;
  }
  if (line.pContainer !== pContainer.parent) {
    parseContinuation(pContainer.parent, line);
    if (line.pContainer !== pContainer.parent || line.pContainerBottomBorder !== null) {
      return;
    }
  }
  if (pContainer.irContainer.source.continues(line)) {
    line.pContainer = pContainer;
  } else {
  }
}

// ptss-parser/debugUtil.ts
function stringifyTruncate(s, max = 50) {
  if (s.length > max) {
    return JSON.stringify(s.slice(0, max)).slice(0, max + 1) + "... (TRUNCATED)";
  }
  return JSON.stringify(s);
}
var stringifyReplacerForDebugLogging = () => {
  const seen = /* @__PURE__ */ new WeakSet();
  return (k, v) => {
    if (!v) {
      return v;
    }
    if (k === "source") {
      return void 0;
    }
    if (v instanceof Stylesheet) {
      return { stylesheet: v.name };
    }
    if (v instanceof RegExp) {
      return v.source;
    }
    if (typeof v === "object") {
      if (seen.has(v)) {
        return `\u{1F3F7}`;
      }
      seen.add(v);
    }
    return v;
  };
};

// ptss-parser/line.ts
var Line = class _Line {
  // line number within src, 1-based
  num;
  // start of line
  SOL;
  /**
   * End Of Content: points to the position immediately after the last
   * non-whitespace character on the line.
   * - If line is all whitespace, it will be the same value as `SOL`
   * - If line has no trailing whitespace it will be the same value as `EOL`.
   */
  EOC;
  /**
   * End Of Line: points to the newline character at the end of the line,
   * except for the last line if the file does not end with a newline it
   * points to the position after the last pos in the file.
   *
   * In either case,
   *  - the full content of the line is always `src.substring(SOL, EOL)`
   *  - the trailing whitespace is always `src.substring(EOC, EOL)`
   *  - the remaining part of the line is always `src.substring(ptr, EOL)`
   */
  EOL;
  //! The fields and properties prefixed with "ptr" are tightly
  //  coupled and represent the left-to-right progress of parsing
  //  this Line. `Line.ptr` is a straightforward pointer to a
  //  specific char position in the line, and is `Line.src`
  //  relative. But because of tab expansion, advancing one space
  //  is not always as simple as incrementing `ptr`. If there are
  //  unconsumed "virtual" spaces from an earlier tab char,
  //  advancing may simply decrement `ptrTabRemainder` and
  //  increment `ptrColumnAdj` instead. See the unit tests for a
  //  better understanding.
  // current parse position, relative to src
  ptr;
  // add to `Line.ptr` to arrive at column (one-based)
  ptrColumnAdj = 0;
  get ptrColumn() {
    return this.ptr - this.SOL + 1 + this.ptrColumnAdj;
  }
  // number of spaces from last tab not yet consumed
  ptrTabRemainder = 0;
  _next = null;
  /**
   * Returns the next line.
   * If this is the last line in the src, returns null.
   *
   * Does no parsing or updating of Line state other than
   * to find the EOL if hasn't been determined yet. If this
   * is the first time the next line has been retrieved, it
   * will be initialized to starting state, unparsed, container
   * set to root and ptr set to SOL.
   */
  get next() {
    if (this._next) {
      return this._next;
    }
    const nextSOL = this.EOL + 1;
    if (nextSOL < this.src.length) {
      return this._next = new _Line(this.src, this.num + 1, nextSOL, this._pContainer.root());
    } else {
      return null;
    }
  }
  //! The fields and properties prefixed with "pContainer" are tightly
  //  coupled.
  // the container context as of the current parse point, Line.ptr
  _pContainer;
  get pContainer() {
    return this._pContainer;
  }
  set pContainer(value) {
    this._pContainer = value;
    this.pContainerSOL = this.ptr;
    this.pContainerSlop = 0;
  }
  // offset of the start of content for `Line.pContainer`
  pContainerSOL;
  // number of slop spaces parsed within `Line.pContainer`
  pContainerSlop = 0;
  // If not null, a bottom border for `Line.pContainer` was parsed on this line.
  // For BlockTreeParser control flow based on whether a bottom border was
  // encountered.
  //
  // todo[containers] per the comments on the parseContinuation function, this
  //   is supposed to contain content from the bottom border, supporting
  //   multi-line bottom borders, so styles that have content within
  //   the borders can extract and map the content via ptss.expressions.
  //   --
  //   THIS HAS YET TO BE IMPLEMENTED.
  //   - 🟧 If the bottom border spans multiple Lines, which one's
  //      pContainerBottomBorder is set? And that one contains the content
  //      from all the lines? May need to revisit this design idea.
  //   - 🟧 Line so far doesn't hold parsing matches or any other high level
  //      content parsing data, just low-level index pointers, etc. Probably
  //      any bottom border content match should be returned by the parse
  //      method to its caller via separate return value, as opposed to
  //      shoe-horning it into Line. ???
  pContainerBottomBorder;
  src;
  constructor(src, num, offset, rootContainer) {
    this.src = src;
    this.num = num;
    this._pContainer = rootContainer;
    this.SOL = this.pContainerSOL = this.ptr = offset;
    this.pContainerBottomBorder = null;
    const EOF = src.length;
    let i = src.indexOf("\n", offset);
    if (i === -1) {
      this.EOL = EOF;
      i = EOF;
    } else {
      this.EOL = i;
    }
    do {
      i--;
    } while (i >= offset && isWhitespace(src.charAt(i)));
    this.EOC = i + 1;
  }
  toString() {
    return `[line ${this.num}] sol:${this.SOL} eoc:${this.EOC} eol:${this.EOL} len:${this.EOL - this.SOL + 1}  ptr:${this.ptr}(col:${this.ptrColumn} col+:${this.ptrColumnAdj} tab%:${this.ptrTabRemainder})  pCon:[${this._pContainer.toString()}${this.pContainerBottomBorder ? `\u{1F171}` : ``} sol:${this.pContainerSOL} slop:${this.pContainerSlop}]  r:${stringifyTruncate(this.remainingSlice(), 15)}`;
  }
  /**
   * Saves the current ptr state so that we can speculatively parse
   * ahead and backtrack on match fail. Use the restore() method on
   * the returned object to restore that state.
   *
   * A single checkpoint can be restored multiple times as
   * {@link LineCheckpoint.restore} is idempotent. For example, see its use
   * in {@link ./BlockTreeParser}'s "try each style" parse loop.
   *
   * Since checkpoints are separate objects from Line, multiple checkpoints
   * can be created for the same Line.
   *
   * todo![parsing] i'm pretty sure we don't want to checkpoint {@link Line._next}:
   *   - we'd be throwing out the EOC and EOL parsing.
   *   - the alternative would be for checkpoint to checkpoint the full _next
   *     chain of lines one-by-one, and likewise restore whole chains. This is
   *     wasteful as most of the time we don't speculatively parse past the
   *     cur line or 2 lines.
   *   - What we are already doing now is perfect: make local decisions on how
   *     to efficiently speculatively parse. For example see how
   *     {@link fwdChunkToTailOrBlank} checkpoints all the Lines it touches in
   *     the _next sequence.
   *   .
   *   IF this is right:
   *   - COMMIT TO THIS APPROACH AND DOCUMENT IT HERE OR SOMEWHERE.
   *   - delete the outdated TODOs such as the one at the end of this TSDoc
   *
   * todo![perf] is what we are doing in {@link fwdChunkToTailOrBlank}
   *   unnecessary? review. Remove and run tests to make sure.
   *
   * todo![arch] checkpoint does not save and restore Line.pContainer* state.
   *   Either:
   *     - change that fact (we may need it for speculative parsing, e.g. tables)
   *     - add a warning to this doc that checkpoint usage can't span any
   *       parsing of containers
   *       - rely on tests to catch violations of this.
   *       - put fail-fast logic that invalidates any checkpoints if pContainer
   *         is updated.
   *   GIVEN THE COMPLEXITY OF WHAT I JUST WROTE, just checkpoint the pContainer
   *   state already! Premature optimization!
   */
  checkpoint() {
    return new _Line.Checkpoint(this, this.ptr, this.ptrColumnAdj, this.ptrTabRemainder, this.pContainerSlop);
  }
  static Checkpoint = class {
    line;
    ptr;
    ptrColumnAdj;
    ptrTabRemainder;
    pContainerSlop;
    constructor(line, ptr, ptrColumnAdj, ptrTabRemainder, pContainerSlop) {
      this.line = line;
      this.ptr = ptr;
      this.ptrColumnAdj = ptrColumnAdj;
      this.ptrTabRemainder = ptrTabRemainder;
      this.pContainerSlop = pContainerSlop;
    }
    restore() {
      const line = this.line;
      line.ptr = this.ptr;
      line.ptrColumnAdj = this.ptrColumnAdj;
      line.ptrTabRemainder = this.ptrTabRemainder;
      line.pContainerSlop = this.pContainerSlop;
    }
  };
  /**
   * Advances the ptr state max spaces and returns the amount. Because
   * of tab expansion, `Line.column` will advance the number of spaces
   * returned, but this does not always translate to `Line.ptr`
   * incrementing by the same amount or even at all.
   *
   * @param max
   * @param cancelIfMore if true and spaces exceed max, cancels the operation,
   *        leaving the line state unchanged.
   */
  parseSpaces(max = Number.POSITIVE_INFINITY, cancelIfMore = false) {
    const src = this.src;
    let spaces = 0;
    let colAdj = 0;
    if (this.ptrTabRemainder !== 0) {
      if (cancelIfMore && this.ptrTabRemainder > max) {
        return 0;
      }
      spaces = colAdj = this.ptrTabRemainder;
    }
    let ptr = this.ptr;
    while (spaces < max) {
      if (src.charAt(ptr) === " ") {
        spaces++;
        ptr++;
      } else if (src.charAt(ptr) === "	") {
        const tabSpaces = 4 - (ptr - this.SOL + this.ptrColumnAdj + colAdj) % 4;
        spaces += tabSpaces;
        colAdj = tabSpaces - 1;
        ptr++;
      } else {
        break;
      }
    }
    if (spaces > max) {
      if (cancelIfMore) {
        return 0;
      }
      this.ptr = ptr;
      const over = spaces - max;
      this.ptrColumnAdj += colAdj - over;
      this.ptrTabRemainder = over;
      spaces = max;
    } else {
      if (cancelIfMore && src.charAt(ptr) === " ") {
        return 0;
      }
      this.ptr = ptr;
      this.ptrColumnAdj += colAdj;
      this.ptrTabRemainder = 0;
    }
    return spaces;
  }
  /**
   * Skip leading spaces up to max.
   */
  parseSlop(max, cancelIfMore = false) {
    this.pContainerSlop = this.parseSpaces(max, cancelIfMore);
  }
  /**
   * Parses `min` number of consecutive `ch`, returning the number parsed.
   * @param ch
   */
  parseChars(ch) {
    const src = this.src;
    let ptr = this.ptr;
    let n = 0;
    while (src.charAt(ptr) === ch) {
      n++;
      ptr++;
    }
    this.ptr = ptr;
    return n;
  }
  /**
   * todo[parsing] placeholder idea for factoring out oft repeated
   *  regex matching and parsing logic for these purposes:
   *  - DRY, simplify cod
   *  - encapsulation (of native Line-internals)
   *  - performance (doing line specific parsing inside Line
   *    may have benefits)
   *
   * Executes the regex at Line.ptr. If it matches:
   *  - updates Line.ptr
   *  - returns any match groups (perhaps {@link RegExpMatchArray} or
   *    {@link RegExpExecArray}
   * @param regex
   */
  parseMatch(regex) {
    return;
  }
  // todo![perf] evaluate new RegExp stuff:
  //   - `d` flag, just get start and end indices of match back:
  //     https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/hasIndices
  //   - use `search`?
  //       "When you want to know whether a pattern is found in a string, use the
  //       test() or search() methods; for more information (but slower execution)
  //       use the exec() or match() methods. If you use exec() or match() and if
  //       the match succeeds, these methods return an array and update properties
  //       of the ...
  /**
   * todo![perf] see note on `d` flag, `test` and `search` above.
   * todo![fwd-parsing} useful?
   *
   * Executes the regex at Line.ptr, but with no side affects.
   * Instead, returns the indices of the match, so the caller
   * can efficiently decide whether and when it will update
   * Line state as a result.
   * @param regex
   */
  searchMatch(regex) {
    return [-1, -1];
  }
  /**
   * todo![perf] see note on `d` flag, `test` and `search` above.
   * todo![fwd-parsing} useful?
   *
   * Tests the regex at Line.ptr. No side affects
   * @param regex
   */
  testMatch(regex) {
    return false;
  }
  /**
   * returns the entire line, inclusive of EOL char (newline) if there is
   * one (there may not be one at EOF).
   */
  srcLine() {
    return this.src.slice(this.SOL, this.EOL + 1);
  }
  // todo[perf] if this gets called a lot for the same line at the same ptr,
  //  (e.g. multiple styles trying to match), we could cache the value, and of
  //  course clear it if the the ptr changes (and thus invalidating it)
  //  - BUT ARGUABLY if this is getting called more than once per line, we
  //    are probably doing something wrong in the parsing logic.
  //  .
  //   🥃 easy test: count all calls, and after test suite, do a histogram of
  //     the number of calls per line.
  /**
   * returns the content from `Line.ptr` to EOL, inclusive of EOL char
   * (newline) if there is one (there may not be one at EOF)
   * and prepended by any unconsumed spaces from tab expansion.
   */
  remainingSlice() {
    if (this.ptrTabRemainder) {
      return " ".repeat(this.ptrTabRemainder) + this.src.slice(this.ptr, this.EOL + 1);
    } else {
      return this.src.slice(this.ptr, this.EOL + 1);
    }
  }
  remainingIsBlank() {
    return this.ptr >= this.EOC;
  }
  /**
   * If the next line hasn't already been determined to continue this line's
   * pContainer, then it will be parsed for that now.
   * todo![perf] if it has already previously been parsed to the same
   *   attempted container depth and failed, we'll end up redoing that
   *   work here. It may or may not be worth adding state and logic to
   *   avoid this.
   *
   * By default the next line is returned if and only if it does continue
   * this line's (deepest) pContainer *explicitly* (i.e. not lazily),
   * returning `null` if it does not.
   *
   * For bottom-bordered containers, the line(s) that are the bottom
   * border ar considered part of the container, and are returned as such.
   * They have no content besides the border. The caller can check to the
   * {@link pContainerBottomBorder} property.
   *
   * todo![test] need tests for this option
   * But if `allowSloppy` is `true`, then the next line will be returned if
   * it might lazily continue this line's pContainer. This will be true if
   * the remaining part of the line isn't empty and isn't a container bottom
   * border. Unlike {@link next} the returned line's parse state and
   * pContainer value will reflect the deepest continuing container even if
   * it doesn't continue all of them. This is needed for forward parsing
   * elements that can span lazily continued lines, e.g. CommonMark Setext
   * headings.
   */
  get nextInContainer() {
    return this.getNextInContainer();
  }
  getNextInContainer(allowLazy = false) {
    if (this.pContainerBottomBorder !== null) {
      return null;
    }
    const next = this.next;
    if (next === null) {
      return null;
    }
    if (next._pContainer === this._pContainer) {
      return next;
    }
    parseContinuation(this._pContainer, next);
    if (next._pContainer !== this._pContainer) {
      if (allowLazy && next.pContainerBottomBorder === null && !next.remainingIsBlank()) {
        return next;
      }
      return null;
    }
    return next;
  }
  /**
   * Extract a block of content from current container context, starting from
   * this line and line.ptr, and ending on whichever of the following occurs
   * first:
   *  - a blank line (non inclusive), *if* `stopOnBlank` is true.
   *  - the line matching `stopPattern` (inclusive), if such pattern is given.
   *  - the last line of this line's container
   *  - EOF
   */
  fwdBlock(stopOnBlank, stopPattern) {
    return fwdBlock(this, stopOnBlank, stopPattern);
  }
  /**
   * Extracts a chunk (cannot span blank line) of content from current container
   * context, starting from this line and line.ptr.
   *
   * IMPORTANT: It is assumed that the line on which this is called belongs to
   * the current element, and therefor the following will ONLY be applied to
   * subsequent lines:
   * - parsing start of line indent or slop
   * - interruption checks
   *
   * The extent of the chunk is determined as follows:
   *  - If `tailPattern` given:
   *    - to the line ending in this pattern if such is found.
   *      - BUT if trailingBlankRequired is true, and the line following
   *        the matching line is not blank, returns null
   *    - if no such match is found before a blank line or end of container or file
   *      is encountered, it returns null
   *
   *  - If `tailPattern` is NOT given:
   *    - to a blank line, end of container or EOF, whichever comes first.
   *
   *  - In addition, indentation rules and interruption checks will be applied
   *    and can also terminate teh chunk.
   *
   * Because we don't want TextPlain to reject inputs or exit with errors,
   * we are going to silently ignore the case where the regex doesn't consume
   * to an EOL. Consuming even a single char of a line constitutes consuming it.
   * (todo[doc] Add this to PTSS spec)
   *
   * @returns [<the last line of the chunk>,
   *    <the body of the chunk up to but not including the tailPattern>,
   *    <the RegExpMatchArray resulting from the tailPattern match>]
   *
   *! ⚠️ DO NOT pass in allowedInterruptions if this call is itself part
   *     of an interruption check. All it will do is waste CPU cycles on a
   *     recursive check when a recursive check makes no sense!
   */
  fwdChunk(indent = 0, bodyPattern, tailPattern, trailingBlankRequired = true, maxLines = Number.MAX_VALUE, allowedInterruptions = void 0, sloppyMargin = 0, allowLazy = false) {
    if (tailPattern !== void 0 || trailingBlankRequired || bodyPattern === void 0) {
      return fwdChunkToTailOrBlank(
        this,
        indent,
        tailPattern,
        trailingBlankRequired,
        bodyPattern,
        maxLines,
        allowedInterruptions,
        sloppyMargin,
        allowLazy
      );
    }
    return fwdChunkToBodyMatch(
      this,
      bodyPattern,
      indent,
      maxLines,
      allowedInterruptions,
      sloppyMargin,
      allowLazy
    );
  }
  /**
   * Rules:
   *    - ✅ FIRST: current element always controls whether it can be interrupted. For
   *      example, a left border container with continuing left border doesn't
   *      check for interruption at all (the matching left border takes precedence)
   *      and a table that clearly sees table continuation because of column
   *      patterns doesn't check for interruption.
   *      - 📥 Make sure this is in the rules.
   *
   *    - ✅ SECOND, the set of style that *could* interrupt the current
   *      element is calculated, essentially applying adjacency rules.
   *
   *      Currently this is a static list calculated when the style is
   *      initialized, but if it needed to be more dynamic, it could do that).
   *
   *      We can evolve this into something like my idea for *adjacency
   *      control*, or *interruption control*. Adjacency control may
   *      result in violations of the "Always be recognizing rule", so
   *      would only be used for `strict syntax` styles sheets).
   *      Interruption control, I think, may be compatible with
   *      non-strict syntax style sheets.
   *
   *      Or we need some other generalized solution
   *      that can, for example:
   *      - in test-ptss-one, prevent 'Level 3/4 Setext Heading' form
   *        interrupting 'Level 1/2 Setext Heading', which would otherwise
   *        happen EVERY TIME!
   *
   *      I'm sure I'll have more examples as I implement Pandoc/GFM
   *
   *    - ✅ THIRD, each allowed interrupting style DECIDES whether it interrupts.
   *      1. Obviously it has to match to interrupt, something it decides.
   *      2. BUT EVEN ON A MATCH, it may decline, e.g.:
   *         - The style may require a preceding blank line.
   *         - A list item may decline if the start num is not 1 (CommonMark rule)
   *         - A list item may decide to interrupt ONLY if there are at least
   *           two items in the list (potential *Natural* rule)
   *      3. Precedence rules apply. The interrupted element doesn't get to choose.
   *      4. Likewise, the interrupted element doesn't get to choose a subset of
   *         allowed styles that can interrupt.
   *         - IF WE ALLOW THIS, it will only be a quirk mode for certain legacy styles.
   *      5. If we implement adjacency control, the rules for that may reduce the
   *         set of styles that can interrupt, but the interrupted element again
   *         doesn't get to control that.
   *
   * todo![docs, spec, interruption] move the above into ptss docs or test cases.
   *   dev strategy 🌶:
   *    - STOP TRYING TO DO ALL THIS IN YOUR HEAD, IMAGINING ALL THE PERMUTATIONS.
   *      Instead: create test cases that cover all the permutation, and let those
   *      drive the code, parsing principles and the PTSS spec.
   *      - Gracedown.ptss & RubyRhod.ptss
   *      - MarkdownHS.ptss
   *        -- This can do better than GFM/CommonMark, and *disregard their rules
   *           when they clearly violate what the human eye sees*.
   *           📥 Do I have this documented as MarkdownHS's purpose?
   *      - PlainJane.ptss
   */
  checkStyleMatch(styles) {
    const checkpoint = this.checkpoint();
    for (const style of styles) {
      const r = style.parse(this, null, true);
      checkpoint.restore();
      if (r !== null) {
        return true;
      }
    }
    return false;
  }
};
function fwdBlock(startLine, stopOnBlank, stopOnPattern) {
  let content = "";
  let line = startLine;
  for (; ; ) {
    const s = line.remainingSlice();
    content += s;
    if (stopOnPattern) {
      stopOnPattern.lastIndex = 0;
      if (stopOnPattern.test(s)) {
        break;
      }
    }
    const nextLine = line.nextInContainer;
    if (nextLine === null || stopOnBlank && nextLine.remainingIsBlank() || nextLine.pContainerBottomBorder !== null) {
      break;
    }
    line = nextLine;
  }
  return [content, line];
}
function fwdChunkToTailOrBlank(startLine, indent, tailPattern, blankAfterTail = true, bodyPattern, maxLines = Number.MAX_VALUE, allowedInterruptions = void 0, sloppyMargin = 0, allowLazy = false) {
  let body = "";
  let bodyMatch;
  let tailMatch = null;
  const checkpoints = [];
  const firstRemaining = startLine.remainingSlice();
  let lastLine = startLine;
  if (tailPattern) {
    tailPattern.lastIndex = 0;
    tailMatch = tailPattern.exec(firstRemaining);
    if (tailMatch) {
      const b4tail = firstRemaining.slice(0, tailMatch.index);
      if (b4tail.length > 0) {
        body += b4tail;
      }
    }
  }
  let i = 1;
  if (!tailMatch) {
    body += firstRemaining;
    for (; i < maxLines; i++) {
      const line = lastLine.getNextInContainer(allowLazy);
      if (line === null || line.remainingIsBlank() || line.pContainerBottomBorder !== null) {
        break;
      }
      if (sloppyMargin > 0 || indent > 0) {
        const cp = line.checkpoint();
        line.parseSlop(sloppyMargin, true);
        if (line.parseSpaces(indent) < indent) {
          cp.restore();
          break;
        }
        checkpoints.push(cp);
      }
      const s = line.remainingSlice();
      if (tailPattern) {
        tailPattern.lastIndex = 0;
        tailMatch = tailPattern.exec(s);
        if (tailMatch) {
          const b4tail = s.slice(0, tailMatch.index);
          lastLine = line;
          if (b4tail.length > 0) {
            body += b4tail;
          }
          break;
        }
      }
      if (allowedInterruptions && line.checkStyleMatch(allowedInterruptions)) {
        break;
      }
      body += s;
      lastLine = line;
    }
  }
  if (i === maxLines) {
    restoreCheckpoints(checkpoints);
    return null;
  }
  if (tailPattern) {
    if (tailMatch === null || blankAfterTail && lastLine.nextInContainer && !lastLine.nextInContainer.remainingIsBlank()) {
      restoreCheckpoints(checkpoints);
      return null;
    }
  }
  if (bodyPattern) {
    bodyPattern.lastIndex = 0;
    bodyMatch = bodyPattern.exec(body);
    if (!bodyMatch) {
      restoreCheckpoints(checkpoints);
      return null;
    }
  } else {
    bodyMatch = [body];
  }
  return [bodyMatch, tailMatch, lastLine];
}
function fwdChunkToBodyMatch(startLine, bodyPattern, indent, maxLines = Number.MAX_VALUE, allowedInterruptions = void 0, sloppyMargin = 0, allowLazy = false) {
  let content = startLine.remainingSlice();
  const lines = [startLine];
  const offsets = [0];
  const checkpoints = [null];
  let line = startLine;
  for (let i2 = 1; i2 < maxLines; i2++) {
    line = line.getNextInContainer(allowLazy);
    if (line === null || line.remainingIsBlank() || line.pContainerBottomBorder !== null) {
      break;
    }
    if (sloppyMargin > 0 || indent > 0) {
      const cp = line.checkpoint();
      line.parseSlop(sloppyMargin, true);
      if (line.parseSpaces(indent) < indent) {
        cp.restore();
        break;
      }
      checkpoints.push(cp);
    } else if (allowedInterruptions && line.checkStyleMatch(allowedInterruptions)) {
      break;
    } else {
      checkpoints.push(null);
    }
    offsets.push(content.length);
    content += line.remainingSlice();
    lines.push(line);
  }
  bodyPattern.lastIndex = 0;
  const bodyMatch = bodyPattern.exec(content);
  if (!bodyMatch) {
    restoreCheckpoints(checkpoints);
    return null;
  }
  const len = bodyMatch[0].length;
  let i = offsets.length;
  for (; ; ) {
    if (i < 0) {
      return null;
    }
    i--;
    line = lines[i];
    if (len > offsets[i]) {
      break;
    }
    checkpoints[i]?.restore();
  }
  return [bodyMatch, null, line];
}
function restoreCheckpoints(checkpoints) {
  for (const cpt of checkpoints) {
    cpt?.restore();
  }
}

// ptss-parser/blockTreeParser.ts
var BlockTreeParser = class {
  /* the inputs */
  src;
  styleSheet;
  /* the output */
  irRoot;
  /**
   * The current line at which the next parse decision is rooted.
   *
   * It *does not necessarily* demarcate the boundary between what we've finished
   * parsing and what we have yet to parse, as there may be
   * unresolved prior lines if {@link unresolvedFrom} is set.
   */
  curLine;
  // the current non-lazy container being parsed
  curPContainer;
  rootPContainer;
  /**
   * @link{curLazyPContainer} and @link{curPContainerHasLazyLines} track
   * lazy continuation for style sheets that require it.
   *
   * todo[perf] what's the overhead for styles that don't use it?
   *
   *  @link{curLazyPContainer} represents the container that owns the
   *  unresolved back chunk because it began in this container.
   *  So it will only be non-null when:
   *   - there is an unresolved back chunk
   *   - they are NOT owned by the current non-lazy container (curContainer).
   *  @link{curLazyPContainer} may become the curContainer again if a
   *  subsequent line matching parses for the container *non-lazily*.
   *  In this case, @link{curPContainerHasLazyLines} keeps track of the fact
   *  that the container includes one or more lazy lines. This is needed as
   *  some styles my not support laziness and therefore cannot consume those
   *  lines.
   *
   * ILLUSTRATED EXAMPLE
   * -------------------
   * Given:
   *
   *    > this container
   *    has lazy
   *    > lines
   *
   * When on line 1, after parsing the `>`:
   *    curPContainer = <block quote>
   *    curLazyPContainer = null
   *    curPContainerHasLazyLines = false
   * When on line 2, after parseContinuation(curPContainer, line)
   *    curPContainer = <root>
   *    curLazyPContainer = <block quote>
   *    curPContainerHasLazyLines = false
   * When on line 3, after parseContinuation(curPContainer, line)
   *    curPContainer = <block quote>
   *    curLazyPContainer = null
   *    curPContainerHasLazyLines = true
   */
  curLazyPContainer;
  /** See explanation under @link{curLazyPContainer} */
  curPContainerHasLazyLines = false;
  //todo[parsing] redo this doc
  /**
   * backward view, unresolved lines.
   * {@link curLazyPContainer}, if it is not null, owns these lines,
   * else {@link curPContainer} owns them.
   *
   * null if there no unresolved lines.
   */
  unresolvedFrom;
  namedValues;
  constructor(src, stylesheet, rootIRElemType, namedValues) {
    this.src = src;
    this.styleSheet = stylesheet;
    this.irRoot = ContainerStyle.newRootContainer(rootIRElemType, stylesheet);
    this.rootPContainer = this.curPContainer = new ParseContainer(this.irRoot);
    this.curLazyPContainer = null;
    this.namedValues = namedValues;
    this.curLine = new Line(this.src, 1, 0, this.rootPContainer);
    this.unresolvedFrom = null;
    this.irRoot.source.lineStart = 1;
  }
  parse() {
    do {
      const line = this.curLine;
      const curPContainer = this.curPContainer;
      if (curPContainer.parent !== null) {
        parseContinuation(curPContainer, line);
      }
      if (line.pContainerBottomBorder !== null) {
        this.defaultResolveBackChunk(false, true);
        this.curPContainer = this.curLine.pContainer.parent;
        continue;
      }
      if (line.pContainer != curPContainer) {
        if (!this.hasUnresolvedBackChunk()) {
          const source = curPContainer.irContainer.source;
          if (source.lastLineBlank) {
            if (source.style?.baseType !== 2 /* Container */ || !source.style.leftBorder) {
              source.lastLineBlank = false;
              line.pContainer.irContainer.source.lastLineBlank = true;
            }
          }
        } else {
          if (this.styleSheet.lazyContinuation) {
            if (!this.curLazyPContainer) {
              this.curLazyPContainer = curPContainer;
            }
          } else {
            this.defaultResolveBackChunk(false, true);
          }
        }
        this.curPContainer = this.curLine.pContainer;
      }
      if (this.curLine.remainingIsBlank()) {
        this.defaultResolveBackChunk();
        this.curPContainer.irContainer.source.lastLineBlank = true;
        continue;
      }
      allStylesFromTop:
        for (; ; ) {
          line.parseSlop(this.styleSheet.sloppyMargin, true);
          const checkpoint = this.curLine.checkpoint();
          nextStyle:
            for (const style of this.styleSheet.blockStyles) {
              if (this.curPContainerHasUnresolvedBackChunk()) {
                if (!style.consumesBackChunk) {
                  if (!style.canInterruptParagraph) {
                    if (!(style instanceof ListStyle) || !style.canInterruptParaWithinList || this.rootPContainer.openList === null) {
                      continue nextStyle;
                    }
                  }
                }
              }
              if ((this.curLazyPContainer !== null || this.curPContainerHasLazyLines) && style instanceof ChunkStyle && style.consumesBackChunk && !style.lazyContinuation) {
                continue nextStyle;
              }
              if (this.hasUnresolvedBackChunk() && !style.consumesBackChunk && this.styleSheet.lazyContinuation && !style.canInterruptLazy) {
                continue nextStyle;
              }
              switch (this.tryBlockStyle(style)) {
                case 0 /* NO_MATCH */:
                  checkpoint.restore();
                  continue nextStyle;
                case 1 /* MATCHED_PARTIAL_LINE */:
                  if (line.remainingIsBlank()) {
                    break allStylesFromTop;
                  }
                  continue allStylesFromTop;
                case 2 /* MATCHED_TO_EOL */:
                  break allStylesFromTop;
              }
            }
          this.leaveCurLineUnresolved();
          break;
        }
    } while (this.advance());
    this.defaultResolveBackChunk(true, true);
    return this.irRoot;
  }
  /**
   * Advance to next line.
   *
   * @returns false if no more lines
   */
  advance() {
    if (this.curLine.next === null) {
      return false;
    }
    this.curLine = this.curLine.next;
    return true;
  }
  tryBlockStyle(blockStyle) {
    switch (blockStyle.baseType) {
      case 1 /* Chunk */:
        return this.tryChunkStyle(blockStyle);
      case 2 /* Container */:
        return this.tryContainerStyle(blockStyle);
      case 3 /* List */:
        return this.tryListStyle(blockStyle);
      case 4 /* Table */:
        return this.tryTableStyle(blockStyle);
      case 5 /* TEMP_HTML_HACK */:
        return this.tryHTMLBlockStyle(blockStyle);
    }
  }
  tryChunkStyle(chunkStyle) {
    const result = chunkStyle.parse(
      this.curLine,
      this.curPContainerHasUnresolvedBackChunk() ? this.unresolvedFrom : null
    );
    if (!result) {
      return 0 /* NO_MATCH */;
    }
    if (result.startLine && result.endLine) {
      if (result.startLine.num < this.curLine.num) {
        this.clearUnresolvedBackChunk();
      } else if (result.startLine.num === this.curLine.num) {
        this.defaultResolveBackChunk();
      }
    } else {
      throw new Error("start and end line expected from chunkStyle.parse");
    }
    this.curLine = result.endLine;
    const irBlock = result.irBlock;
    if (irBlock) {
      if (irBlock.type === "section") {
        this.curPContainer.appendSection(irBlock);
      } else {
        this.curPContainer.append(irBlock);
      }
    }
    if (result.ptNamedValue) {
      if (this.namedValues.define(result.ptNamedValue, this.curPContainer.tip())) {
      } else {
      }
    }
    return 2 /* MATCHED_TO_EOL */;
  }
  tryContainerStyle(containerStyle) {
    const result = containerStyle.parse(
      this.curLine,
      this.curPContainerHasUnresolvedBackChunk() ? this.unresolvedFrom : null
    );
    if (!result) {
      return 0 /* NO_MATCH */;
    }
    this.defaultResolveBackChunk();
    this.curLine = result.endLine;
    const irBlock = result.irBlock;
    this.curPContainer.append(irBlock);
    if (result.ptNamedValue) {
      if (this.namedValues.define(result.ptNamedValue, this.curPContainer.tip())) {
      } else {
      }
    }
    let retVal;
    if (containerStyle.body === "BLOCKS" || containerStyle.body === "INLINE_OR_BLOCKS") {
      this.addNewSubPContainerToLineAndTree(irBlock);
      if (this.curLine.ptr === this.curLine.EOL) {
        retVal = 2 /* MATCHED_TO_EOL */;
      } else {
        retVal = 1 /* MATCHED_PARTIAL_LINE */;
      }
    } else {
      retVal = 2 /* MATCHED_TO_EOL */;
      if (this.curLine.next && this.curLine.next.pContainerBottomBorder !== null) {
        this.curLine = this.curLine.next;
      }
    }
    return retVal;
  }
  tryListStyle(listStyle) {
    const firstLine = this.curLine;
    const result = listStyle.parse(
      firstLine,
      this.curPContainerHasUnresolvedBackChunk() ? this.unresolvedFrom : null
    );
    if (!result) {
      return 0 /* NO_MATCH */;
    }
    this.defaultResolveBackChunk();
    const irListItem = result.irBlock;
    this.curPContainer.appendListItem(irListItem, result.irNewList);
    this.addNewSubPContainerToLineAndTree(irListItem);
    return 1 /* MATCHED_PARTIAL_LINE */;
  }
  tryTableStyle(tableStyle) {
    const result = tableStyle.parse(
      this.curLine,
      this.curPContainerHasUnresolvedBackChunk() ? this.unresolvedFrom : null
    );
    if (!result) {
      return 0 /* NO_MATCH */;
    }
    this.defaultResolveBackChunk();
    this.curLine = result.endLine;
    const irBlock = result.irBlock;
    this.curPContainer.append(irBlock);
    return 2 /* MATCHED_TO_EOL */;
  }
  tryHTMLBlockStyle(htmlBlockStyle) {
    const result = htmlBlockStyle.parse(this.curLine, this.unresolvedFrom);
    if (!result) {
      return 0 /* NO_MATCH */;
    }
    this.defaultResolveBackChunk();
    this.curLine = result.endLine;
    const irBlock = result.irBlock;
    this.curPContainer.append(irBlock);
    return 2 /* MATCHED_TO_EOL */;
  }
  addNewSubPContainerToLineAndTree(containerElem) {
    this.curPContainer = new ParseContainer(containerElem, this.curPContainer);
    this.curLine.pContainer = this.curPContainer;
  }
  /**
   * to be called when we give up on the curLine, and before calling
   * advance() to proceed to the next line.
   */
  leaveCurLineUnresolved() {
    if (this.unresolvedFrom === null) {
      this.unresolvedFrom = this.curLine;
    } else {
    }
    if (this.curLazyPContainer) {
      this.curPContainer = this.curLazyPContainer;
      this.curPContainerHasLazyLines = true;
      this.curLazyPContainer = null;
    }
    if (this.curPContainer.openList !== null) {
    }
    this.curPContainer.openList = null;
  }
  hasUnresolvedBackChunk() {
    return this.unresolvedFrom !== null;
  }
  clearUnresolvedBackChunk() {
    this.unresolvedFrom = null;
    this.curLazyPContainer = null;
    this.curPContainerHasLazyLines = false;
  }
  //todo[perf] as paragraphs are the most common, optimizing them may be
  //  worthwhile. Possibilities:
  //    - Have a *virtual* built-in default style, that if not overridden, is
  //      applied. Constructing the IR node for this style is fast, not
  //      using ptss.Expressions.
  //    - since most paragraphs are at the root, there is no need to extract
  //      lines from src as we do, only to concatenate them here.
  defaultResolveBackChunk(includeCurLine = false, containerIsClosing = false) {
    if (this.hasUnresolvedBackChunk()) {
      const [content, lineStart, lineEnd, pContainer] = this.getUnresolvedBackChunkAndContainer(includeCurLine);
      if (pContainer !== this.curPContainer) {
        containerIsClosing = true;
      }
      if (containerIsClosing && (pContainer.irContainer.source?.style).body === "INLINE_OR_BLOCKS" && pContainer.irContainer.body === void 0) {
        evalIRBlockPropertyExpr(
          {
            body: new Expression(["parseInlines", ["body"]])
          },
          pContainer.irContainer,
          null,
          null,
          [content],
          null,
          null
        );
      } else {
        const defaultBlockStyle = this.styleSheet.defaultBlockStyle;
        const ptBlock = new Block2(defaultBlockStyle);
        ptBlock.lineStart = lineStart;
        ptBlock.lineEnd = lineEnd;
        const irNode = new Block("default");
        evalIRBlockPropertyExpr(defaultBlockStyle.irNode, irNode, null, null, [content], null, null);
        irNode.source = ptBlock;
        pContainer.append(irNode);
      }
      this.clearUnresolvedBackChunk();
    }
  }
  curPContainerHasUnresolvedBackChunk() {
    return this.curLazyPContainer === null && this.unresolvedFrom !== null;
  }
  /**
   * Returns unresolved lines ONLY if they belong to *the
   * current container*.
   *
   * If the lines are consumed, caller is responsible for setting:
   *     this._unresolvedBackChunk = null
   *     this._currentLineUnresolved = false
   *
   * (I can't think of a case where a partial resolve
   * makes sense, forcing the default resolution on
   * earlier lines. We can change this later.)
   */
  curPContainerUnresolvedFrom() {
    if (this.curLazyPContainer) {
      return null;
    }
    return this.unresolvedFrom;
  }
  /**
   * Returns the unresolved back chunk and the container to which it would belong if it
   * were to be resolved now. It doesn't necessarily belong to the current container;
   * if the stylesheet includes lazy continuation, it might belong to a lazily continuing
   * container.
   */
  getUnresolvedBackChunkAndContainer(includeCurLine = false) {
    if (this.unresolvedFrom === null) {
      return ["", -1, -1, this.rootPContainer];
    }
    const c = this.curLazyPContainer ? this.curLazyPContainer : this.curPContainer;
    if (c === this.rootPContainer && this.curLazyPContainer === null) {
      if (includeCurLine) {
        return [
          this.src.slice(this.unresolvedFrom.SOL, this.curLine.EOL),
          this.unresolvedFrom.num,
          this.curLine.num,
          c
        ];
      } else {
        return [
          this.src.slice(this.unresolvedFrom.SOL, this.curLine.SOL),
          this.unresolvedFrom.num,
          this.curLine.num - 1,
          c
        ];
      }
    }
    let l = this.unresolvedFrom;
    let s = "";
    while (l.num < this.curLine.num) {
      s += l.remainingSlice();
      l = l.next;
    }
    if (includeCurLine) {
      s += this.curLine.remainingSlice();
    }
    const lineStart = this.unresolvedFrom.num;
    const lineEnd = includeCurLine ? this.curLine.num : this.curLine.num - 1;
    return [s, lineStart, lineEnd, c];
  }
};

// ptss-parser/namedValues.ts
var NamedValues = class {
  /**
   * The structure of the index enforces these namespace rules:
   * - each unique name (sans any path prefix) can only be assigned
   *   to exactly one of the following:
   *   - an HREF value
   *   - a synonym
   *   - one or more content elements, where each content element with
   *     the same name is the only one with that name in its immediate
   *     containing section. In other words, a name can be associated
   *     with multiple content elements as long as each has a unique
   *     *section path*.
   *
   *     todo![now, references] multiple sections sharing the same name
   *      is legit, but does it make sense for other elements? Can
   *      two named inlines (e.f. key words), have the same name?
   *      OPTIONS:
   *      - leave it to the content author. If it doesn't make sense to
   *        have multiple non-sections share a name, even if in separate
   *        parent sections, they can see that. PTSS will just warn/error/skip
   *        as it does for duplicate section names.
   *      - have distinct rules for sections vs other elements, and change
   *        the structure below.
   *      - let the style sheet define the rules.
   */
  index = {};
  /**
   *
   * @return whether or not the definition is recognized.
   *
   * todo![now, references] this value currently being passed in for
   *   section is the immediate parent, whether or not it is a section.
   *   Need to decide what is actually correct, and either pass in a
   *   section or change the name of this param.
   */
  define(nv, section) {
    let existing = this.index[nv.name];
    if (nv.value.type === "element") {
      const { path, sectioningRoot } = idPath(section);
      if (sectioningRoot !== void 0) {
        return false;
      }
      const id = path ? path + "/" + nv.name : nv.name;
      if (existing === void 0) {
        existing = { type: "pathed elements", map: {} };
        existing.map[id] = nv.value;
        this.index[nv.name] = existing;
      } else if (existing.type !== "pathed elements") {
        throw new Error(`PTSS Named Value TYPE collision on ${nv.name}: ${existing.type} and ${nv.value.type}`);
      } else {
        if (id in existing.map) {
          return false;
        }
        existing.map[id] = nv.value;
      }
      nv.value.element.id = id;
    } else {
      if (this.index[nv.name]) {
        return false;
      }
      this.index[nv.name] = nv.value;
    }
    return true;
  }
  valueFor(name) {
    const v = this.index[normalizeName(name)];
    if (v === void 0) {
      return void 0;
    }
    if (v.type === "pathed elements") {
      if (name in v.map) {
        return v.map[name];
      }
      if (Object.keys(v.map).length === 1) {
        return v.map[Object.keys(v.map)[0]];
      }
      return void 0;
    }
    return v;
  }
  toString() {
    let s = "";
    const sorted = Object.entries(this.index).sort((a, b) => a[0].localeCompare(b[0]));
    for (const [name, val] of sorted) {
      if (val.type === "pathed elements") {
        s += `${name}: `;
        s += "\n";
        for (const path in val.map) {
          s += `  ${path} \u279E `;
          s += stringifyValue(val.map[path]);
          s += "\n";
        }
      } else {
        s += stringifyNameAndValue(name, val);
        s += "\n";
      }
    }
    return s;
  }
};

// ptss-parser/ptss/expression.ts
function expressionError(msg) {
  throw new Error(`Expression Error: ${msg}`);
}
var INLINE_PARSE_FLAG = "\u{1F17F}\uFE0Farse\u{1F6A9}";
function evaluateExpression(expression, headMatch, tailMatch, bodyMatch, markerMatch, righterMatch) {
  if (!Array.isArray(expression)) {
    return expression;
  }
  const func = expression[0];
  if (func === "if") {
    if (expression.length < 4) {
      expressionError(`'if' expression requires 3 args. There are ${expression.length - 1}.`);
    }
    let value2;
    if (evaluateExpression(expression[1], headMatch, tailMatch, bodyMatch, markerMatch, righterMatch)) {
      value2 = evaluateExpression(expression[2], headMatch, tailMatch, bodyMatch, markerMatch, righterMatch);
    } else {
      value2 = evaluateExpression(expression[3], headMatch, tailMatch, bodyMatch, markerMatch, righterMatch);
    }
    return value2;
  }
  const args = [];
  for (let i = 1; i < expression.length; i++) {
    args.push(evaluateExpression(expression[i], headMatch, tailMatch, bodyMatch, markerMatch, righterMatch));
  }
  let value = void 0;
  switch (func) {
    case "head":
      if (headMatch) {
        if (expression[1]) {
          value = headMatch[expression[1]];
        } else {
          value = headMatch[0];
        }
      } else {
        value = void 0;
      }
      break;
    case "tail":
      if (tailMatch) {
        if (expression[1]) {
          value = tailMatch[expression[1]];
        } else {
          value = tailMatch[0];
        }
      } else {
        value = void 0;
      }
      break;
    case "body":
      if (bodyMatch) {
        if (expression[1]) {
          value = bodyMatch[expression[1]];
        } else {
          value = bodyMatch[0];
        }
      } else {
        value = void 0;
      }
      break;
    case "marker":
      if (markerMatch) {
        if (expression[1]) {
          value = markerMatch[expression[1]];
        } else {
          value = markerMatch[0];
        }
      } else {
        value = void 0;
      }
      break;
    case "righter":
      if (righterMatch) {
        if (expression[1]) {
          value = righterMatch[expression[1]];
        } else {
          value = righterMatch[0];
        }
      } else {
        value = void 0;
      }
      break;
    case "length":
      value = args[0].length;
      break;
    case "at":
      value = args[0].at(args[1]);
      break;
    case "trim":
      value = args[0]?.trim();
      break;
    case "map":
      value = args[1][args[0]];
      break;
    case "match":
      value = args[0].match(args[1]);
      break;
    case "replace":
      value = args[0].replace(args[1], args[2]);
      break;
    case "escape":
      value = escapeText(args[0]);
      break;
    case "unescape":
      value = unescapeString(args[0]);
      break;
    case "first":
      for (let i = 0; i < args.length; i++) {
        if (args[i] !== void 0) {
          value = args[i];
          break;
        }
      }
      break;
    case "concat":
      value = "";
      for (let i = 0; i < args.length; i++) {
        value += args[i];
      }
      break;
    case "parseInlines":
      if (args[0] !== void 0) {
        value = [INLINE_PARSE_FLAG, ...args];
      } else {
        value = void 0;
      }
      break;
    case "parseBlocks":
      if (args[0] !== void 0) {
        const stylesheet = args[1];
        const rootType = args.length > 2 ? args[2] : "dummy";
        const btp = new BlockTreeParser(args[0], stylesheet, rootType, new NamedValues());
        const root = btp.parse();
        value = rootType === "dummy" ? root.body : root;
      } else {
        value = void 0;
      }
      break;
    default:
      if (args.length === 0) {
        value = func;
      } else {
        expressionError(`unrecognized expression function: ${func}`);
      }
  }
  return value;
}
var Expression = class {
  exp;
  constructor(exp) {
    this.exp = exp;
  }
  //todo![arch, spec, expressions] if we need to add ANY more to this list,
  //  switch to a map to allow arbitrary named variables to be passed in
  //  and referenced by expressions.
  evaluate(headMatch, tailMatch, bodyMatch, markerMatch, righterMatch) {
    return evaluateExpression(this.exp, headMatch, tailMatch, bodyMatch, markerMatch, righterMatch);
  }
  toString() {
    return JSON.stringify(this.exp, stringifyReplacerForDebugLogging());
  }
};

// ptss-parser/ptss/containerStyle.ts
var reIndentContainerTrailHack = /(\n *)*$/;
var ContainerStyle = class {
  baseType = 2 /* Container */;
  name;
  indent = "no";
  mmIndentMin = -1;
  mmIndentMax = -1;
  hangingIndent = "no";
  hangingIndentRequired = false;
  marker;
  //todo![now] i don't like this inconsistency where here we are using `null`
  //  go back to `undefined` , and for bottomBorder have 'match top' mean that.
  topBorder = null;
  // bottomBorder:
  // - null means: *there is no bottom border*.
  //   - explicitly disable bottom border by setting it to '' (null for now).
  //     If disabled, at least left border or indent must be specified, otherwise
  //     there would be no terminal condition for the block.
  // - undefined means: must match top border
  // - otherwise an string representing the set of characters allowed for the border.
  bottomBorder = void 0;
  //todo[spec, docs, markdown flaws] CommonMark's allowing a Setext underline
  // of a single character is rather dumb. Even two character borders or underlines
  // is making a lot of people pay for the laziness of a few, and oh, look at
  // this level of laziness! PTSS should be designed somehow to encourage
  // good design and discourage bad, starting with defaults. And maybe a
  // a stylesheet setting such as an explicit `natural` declaration that
  // imposes stricter rules?
  topBorderMinLength = 8;
  //more dynamic rules (e.g. min length relative to content) via property expressions?
  topBorderMaxLength = 120;
  leftBorder = null;
  // Padding is ALWAYS at most one space, otherwise there's too much
  // ambiguity between padding and indent.
  // - 'per first line' means the first line determines padding. This means that
  //    if the first line has padding, and a subsequent line does not, the
  //   left border container will terminate, and potentially a new, zero
  //   padding container will start.
  // - 'sloppy' is Markdown's way, which means padding is optional on a line-by-line
  // basis, resulting in odd (bad) behavior (described in the docs)
  leftPadding;
  righter = null;
  /**
   *
   * Source Container Content Models
   * ===============================
   * (distinct from and independent of target STIR element content model)
   *
   * INLINE_OR_BLOCKS
   * ------
   * InlineSequence | BlockSequence
   *
   * If the content of the container is a single chunk, it will be treated
   * as an InlineSequence.
   *
   * BLOCKS
   * ------
   * BlockSequence
   *
   * RAW
   * ---
   * The term `RAW` is better than `LITERAL` because the raw source
   * might be taken literally, or it might not (e.g. it might be
   * inline parsed, or otherwise manipulated). This way we avoid confusion.
   * One describes how to parse the source, and the other describes the
   * semantics of the source.
   *
   * We may update the Content Model types to include a `LITERAL`, which would
   * be a shortcut way to say `RAW` and then copy it directly to the STIR
   * body with no manipulation. We'd only do that if it were a common enough
   * thing to give it special terse expression.
   *
   * The extracted raw text will NOT include a trailing newline, as depicted
   * below. The trailing newline is considered an artifact of the form (the
   * bottom border cannot exist on the same line as the last line of content.
   * Another reason, is for consistency guarantees for semantically equivalent
   * content: a container terminated by a bottom border, a parent container
   * EOC, or EOF should be identical. Downstream processing shouldn't have to
   * deal with the uncertainly, have if-else logic, etc.
   *
   * IF the style needs the trailing newline, it can use `RAW_NL` instead.
   * See below.
   *
   * This:
   *   ~~~~~~~~~~~~~~~~~~ markdown
   *   ``````````````
   *   <-- from here \n
   *      to here -->\n
   *   ``````````````
   *   ~~~~~~~~~~~~~~~~~~
   * yields: '<-- from here \n   to here -->'
   *
   * and this:
   *   ~~~~~~~~~~~~~~~~~~ markdown
   *   ``````````````
   *        \n
   *   ``````````````
   *   ~~~~~~~~~~~~~~~~~~
   * yields: '     '
   *
   * and this:
   *   ~~~~~~~~~~~~~~~~~~ markdown
   *   ``````````````
   *   \n
   *   ``````````````
   *   ~~~~~~~~~~~~~~~~~~
   * yields: ''
   *
   * RAW_NL
   * ------
   * Same as RAW but includes trailing newline (guaranteed, even at EOF).
   * We may nix this and just have style that need it append a newline to
   * the body via PTSS Expression.
   *
   * Regex
   * -----
   * entire match available as expression: ['body']
   * match groups available by index, e.g.: ['body' 2]
   *
   *
   * @type {'INLINE_OR_BLOCKS' | 'BLOCKS' | 'RAW' | 'RAW_NL' | RegExp}
   *
   * todo![spec, ptss, dsl, composition] Would it be more elegant and consistent
   *  if we nixed 'BLOCKS' and replace it with the following?
   *  ```
   *  body = 'RAW' | 'RAW_NL' | RegExp = 'RAW'
   *  irNode.body = ['parseBlocks' ['body'] ...]
   *  ```
   *  and also nixed 'RAW_NL' as suggested above.
   *  - - -
   *  PERHAPS THE ANSWER IS "NO".
   *  ==KEY PRINCIPLE==:
   *     - this `body` field makes a declaration ABOUT THE PLAIN TEXT SOURCE ELEMENT'S BODY
   *     - irNode.body makes a declaration ABOUT THE OUTPUT STIR ELEMENT'S BODY
   *  Thoughts, given this principle:
   *  - keep 'BLOCKS'. It means "the source body is composed of block
   *    elements as defined by this style sheet. In other words, this is a
   *    point of style sheet recursion."
   *  - - -
   *  HOW DOES COMPOSITION FIT IN?
   *  ```
   *  body = [
   *    $block(heading),
   *    'BLOCKS',
   *    $block('Thematic Break'),
   *    $block('paragraph')
   *  ]
   *  irNode.title = ['body', 1]
   *  irNode.body = ['body', 2]
   *  irNode.footer = ['body', 4]
   *  ```
   *  or we could use names (and we'd do the same with Regex groups):
   *  ```
   *  body = {
   *    heading: $block(heading),
   *    body: 'BLOCKS',
   *    divider: $block('Thematic Break'),
   *    footer: $block('paragraph')
   *  }
   *  irNode.title = ['body', 'heading']  // STIR title <= this PTSS element's "heading" <= PTSS container body element 1.
   *  irNode.body = ['body', 'body']      // STIR body <= this PTSS element's "body" <= PTSS container body elements 2 thru n-2.
   *  irNode.footer = ['body', 'footer']  // STIR footer <= this PTSS element's "footer" <= PTSS container body elements n.
   *  ```
   */
  body = "INLINE_OR_BLOCKS";
  //todo[spec] better to default RAW?.
  //todo[spec] support minLines OR allowZeroLineContainers
  //   See case files for examples/visual analysis.
  //   - if we have the minLine rule, we'd have to parse ahead to
  //     make sure we have min lines. BUT CAN WE DO THIS without
  //     having to parse the contents normally, (which we can't do
  //     within `parse`, only BlockTreeParser can do that) and
  //     then we'd have to back out all the parsing state changes
  //     if min lines fails. LIKELY CRAZY COMPLEX.
  //   - fuck `minLines`. There is no need to support any minLines
  //     value greater than one, so we should just do
  //     `allowZeroLineContainers`, in which case we only have to
  //     look one line ahead, and we can do that immediately within
  //     parse open, and existing Line checkpointing is more than
  //     sufficient. In fact, all we have to do is make sure the
  //     next line isn't a bottom border or end of parent container!
  /** One instance of continues func to be shared by all occurrences of this style. */
  // initialize with non-null default to avoid null check
  continues = () => false;
  canInterruptParagraph = true;
  canInterruptLazy = true;
  consumesBackChunk = false;
  styleSheet;
  // property expressions
  _irNode;
  _ptNamedValue;
  constructor(name, styleSheet) {
    this.name = name;
    this.styleSheet = styleSheet;
  }
  get irNode() {
    if (this._irNode === void 0) {
      this._irNode = {};
    }
    return this._irNode;
  }
  set ptNamedValue(value) {
    this._ptNamedValue = value;
  }
  initAndValidate() {
    if (this._ptNamedValue?.value === "self" && this._irNode === void 0) {
      throw new Error(`ptNamedValue.value is set to ${this._ptNamedValue.value} but the style is not configured to generate one`);
    }
    const markdownIndentMatch = RE_MARKDOWN_INDENT.exec(this.indent);
    if (!markdownIndentMatch && this.topBorder === null && this.leftBorder === null && this.indent !== "yes" && this.hangingIndent === "no") {
      throw new Error("invalid container style: no definitive container delimiter(s)");
    }
    if (markdownIndentMatch) {
      this.mmIndentMin = Number.parseInt(markdownIndentMatch[1]);
      if (this.mmIndentMin < 0) {
        throw new Error("invalid container style: indent min cannot be negative");
      }
      if (this.mmIndentMin <= this.styleSheet.sloppyMargin) {
        throw new Error("invalid container style: indent min must be greater than allowed sloppy margin");
      }
      this.mmIndentMax = Number.parseInt(markdownIndentMatch[2]);
      if (this.mmIndentMax < this.mmIndentMin) {
        throw new Error("invalid container style: indent max must be at least indent min");
      }
    }
    if (this.topBorder) {
      if (this.bottomBorder === null && this.leftBorder === null && this.indent !== "yes" && this.mmIndentMin < 1) {
        throw new Error("invalid container style: disabling bottom border without specifying a left border or indent results in no terminal condition");
      }
    }
    if (this.leftBorder) {
      if (!this.leftPadding) {
        throw new Error("invalid container style: leftPadding must be specified for left border");
      }
    } else if (this.leftPadding) {
      throw new Error("invalid container style: leftPadding only makes sense if there is a left border");
    }
    if (this.righter && !this.topBorder) {
      throw new Error("invalid container style: righter only support with top border");
    }
    if (this.hangingIndent !== "no") {
      if (this.topBorder !== null || this.leftBorder !== null || this.bottomBorder) {
        throw new Error("invalid container style: hanging indent containers cannot have any borders");
      }
      const noMaterialMarker = this.marker === void 0 || this.marker.test("") || this.marker.test(" ") || this.marker.test("	");
      if (this.hangingIndent === "marker") {
        if (noMaterialMarker) {
          throw new Error("invalid container style: hangingIndent is 'marker' but no valid marker is defined");
        }
      } else if (this.hangingIndent === "auto") {
      } else if (!(this.hangingIndent > 1)) {
        throw new Error("invalid container style: invalid hangingIndent declaration");
      }
      if (this.canInterruptParagraph && noMaterialMarker) {
        throw new Error("invalid container style: unmarked hanging indent containers cannot interrupt");
      }
    }
    if (this._irNode === void 0) {
      throw new Error("invalid container style: target irNode node not defined");
    }
    if (this._irNode.type === void 0) {
      throw new Error("invalid container style: target irNode node type not specified");
    }
    if (Object.values(this._irNode).filter((s) => JSON.stringify(s).indexOf("body") > -1).length === 0) {
      this._irNode.body = new Expression(["body", 0]);
    }
    this.continues = sourceContinuesFunc();
  }
  /**
   * RETURN CASES:
   *  - NO TOP BORDER, NO HEADER
   *    - "open" IR Node with continues method
   *    - endLine === curLine
   *    - endLine PARTIALLY consumed
   *  - NO TOP BORDER, WITH HEADER
   *    - "open" IR Node with continues method
   *    - endLine >= curLine (depends on how many lines header consumed)
   *    - endLine FULLY consumed (unless we decide to support partial width header)
   *  - TOP BORDER, NO HEADER
   *    - "open" IR Node with continues method
   *    - endLine === curLine
   *    - endLine FULLY consumed
   *  - TOP BORDER, WITH HEADER
   *    - "open" IR Node with continues method
   *    - endLine > curLine
   *    - endLine FULLY consumed (unless we decide to support partial width header)
   *  - LITERAL CONTENT MODEL
   *    - "closed" IR Node. NO continues method
   *    - endLine > curLine
   *
   *  BOTTOM BORDER is handled by the continues method except in the case of
   *  LITERAL CONTENT MODEL.
   */
  parse(firstLine, fromBackLine, lookahead = false) {
    const src = firstLine.src;
    let endLine = firstLine;
    let indent;
    if (this.mmIndentMin !== -1) {
      indent = firstLine.parseSpaces(this.mmIndentMax);
      if (indent < this.mmIndentMin) {
        return null;
      }
    } else {
      indent = firstLine.parseSpaces();
      if (indent === 0 && this.indent === "yes") {
        return null;
      }
      if (indent > 0 && this.indent === "no") {
        return null;
      }
    }
    let successiveSloppiness;
    if (this.leftBorder) {
      successiveSloppiness = this.styleSheet.sloppyMargin;
    } else if (indent > 0 || this.hangingIndent !== "no") {
      successiveSloppiness = 0;
    } else {
      successiveSloppiness = firstLine.pContainerSlop;
    }
    let topBorderChar;
    let topLength = 0;
    let leftBorderChar;
    let bottomBorderChar;
    let marker;
    let hangingIndent = 0;
    let padding;
    let markerMatch = null;
    let righterMatch = null;
    if (this.topBorder) {
      for (const c of this.topBorder) {
        topLength = firstLine.parseChars(c);
        if (topLength > 0) {
          if (topLength < this.topBorderMinLength) {
            return null;
          }
          if (topLength > this.topBorderMaxLength) {
            return null;
          }
          topBorderChar = c;
          break;
        }
      }
      if (topBorderChar === void 0) {
        return null;
      }
      if (this.righter) {
        this.righter.lastIndex = firstLine.ptr;
        righterMatch = this.righter.exec(src);
        if (!righterMatch) {
          return null;
        }
        if (righterMatch.index !== firstLine.ptr) {
          throw new Error("righter pattern failed to match match all content after top border.");
        }
        firstLine.ptr += righterMatch[0].length;
      }
      if (lookahead) {
        return {};
      }
      if (this.leftBorder) {
        leftBorderChar = this.leftBorder;
        switch (this.leftPadding) {
          case "yes":
            padding = true;
            break;
          case "no":
            padding = false;
            break;
          case "per first line":
            padding = true;
            break;
          case "sloppy":
            firstLine.parseSpaces(1);
            break;
          default:
            throw new Error("invalid style declaration");
        }
      }
      switch (this.bottomBorder) {
        case void 0:
          bottomBorderChar = topBorderChar;
          break;
        case null:
          bottomBorderChar = void 0;
          break;
        default:
          bottomBorderChar = this.bottomBorder;
      }
      if (!firstLine.remainingIsBlank()) {
        throw new Error("top border / right pattern failed to match match all content after top border.");
      }
    } else if (this.leftBorder) {
      leftBorderChar = src.charAt(firstLine.ptr++);
      if (leftBorderChar !== this.leftBorder)
        return null;
      switch (this.leftPadding) {
        case "yes":
          if (firstLine.parseSpaces(1) === 0) {
            return null;
          }
          padding = true;
          break;
        case "no":
          padding = false;
          break;
        case "per first line":
          padding = firstLine.parseSpaces(1) === 1;
          break;
        case "sloppy":
          firstLine.parseSpaces(1);
          break;
        default:
          throw new Error("invalid style declaration");
      }
      if (lookahead) {
        return {};
      }
    } else {
      if (this.hangingIndent === "no") {
        if (lookahead) {
          return {};
        }
      } else {
        let markerLen = 0;
        if (this.marker !== void 0) {
          this.marker.lastIndex = firstLine.ptr;
          markerMatch = this.marker.exec(src);
          if (markerMatch === null) {
            return null;
          }
          markerLen = markerMatch[0].length;
          if (src[firstLine.ptr + markerLen] !== " " && src[firstLine.ptr + markerLen] !== "	" && src[firstLine.ptr + markerLen] !== "\n") {
            return null;
          }
          if (!lookahead) {
            firstLine.ptr += markerLen;
            if (this.hangingIndent === "marker") {
              hangingIndent = firstLine.pContainerSlop + indent + markerLen + firstLine.parseSpaces();
            } else if (this.hangingIndent !== "auto") {
              firstLine.parseSpaces();
              hangingIndent = firstLine.pContainerSlop + indent + this.hangingIndent;
            }
          }
        }
        if (hangingIndent === 0 || this.hangingIndentRequired) {
          let nextLine = firstLine.nextInContainer;
          while (nextLine !== null && nextLine.remainingIsBlank()) {
            nextLine = nextLine.nextInContainer;
          }
          if (nextLine === null) {
            if (markerLen === 0 || this.hangingIndentRequired) {
              return null;
            }
            if (lookahead) {
              return {};
            }
            hangingIndent = 999;
          } else {
            const cp = nextLine.checkpoint();
            let nextIndent = nextLine.parseSpaces();
            cp.restore();
            if (this.hangingIndent === "auto") {
              if (nextIndent < firstLine.pContainerSlop + indent + 1) {
                if (markerLen === 0 || this.hangingIndentRequired) {
                  return null;
                }
                nextIndent = 999;
              }
              if (lookahead) {
                return {};
              }
              hangingIndent = nextIndent;
            } else {
              hangingIndent = firstLine.pContainerSlop + indent + this.hangingIndent;
              if (nextIndent < hangingIndent || this.hangingIndentRequired) {
                return null;
              }
              if (lookahead) {
                return {};
              }
            }
          }
          firstLine.parseSpaces();
        }
      }
    }
    const ptBlock = new Block2(this);
    ptBlock.style = this;
    ptBlock.sloppiness = successiveSloppiness;
    ptBlock.indent = hangingIndent || indent;
    ptBlock.padding = padding;
    if (topBorderChar) {
      ptBlock.topBorderChar = topBorderChar;
      ptBlock.bottomBorderChar = bottomBorderChar;
      ptBlock.topBorderLength = topLength;
    }
    ptBlock.leftBorderChar = leftBorderChar;
    ptBlock.continues = this.continues;
    ptBlock.lineStart = firstLine.num;
    const irBlock = new Block("container");
    irBlock.source = ptBlock;
    let bodyMatch = null;
    if (this.body === "BLOCKS" || this.body === "INLINE_OR_BLOCKS") {
    } else {
      let body;
      [body, endLine] = this.extractRawBody(
        firstLine,
        irBlock,
        leftBorderChar === void 0 && bottomBorderChar === void 0
      );
      if (body) {
        if (this.body === "RAW" || this.body === "RAW_NL") {
          bodyMatch = [body];
        } else {
          this.body.lastIndex = 0;
          bodyMatch = this.body.exec(body);
        }
      }
    }
    ptBlock.lineEnd = endLine.num;
    if (this._irNode !== void 0) {
      evalIRBlockPropertyExpr(this._irNode, irBlock, null, null, bodyMatch, markerMatch, righterMatch);
    }
    let ptNamedValue = void 0;
    if (this._ptNamedValue !== void 0) {
      ptNamedValue = evalPTNamedValueExpr(
        this._ptNamedValue,
        irBlock,
        null,
        null,
        bodyMatch,
        markerMatch,
        righterMatch
      );
    }
    return { irBlock, ptNamedValue, endLine };
  }
  // faster and simpler to extract raw container content here and now than leaving it to BlockTreeParser
  extractRawBody(line, irBlock, isIndentContainer) {
    line.pContainer = new ParseContainer(irBlock, line.pContainer);
    let body;
    let endLine;
    if (line.ptr === line.EOL) {
      const nextLine = line.nextInContainer;
      if (nextLine !== null && nextLine.pContainerBottomBorder === null) {
        [body, endLine] = nextLine.fwdBlock(false);
      } else {
        return ["", line];
      }
    } else {
      [body, endLine] = line.fwdBlock(false);
    }
    if (isIndentContainer) {
      if (this.body === "RAW") {
        body = body.replace(reIndentContainerTrailHack, "");
      } else {
        body = body.replace(reIndentContainerTrailHack, "\n");
      }
    } else {
      if (this.body === "RAW") {
        if (body.at(-1) === "\n") {
          body = body.slice(0, -1);
        }
      } else {
        if (body.at(-1) !== "\n") {
          body += "\n";
        }
      }
    }
    return [body, endLine];
  }
  // todo[spec] there maybe should be an explicit document style, which in most cases will
  //   always match (as the hardcoded one below does), but imagine a document style that
  //   supports optional or required front matter, or BOM chars, etc.
  static newRootContainer(rootIRElemType, ptss) {
    const ptRoot = new Block2(ptss.rootContainerStyle);
    ptRoot.continues = () => true;
    const irRoot = new Block(rootIRElemType);
    irRoot.source = ptRoot;
    return irRoot;
  }
};
function sourceContinuesFunc() {
  return function(line) {
    const ptBlock = this;
    const style = ptBlock.style;
    const indent = ptBlock.indent;
    if (line.remainingIsBlank()) {
      if (style.leftBorder !== null) {
        return false;
      }
      if (style.body === "RAW" || style.body === "RAW_NL") {
        line.parseSpaces(indent);
      }
      return true;
    }
    const src = line.src;
    const cp = line.checkpoint();
    if (indent > 0) {
      const spaces = line.parseSpaces(indent);
      if (spaces < indent) {
        cp.restore();
        return false;
      }
    } else if (ptBlock.sloppiness !== void 0 && ptBlock.sloppiness > 0) {
      line.parseSlop(ptBlock.sloppiness, style.body !== "RAW_NL");
    }
    const bottomBorderCharSet = ptBlock.bottomBorderChar;
    if (bottomBorderCharSet) {
      const bbcp = line.checkpoint();
      if (indent === 0) {
        if (line.pContainerSlop < style.styleSheet.sloppyMargin) {
          line.parseSpaces(style.styleSheet.sloppyMargin - line.pContainerSlop, true);
        }
      }
      for (const c of bottomBorderCharSet) {
        const len = line.parseChars(c);
        if (len > 0) {
          if (len >= ptBlock.topBorderLength && line.remainingIsBlank()) {
            line.pContainerBottomBorder = [];
            return true;
          }
          break;
        }
      }
      bbcp.restore();
    }
    if (style.leftBorder) {
      if (src.charAt(line.ptr) !== ptBlock.leftBorderChar) {
        cp.restore();
        return false;
      }
      line.ptr++;
      if (line.remainingIsBlank()) {
        return true;
      }
      if (ptBlock.padding === void 0) {
        line.parseSpaces(1);
      } else if (ptBlock.padding) {
        if (line.parseSpaces(1) === 0) {
          cp.restore();
          return false;
        }
      }
    }
    return true;
  };
}

// ptss-parser/ptss/listStyle.ts
var ListStyle = class {
  name;
  baseType = 3 /* List */;
  indent = "no";
  unorderedMarkers = "";
  orderedMarkers = "";
  orderedMarkerPattern = /$/;
  honorStartNum = true;
  // This is set to true, because sometimes a list can.
  // the actual parse logic may impose more restrictive logic
  // (e.g. only if the list item number is 1).
  canInterruptParagraph = true;
  canInterruptParaWithinList = true;
  canInterruptLazy = true;
  consumesBackChunk = false;
  styleSheet;
  constructor(name, styleSheet) {
    this.name = name;
    this.styleSheet = styleSheet;
  }
  /* one instance of continues func to be shared by all occurrences of this style*/
  continues = listItemContinuesFunc();
  initAndValidate() {
    const match = RE_MARKDOWN_INDENT.exec(this.indent);
    if (match) {
      throw Error(`markdown mode indent is not supported for list items`);
    }
    if (this.canInterruptParagraph && !this.canInterruptParaWithinList) {
      throw Error(`if canInterruptParagraph is set true, canInterruptParaWithinList must also be true`);
    }
    this.orderedMarkerPattern = new RegExp("(\\d{1,9})([" + this.orderedMarkers + "])", "y");
    return;
  }
  parse(firstLine, fromBackLine, lookahead = false) {
    const src = firstLine.src;
    const indent = firstLine.parseSpaces();
    if (indent === 0 && this.indent === "yes") {
      return null;
    }
    if (indent > 0 && this.indent === "no") {
      return null;
    }
    let listOrdered;
    let bulletChar;
    let delimiter;
    let startNum;
    let markerLen = 0;
    let paddingLen = 0;
    let lineContentBlank = false;
    const checkpoint = firstLine.checkpoint();
    for (const c of this.unorderedMarkers) {
      if (src[firstLine.ptr] === c) {
        bulletChar = c;
        firstLine.ptr++;
        break;
      }
    }
    if (bulletChar) {
      markerLen = bulletChar.length;
      if (firstLine.remainingIsBlank()) {
        lineContentBlank = true;
        paddingLen = 1;
        listOrdered = false;
      } else {
        paddingLen = firstLine.parseSpaces(4, true);
        if (paddingLen === 0) {
          paddingLen = firstLine.parseSpaces(1);
          if (paddingLen === 1) {
            listOrdered = false;
          }
        } else {
          listOrdered = false;
        }
      }
    }
    if (listOrdered === void 0) {
      checkpoint.restore();
      this.orderedMarkerPattern.lastIndex = firstLine.ptr;
      const match = this.orderedMarkerPattern.exec(src);
      if (match) {
        startNum = parseInt(match[1]);
        delimiter = match[2];
        markerLen = match[1].length + delimiter.length;
        firstLine.ptr += markerLen;
        if (firstLine.remainingIsBlank()) {
          lineContentBlank = true;
          paddingLen = 1;
          listOrdered = true;
        } else {
          paddingLen = firstLine.parseSpaces(4, true);
          if (paddingLen === 0) {
            paddingLen = firstLine.parseSpaces(1);
            if (paddingLen === 1) {
              listOrdered = true;
            }
          } else {
            listOrdered = true;
          }
        }
      }
    }
    if (listOrdered === void 0) {
      return null;
    }
    if (fromBackLine !== null) {
      if (startNum && startNum !== 1 || lineContentBlank) {
        return null;
      }
    }
    if (lookahead) {
      return { irNewList: void 0 };
    }
    if (lineContentBlank) {
    }
    const contentIndent = indent + firstLine.pContainerSlop + markerLen + paddingLen;
    const ptListItem = new Block2(this);
    ptListItem.style = this;
    ptListItem.lineStart = firstLine.num;
    ptListItem.lineEnd = firstLine.num;
    ptListItem.indent = indent;
    ptListItem.listContentIndent = contentIndent;
    ptListItem.continues = this.continues;
    if (lineContentBlank) {
      ptListItem.endItemIfNextLineBlank = true;
    }
    const irListItem = new Block("list_item");
    irListItem.source = ptListItem;
    let newList;
    const curList = firstLine.pContainer.openList;
    if (!curList || listOrdered !== curList.listOrdered || delimiter !== curList.source.listDelimiter || bulletChar !== curList.source.listBulletChar) {
      const ptList = new Block2(this);
      ptList.listBulletChar = bulletChar;
      ptList.listDelimiter = delimiter;
      ptList.lineStart = firstLine.num;
      ptList.lineEnd = firstLine.num;
      newList = new Block("list");
      newList.source = ptList;
      newList.listOrdered = listOrdered;
      if (listOrdered) {
        newList.listStyle = "decimal";
        if (this.honorStartNum) {
          newList.listStartNum = startNum;
        }
      }
      newList.hints["commonmark.list.tight"] = true;
    }
    return { irBlock: irListItem, ptNamedValue: void 0, endLine: firstLine, irNewList: newList };
  }
};
function listItemContinuesFunc() {
  return function(line) {
    const ptBlock = this;
    if (line.remainingIsBlank()) {
      return !ptBlock.endItemIfNextLineBlank;
    } else {
      const cp = line.checkpoint();
      const contentIndent = ptBlock.listContentIndent;
      const indent = line.parseSpaces(contentIndent);
      if (indent !== contentIndent) {
        cp.restore();
        return false;
      }
      return true;
    }
  };
}

// ptss-parser/ptss/tableStyle.ts
var TableStyle = class {
  name;
  baseType = 4 /* Table */;
  indent = "no";
  tableType = "ag";
  ///// SV table structure (TBD some fields may be shared with AG table) /////
  //todo![spec] consider making this SVTableStyle.ts, sep from AGTableStyle.ts,
  //    both a subclass of TableStyle.
  //    This is an internal breakdown, doesn't impact PTSS style settings,
  //    as the tableType value can decide which class to instantiate.
  //todo![spec, arch] possible AGTablesStyle.ts strategy:
  //  - See notes under PTSS-REF/tables_AG.html#cell-content-model
  //  - If the AG Table cell spans multiple lines, collect it into
  //    a single `\n` delimited string.
  //  - Similarly to how we tag the SV table cell content with `INLINE_PARSE_FLAG`,
  //    tag the AG table cell with `NESTED_BLOCK_SEQUENCE_PARSE_FLAG`. Later
  //    we will walk the tree and for each cell encountered with this flag we
  //    will call textplain.Parser.parse with the cell as the ir.block serving
  //    as the root container for that call.
  //  - We *could* do away with the deferred parsing for both inline and nexted
  //    block parsing simply by every place where we set one of the above flags
  //    just make the inline or block parse calls right then and there.
  heading = "none";
  headingDelim;
  //e.g. '-'
  delimIntersection;
  // e.g. '|-+', defaults to columnsDelim
  // todo![spec]: consistent border prop semantics with containerStyle?
  // if non-null, the top border will be required
  topBorder;
  // bottomBorder:
  // - null means: *there is no bottom border*.
  // - undefined means: must match top border
  // - otherwise an string representing the set of characters allowed for the border.
  bottomBorder = void 0;
  sideBorder;
  //e.g. '|'
  sideBorderLeftRule = "optional";
  sideBorderRightRule = "match";
  columnsDelim;
  //e.g. '|'
  columnsNumber = "per head delim";
  columnsAlignIndicator;
  //e.g. ':'
  bodyRowAtLeastOneMarker = "yes";
  bodyRowTooShort = "as-is";
  bodyRowTooLong = "as-is";
  cell;
  // if given, allows field values to be wrapped by the given pair of chars.
  // When so wrapped, any special chars need not be escaped. If more than one
  // quote char pair is given, use of one can allow the unescaped use of the
  // other(s). For example, if:
  //      columnsDelim  ,
  //      escapeChar    /
  //      quoteChars    ""''⎡⎦
  // all of the following are equivalent:
  //      'She said, "Hi!"'
  //      ⎡She said, "Hi!"⎦
  //      She said\, \"Hi!\"
  // todo[spec] review"
  //   https://en.wikipedia.org/wiki/Comma-separated_values
  //   https://en.wikipedia.org/wiki/Delimiter-separated_values
  //   https://en.wikipedia.org/wiki/Tab-separated_values
  quoteCharPairs;
  // todo![spec] to allow a stylesheet to achieve
  //  backward GFM compatibility.
  gfmQuirks = false;
  canInterruptParagraph = true;
  canInterruptLazy = true;
  interruptibleBy = [];
  consumesBackChunk = false;
  styleSheet;
  // property expressions
  _irNode;
  _ptNode;
  //todo![spec] start with ^ ???
  // instance copies so parse methods are reentrant
  //   for parallel executing parser instances.
  RE_H_DELIM = new RegExp("");
  RE_INTERSECTION = new RegExp("");
  //todo![spec] use style defined chars
  //todo![spec] support different sep and right border
  RE_DATA = /(?:(?:(?:\\\|)|[^|\n])*)/y;
  constructor(name, styleSheet) {
    this.name = name;
    this.styleSheet = styleSheet;
  }
  get irNode() {
    if (this._irNode === void 0) {
      this._irNode = {};
    }
    return this._irNode;
  }
  get ptNode() {
    if (this._ptNode === void 0) {
      this._ptNode = {};
    }
    return this._ptNode;
  }
  initAndValidate() {
    this.interruptibleBy = this.styleSheet.blockStyles.filter((s) => s.baseType !== 4 /* Table */);
    const match = RE_MARKDOWN_INDENT.exec(this.indent);
    if (match) {
      throw new Error(`markdown mode indent is not supported for tables`);
    }
    if (this.tableType === "sv") {
      if (this.heading.startsWith("delimited")) {
        if (this.headingDelim === void 0) {
          throw new Error(`headingDelim must be specified for heading type ${this.headingDelim}`);
        }
        if (this.columnsDelim === void 0) {
          throw new Error(`columnsDelim must be specified`);
        }
        let delimPattern = "[ \\t]*";
        if (this.columnsAlignIndicator) {
          delimPattern += `(${this.columnsAlignIndicator})?`;
        }
        delimPattern += this.headingDelim + "+";
        if (this.columnsAlignIndicator) {
          delimPattern += `(${this.columnsAlignIndicator})?`;
        }
        delimPattern += "[ \\t]*";
        this.RE_H_DELIM = RegExp(delimPattern, "y");
        let intersectionPattern = "";
        if (this.delimIntersection === void 0) {
          intersectionPattern = this.columnsDelim;
        } else if (this.delimIntersection.length === 1) {
          intersectionPattern = this.delimIntersection;
        } else {
          intersectionPattern = "[" + this.delimIntersection + "]";
        }
        this.RE_INTERSECTION = new RegExp(intersectionPattern, "y");
      } else {
        throw new Error(`table heading type "${this.heading}" not yet implemented`);
      }
      if (this.sideBorderLeftRule !== "never" && !this.sideBorder) {
        throw new Error(`side border is"${this.sideBorderLeftRule}" but sideBorder char(s) is not specified`);
      }
    } else {
      throw new Error("AG tables not yet implemented");
    }
    if (this.topBorder || this.bottomBorder) {
      throw new Error("table top/bottom border not yet implemented");
    }
  }
  parse(firstLine, fromBackLine, lookahead = false) {
    const src = firstLine.src;
    const delimLine = firstLine.nextInContainer;
    if (delimLine === null || delimLine.remainingIsBlank()) {
      return null;
    }
    const tableIndent = firstLine.parseSpaces();
    if (tableIndent === 0 && this.indent === "yes") {
      return null;
    }
    if (tableIndent > 0 && this.indent === "no") {
      return null;
    }
    const startOffset = firstLine.ptr;
    let lineIndent;
    let lineHasMarker = false;
    const delimCheckpoint = delimLine.checkpoint();
    delimLine.parseSlop(this.styleSheet.sloppyMargin, true);
    lineIndent = delimLine.parseSpaces(tableIndent);
    if (lineIndent != tableIndent) {
      delimCheckpoint.restore();
      return null;
    }
    let leftBorder = "no";
    let rightBorder = "no";
    if (this.sideBorderLeftRule !== "never") {
      if (src.charAt(delimLine.ptr) === this.sideBorder) {
        delimLine.ptr += 1;
        leftBorder = this.sideBorderLeftRule !== "lazy" ? "yes" : "lazy";
        lineHasMarker = true;
      } else {
        switch (this.sideBorderLeftRule) {
          case "always":
            delimCheckpoint.restore();
            return null;
          case "optional":
            leftBorder = "no";
            break;
          case "lazy":
            leftBorder = "lazy";
        }
      }
    }
    if (this.interruption(delimLine, lineHasMarker)) {
      delimCheckpoint.restore();
      return null;
    }
    if (this.sideBorderRightRule !== "never") {
      if (this.sideBorderRightRule === "match") {
        rightBorder = leftBorder;
      } else {
        rightBorder = "lazy";
      }
    }
    this.RE_H_DELIM.lastIndex = delimLine.ptr;
    let match = this.RE_H_DELIM.exec(src);
    if (match === null) {
      delimCheckpoint.restore();
      return null;
    }
    const cols = [match[1] === void 0 ? match[2] === void 0 ? { align: "" } : { align: "R" } : match[2] === void 0 ? { align: "L" } : { align: "C" }];
    delimLine.ptr = this.RE_H_DELIM.lastIndex;
    if (!lineHasMarker && delimLine.ptr === delimLine.EOL) {
      delimCheckpoint.restore();
      return null;
    }
    while (delimLine.ptr !== delimLine.EOL) {
      if (src.charAt(delimLine.ptr) === this.sideBorder && rightBorder !== "no" && delimLine.ptr + 1 === delimLine.EOC) {
        delimLine.ptr = delimLine.EOL;
        break;
      }
      this.RE_INTERSECTION.lastIndex = delimLine.ptr;
      if (this.RE_INTERSECTION.exec(src)) {
        this.RE_H_DELIM.lastIndex = delimLine.ptr + 1;
        match = this.RE_H_DELIM.exec(src);
        if (match === null) {
          delimCheckpoint.restore();
          return null;
        }
        cols.push(match[1] === void 0 ? match[2] === void 0 ? { align: "" } : { align: "R" } : match[2] === void 0 ? { align: "L" } : { align: "C" });
        delimLine.ptr = this.RE_H_DELIM.lastIndex;
      } else {
        delimCheckpoint.restore();
        return null;
      }
    }
    if (delimLine.ptr !== delimLine.EOL) {
      delimCheckpoint.restore();
      return null;
    }
    const irBlock = new Block("table");
    const header = this.parseData(src, firstLine, leftBorder, rightBorder, irBlock);
    if (header === null) {
      delimCheckpoint.restore();
      return null;
    }
    if (header.length !== cols.length) {
      delimCheckpoint.restore();
      return null;
    }
    if (lookahead) {
      delimCheckpoint.restore();
      return {};
    }
    let endLine = delimLine;
    const rows = [];
    for (let line = delimLine.nextInContainer; line !== null && !line.remainingIsBlank(); line = line.nextInContainer) {
      const checkpoint = line.checkpoint();
      line.parseSlop(this.styleSheet.sloppyMargin, true);
      lineIndent = line.parseSpaces(tableIndent);
      if (lineIndent != tableIndent) {
        checkpoint.restore();
        break;
      }
      let row = this.parseData(src, line, leftBorder, rightBorder, irBlock);
      if (row === null) {
        checkpoint.restore();
        break;
      }
      if (row.length < cols.length) {
        if (this.bodyRowTooShort === "add-empty") {
          while (row.length < cols.length) {
            row.push({ type: "cell", body: "", colSpan: 1, rowSpan: 1, parent: irBlock });
          }
        }
      } else if (row.length > cols.length) {
        if (this.bodyRowTooLong === "truncate") {
          row = row.slice(0, cols.length);
        }
      }
      rows.push(row);
      endLine = line;
    }
    const ptTable = new Block2(this);
    ptTable.style = this;
    ptTable.lineStart = firstLine.num;
    ptTable.lineEnd = endLine.num;
    ptTable.indent = tableIndent;
    irBlock.head = [header];
    irBlock.body = rows;
    irBlock.tableMeta = {
      //todo![spec] if there is no meta, don't set these fields
      head: cols,
      body: cols
    };
    irBlock.source = ptTable;
    return { irBlock, ptNamedValue: void 0, endLine };
  }
  parseData(src, line, leftBorder, rightBorder, irBlock) {
    let lineHasMarker = false;
    if (leftBorder !== "no") {
      if (src.charAt(line.ptr) === this.sideBorder) {
        line.ptr += 1;
        lineHasMarker = true;
      } else if (leftBorder === "yes") {
        return null;
      }
    }
    if (this.interruption(line, lineHasMarker)) {
      return null;
    }
    const row = [];
    let match;
    while (!line.remainingIsBlank()) {
      this.RE_DATA.lastIndex = line.ptr;
      match = this.RE_DATA.exec(src);
      const fieldVal = match[0].replace(/\\\|/g, "|");
      if (this.cell === void 0) {
        row.push(
          {
            type: "cell",
            body: [INLINE_PARSE_FLAG, fieldVal],
            colSpan: 1,
            rowSpan: 1,
            parent: irBlock
          }
        );
      } else {
        const cellBody = this.cell.evaluate(null, null, [fieldVal], null, null);
        if (cellBody instanceof Block) {
          if (cellBody.type === "cell") {
            if (cellBody.body?.length === 1 && cellBody.body[0] instanceof Block && cellBody.body[0].type === "paragraph") {
              row.push(
                {
                  type: "cell",
                  body: cellBody.body[0].body,
                  colSpan: 1,
                  rowSpan: 1,
                  parent: irBlock
                }
              );
            } else {
              row.push(
                {
                  ...cellBody,
                  colSpan: 1,
                  rowSpan: 1,
                  parent: irBlock
                }
              );
            }
          } else {
            throw Error("not yet thought through");
          }
        } else {
          row.push(
            {
              type: "cell",
              body: cellBody,
              colSpan: 1,
              rowSpan: 1,
              parent: irBlock
            }
          );
        }
      }
      line.ptr = this.RE_DATA.lastIndex;
      if (line.ptr === line.EOL) {
        if (rightBorder === "yes") {
          return null;
        }
        break;
      }
      lineHasMarker = true;
      if (src.charAt(line.ptr) !== this.columnsDelim) {
        if (rightBorder === "no") {
          return null;
        }
        line.ptr += 1;
        break;
      }
      line.ptr += 1;
      if (this.columnsDelim === this.sideBorder && rightBorder !== "no" && line.remainingIsBlank()) {
        break;
      }
    }
    if (!lineHasMarker && this.bodyRowAtLeastOneMarker === "yes") {
      return null;
    }
    return row;
  }
  interruption(line, lineHasMarker) {
    if (!lineHasMarker && this.gfmQuirks) {
      return line.checkStyleMatch(this.interruptibleBy);
    } else {
      return false;
    }
  }
};

// ptss-parser/ptss/htmlBlockStyle.ts
var TAG_NAME = "[A-Za-z][A-Za-z0-9-]*";
var ATTRIBUTE_NAME = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var UNQUOTED_VALUE = "[^\"'=<>`\\x00-\\x20]+";
var SINGLE_QUOTED_VALUE = "'[^'\n]*'";
var DOUBLE_QUOTED_VALUE = '"[^"\n]*"';
var ATTRIBUTE_VALUE = "(?:" + UNQUOTED_VALUE + "|" + SINGLE_QUOTED_VALUE + "|" + DOUBLE_QUOTED_VALUE + ")";
var ATTRIBUTE_VALUE_SPEC = "(?:[ \\t]*=[ \\t]*" + ATTRIBUTE_VALUE + ")";
var ATTRIBUTE = "(?:[ \\t]+" + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + "?)";
var OPEN_TAG = "<" + TAG_NAME + ATTRIBUTE + "*[ \\t]*/?>";
var CLOSE_TAG = "</" + TAG_NAME + "[ \\t]*[>]";
var reHtmlBlockOpen = [
  /./,
  // dummy for 0
  /(?:script|pre|style|textarea)(?:\s|>)/iy,
  /!--/y,
  /[?]/y,
  /![A-Za-z]/y,
  /!\[CDATA\[/y,
  /[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/iy,
  new RegExp("(?:" + OPEN_TAG.slice(1) + "|" + CLOSE_TAG.slice(1) + ")[ \\t]*\n", "y")
];
var reHtmlBlockClose = [
  /./,
  // dummy for 0
  /^.*<\/(?:script|pre|style|textarea)>/iym,
  /^.*-->/ym,
  /^.*\?>/ym,
  /^.*>/ym,
  /^.*]]>/ym
];
var HTMLBlockStyle = class {
  baseType = 5 /* TEMP_HTML_HACK */;
  name;
  indent = "no";
  canInterruptParagraph = true;
  canInterruptLazy = true;
  consumesBackChunk = false;
  styleSheet;
  constructor(name, styleSheet) {
    this.name = name;
    this.styleSheet = styleSheet;
  }
  initAndValidate() {
    const match = RE_MARKDOWN_INDENT.exec(this.indent);
    if (match) {
      throw new Error(`markdown mode indent is not supported for HTML blocks`);
    }
    return;
  }
  parse(firstLine, fromBackLine, lookahead = false) {
    const src = firstLine.src;
    const indent = firstLine.parseSpaces();
    if (indent === 0 && this.indent === "yes") {
      return null;
    }
    if (indent > 0 && this.indent === "no") {
      return null;
    }
    let startOffset = firstLine.ptr;
    if (src.charAt(startOffset) !== "<") {
      return null;
    }
    startOffset++;
    const allowedTypes = fromBackLine === null ? 7 : 6;
    let blockType;
    for (blockType = 1; blockType <= 7; blockType++) {
      const regExp = reHtmlBlockOpen[blockType];
      regExp.lastIndex = startOffset;
      if (blockType <= allowedTypes && regExp.test(src)) {
        if (lookahead) {
          return {};
        }
        firstLine.ptr = firstLine.pContainerSOL;
        let blockContent, lastLine;
        if (blockType <= 5) {
          [blockContent, lastLine] = firstLine.fwdBlock(false, reHtmlBlockClose[blockType]);
        } else {
          [blockContent, lastLine] = firstLine.fwdBlock(true);
        }
        const ptBlock = new Block2(this);
        ptBlock._htmlBlockType = blockType;
        ptBlock.lineStart = firstLine.num;
        ptBlock.lineEnd = lastLine.num;
        const irHtmlBlock = new Block("html_block");
        irHtmlBlock.source = ptBlock;
        irHtmlBlock.body = blockContent.replace(/(\n *)+$/, "");
        return { irBlock: irHtmlBlock, endLine: lastLine };
      }
    }
    return null;
  }
};

// ptss-parser/ptss/stylesheet.ts
var Stylesheet = class {
  //todo![spec] Maybe the name of every stylesheet should be identical to
  // the filename (including the `.ptss` suffix):
  //   - consistency
  //   - simplicity
  //   - elegant circularity
  //   - no ambiguity
  //   - eliminate the dumb switch statement we have in sheets/index.ts
  //     - stylesheets should get registered with their own name as declared
  //       in their definition.
  // If we decide to do that:
  //   - `+ '.ptss'` in TLP and anywhere else we have it
  name;
  // todo![strict syntax, errors] need to review features i've previously
  //  rejected because of the "do not allow parsing impasses" principle,
  //  since this property expressly begs for such impasses.
  strictSyntax = false;
  //! ////////////// BEGIN BLOCK-LEVEL DECLARATIONS ////////////////
  blockStyles = [];
  rootContainerStyle;
  defaultBlockStyle;
  // this will be true if at least element style is lazy
  _lazyContinuation = false;
  get lazyContinuation() {
    return this._lazyContinuation;
  }
  // See documentation on sloppyMargin vs intentional/meaningful indentation.
  // todo![spec] i think this should be renamed to "sloppinessLimit"
  //   (or even simply "sloppiness") as doesn't govern the entire margin of
  //   a Chunk style. See the `compare/sloppiness.md` cases. Not how I
  //   naturally say, "the sloppiness limit is only applied to...".
  //   Writing that doc with "sloppiness margin" just doesn't work.
  sloppyMargin = 0;
  //! ////////////// BEGIN INLINE-LEVEL DECLARATIONS ////////////////
  // todo[inline] TEMP HACK until we implement ptss.InlineStyle and ditch
  //  Markdown-it. hack for now is:
  //   - empty array is default, CommonMark inline elements
  //   - add names of Markdown-it's inline rules for more
  inlineStyles = [];
  /**
   * See documentation for {@link EscapeSyntax}.
   *
   *! the reason we define escape sequences here rather rather than entirely
   *  within the `escape sequence` inline style is because the escape sequences
   *  also apply in link destinations text, which are not subject to inline
   *  style parsing. Thus we must have the escape sequence spec here so it can
   *  be shared by the inline styled text parser AND the link destination parser.
   */
  escapeSyntax;
  linkDestAllowSpaces = true;
  constructor(name) {
    this.name = name;
    this.rootContainerStyle = new ContainerStyle(`${name} root container`, this);
    this.rootContainerStyle.irNode.type = new Expression("structured_text_intermediate_representation");
    this.rootContainerStyle.body = "BLOCKS";
    this.defaultBlockStyle = new ChunkStyle("Paragraph", this);
    this.defaultBlockStyle.irNode.type = new Expression("paragraph");
    this.defaultBlockStyle.irNode.body = new Expression(["parseInlines", ["trim", ["body"]]]);
    this.escapeSyntax = {
      escapeChar: void 0,
      escapeLiterals: "",
      escapeMappings: [],
      ESCAPE_INLINE_LOOKUP: new Array(256),
      ESCAPE_LINK_DEST_LOOKUP: new Array(256)
    };
  }
  initAndValidate() {
    for (const style of this.blockStyles) {
      if (style.styleSheet !== this) {
        throw Error(`"${style.name}" is attached to "${style.styleSheet.name}" but added to "${this.name}"`);
      }
      try {
        style.initAndValidate();
      } catch (e) {
        throw Error(`Invalid Style Declaration "${style.name}" in "${this.name}" style sheet`, { cause: e });
      }
      this._lazyContinuation = this.defaultBlockStyle.lazyContinuation;
      if (style instanceof ChunkStyle && style.lazyContinuation) {
        if (!this.defaultBlockStyle.lazyContinuation) {
          throw Error(`Lazy continuation enabled for "${style.name}" but not for the default style ${this.defaultBlockStyle.name}. If any style can lazily continue, the default must be.`);
        }
        this._lazyContinuation = true;
      }
    }
    const escapeInlineLookup = this.escapeSyntax.ESCAPE_INLINE_LOOKUP;
    const escapeLinkDestLookup = this.escapeSyntax.ESCAPE_LINK_DEST_LOOKUP;
    this.escapeSyntax.escapeLiterals.split("").forEach(function(ch) {
      escapeInlineLookup[ch.charCodeAt(0)] = ch;
      escapeLinkDestLookup[ch.charCodeAt(0)] = ch;
    });
    this.escapeSyntax.escapeMappings.forEach(function(mapping) {
      const ch1 = mapping[0];
      if (ch1.length > 1 || ch1.charCodeAt(0) > 256) {
        throw Error("can only escape extended ASCII characters");
      }
      escapeInlineLookup[ch1.charCodeAt(0)] = mapping[1];
    });
  }
  get(name) {
    const style = this.blockStyles.find((style2) => style2.name === name);
    if (style) {
      return style;
    }
    if (this.defaultBlockStyle.name === name) {
      return this.defaultBlockStyle;
    }
    throw new Error(`not found: ${name}`);
  }
  insertAbove(existingStyle, newStyle) {
    const idx = this.blockStyles.findIndex((style) => style.name === existingStyle);
    if (idx === -1) {
      if (this.defaultBlockStyle.name === existingStyle) {
        this.blockStyles.push(newStyle);
      } else {
        throw new Error(`not found: ${existingStyle}`);
      }
    }
    this.blockStyles.splice(idx, 0, newStyle);
  }
  remove(name) {
    const idx = this.blockStyles.findIndex((style2) => style2.name === name);
    if (idx === -1) {
      if (this.defaultBlockStyle.name === name) {
        throw new Error(`cannot remove default style, ${name}, but you can set a new one.`);
      }
      throw new Error(`not found: ${name}`);
    }
    const style = this.blockStyles[idx];
    this.blockStyles.splice(idx, 1);
    return style;
  }
  toDebugString() {
    let s = this.name + ": {\n  block styles: {";
    for (const blockStyle of this.blockStyles) {
      s += "\n    " + blockStyle.name;
    }
    s += "\n  }\n  inline styles: {";
    for (const inlineStyle of this.inlineStyles) {
      s += "\n    " + inlineStyle;
    }
    s += "\n  }\n}";
    return s;
  }
};

// node_modules/linkifyjs/dist/linkify.es.js
var encodedTlds = "aaa1rp3barth4b0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0faromeo7ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re2s2c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y0eats7k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking0channel11l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t0isalat7u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0at2delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d0network8tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntdoor4ier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5gtv3iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0eles2s3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1nder2le4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster5ia3d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4de2k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0cys3drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7serati6ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic3tual5v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rthwesternmutual14on4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3ssagens7y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cher3ks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w0time7i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ffany5ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0channel7ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5m\xF6gensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lkswagen7vo3te1ing3o2yage5u0elos6wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2";
var encodedUtlds = "\u03B5\u03BB1\u03C52\u0431\u04331\u0435\u043B3\u0434\u0435\u0442\u04384\u0435\u044E2\u043A\u0430\u0442\u043E\u043B\u0438\u043A6\u043E\u043C3\u043C\u043A\u04342\u043E\u043D1\u0441\u043A\u0432\u04306\u043E\u043D\u043B\u0430\u0439\u043D5\u0440\u04333\u0440\u0443\u04412\u04442\u0441\u0430\u0439\u04423\u0440\u04313\u0443\u043A\u04403\u049B\u0430\u04373\u0570\u0561\u05753\u05D9\u05E9\u05E8\u05D0\u05DC5\u05E7\u05D5\u05DD3\u0627\u0628\u0648\u0638\u0628\u064A5\u062A\u0635\u0627\u0644\u0627\u062A6\u0631\u0627\u0645\u0643\u06485\u0644\u0627\u0631\u062F\u06464\u0628\u062D\u0631\u064A\u06465\u062C\u0632\u0627\u0626\u06315\u0633\u0639\u0648\u062F\u064A\u06296\u0639\u0644\u064A\u0627\u06465\u0645\u063A\u0631\u06285\u0645\u0627\u0631\u0627\u062A5\u06CC\u0631\u0627\u06465\u0628\u0627\u0631\u062A2\u0632\u0627\u06314\u064A\u062A\u06433\u06BE\u0627\u0631\u062A5\u062A\u0648\u0646\u06334\u0633\u0648\u062F\u0627\u06463\u0631\u064A\u06295\u0634\u0628\u0643\u06294\u0639\u0631\u0627\u06422\u06282\u0645\u0627\u06464\u0641\u0644\u0633\u0637\u064A\u06466\u0642\u0637\u06313\u0643\u0627\u062B\u0648\u0644\u064A\u06436\u0648\u06453\u0645\u0635\u06312\u0644\u064A\u0633\u064A\u06275\u0648\u0631\u064A\u062A\u0627\u0646\u064A\u06277\u0642\u06394\u0647\u0645\u0631\u0627\u06475\u067E\u0627\u06A9\u0633\u062A\u0627\u06467\u0680\u0627\u0631\u062A4\u0915\u0949\u092E3\u0928\u0947\u091F3\u092D\u093E\u0930\u09240\u092E\u094D3\u094B\u09245\u0938\u0902\u0917\u0920\u09285\u09AC\u09BE\u0982\u09B2\u09BE5\u09AD\u09BE\u09B0\u09A42\u09F0\u09A44\u0A2D\u0A3E\u0A30\u0A244\u0AAD\u0ABE\u0AB0\u0AA44\u0B2D\u0B3E\u0B30\u0B244\u0B87\u0BA8\u0BCD\u0BA4\u0BBF\u0BAF\u0BBE6\u0BB2\u0B99\u0BCD\u0B95\u0BC86\u0B9A\u0BBF\u0B99\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0BC2\u0BB0\u0BCD11\u0C2D\u0C3E\u0C30\u0C24\u0C4D5\u0CAD\u0CBE\u0CB0\u0CA44\u0D2D\u0D3E\u0D30\u0D24\u0D025\u0DBD\u0D82\u0D9A\u0DCF4\u0E04\u0E2D\u0E213\u0E44\u0E17\u0E223\u0EA5\u0EB2\u0EA73\u10D2\u10D42\u307F\u3093\u306A3\u30A2\u30DE\u30BE\u30F34\u30AF\u30E9\u30A6\u30C94\u30B0\u30FC\u30B0\u30EB4\u30B3\u30E02\u30B9\u30C8\u30A23\u30BB\u30FC\u30EB3\u30D5\u30A1\u30C3\u30B7\u30E7\u30F36\u30DD\u30A4\u30F3\u30C84\u4E16\u754C2\u4E2D\u4FE11\u56FD1\u570B1\u6587\u7F513\u4E9A\u9A6C\u900A3\u4F01\u4E1A2\u4F5B\u5C712\u4FE1\u606F2\u5065\u5EB72\u516B\u53662\u516C\u53F81\u76CA2\u53F0\u6E7E1\u70632\u5546\u57CE1\u5E971\u68072\u5609\u91CC0\u5927\u9152\u5E975\u5728\u7EBF2\u5927\u62FF2\u5929\u4E3B\u65593\u5A31\u4E502\u5BB6\u96FB2\u5E7F\u4E1C2\u5FAE\u535A2\u6148\u55842\u6211\u7231\u4F603\u624B\u673A2\u62DB\u80582\u653F\u52A11\u5E9C2\u65B0\u52A0\u57612\u95FB2\u65F6\u5C1A2\u66F8\u7C4D2\u673A\u67842\u6DE1\u9A6C\u95213\u6E38\u620F2\u6FB3\u95802\u70B9\u770B2\u79FB\u52A82\u7EC4\u7EC7\u673A\u67844\u7F51\u57401\u5E971\u7AD91\u7EDC2\u8054\u901A2\u8C37\u6B4C2\u8D2D\u72692\u901A\u8CA92\u96C6\u56E22\u96FB\u8A0A\u76C8\u79D14\u98DE\u5229\u6D663\u98DF\u54C12\u9910\u53852\u9999\u683C\u91CC\u62C93\u6E2F2\uB2F7\uB1371\uCEF42\uC0BC\uC1312\uD55C\uAD6D2";
var assign = (target, properties) => {
  for (const key in properties) {
    target[key] = properties[key];
  }
  return target;
};
var numeric = "numeric";
var ascii = "ascii";
var alpha = "alpha";
var asciinumeric = "asciinumeric";
var alphanumeric = "alphanumeric";
var domain = "domain";
var emoji = "emoji";
var scheme = "scheme";
var slashscheme = "slashscheme";
var whitespace = "whitespace";
function registerGroup(name, groups) {
  if (!(name in groups)) {
    groups[name] = [];
  }
  return groups[name];
}
function addToGroups(t, flags, groups) {
  if (flags[numeric]) {
    flags[asciinumeric] = true;
    flags[alphanumeric] = true;
  }
  if (flags[ascii]) {
    flags[asciinumeric] = true;
    flags[alpha] = true;
  }
  if (flags[asciinumeric]) {
    flags[alphanumeric] = true;
  }
  if (flags[alpha]) {
    flags[alphanumeric] = true;
  }
  if (flags[alphanumeric]) {
    flags[domain] = true;
  }
  if (flags[emoji]) {
    flags[domain] = true;
  }
  for (const k in flags) {
    const group = registerGroup(k, groups);
    if (group.indexOf(t) < 0) {
      group.push(t);
    }
  }
}
function flagsForToken(t, groups) {
  const result = {};
  for (const c in groups) {
    if (groups[c].indexOf(t) >= 0) {
      result[c] = true;
    }
  }
  return result;
}
function State(token) {
  if (token === void 0) {
    token = null;
  }
  this.j = {};
  this.jr = [];
  this.jd = null;
  this.t = token;
}
State.groups = {};
State.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(input) {
    const state = this;
    const nextState = state.j[input];
    if (nextState) {
      return nextState;
    }
    for (let i = 0; i < state.jr.length; i++) {
      const regex = state.jr[i][0];
      const nextState2 = state.jr[i][1];
      if (nextState2 && regex.test(input)) {
        return nextState2;
      }
    }
    return state.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(input, exactOnly) {
    if (exactOnly === void 0) {
      exactOnly = false;
    }
    return exactOnly ? input in this.j : !!this.go(input);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(inputs, next, flags, groups) {
    for (let i = 0; i < inputs.length; i++) {
      this.tt(inputs[i], next, flags, groups);
    }
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(regexp, next, flags, groups) {
    groups = groups || State.groups;
    let nextState;
    if (next && next.j) {
      nextState = next;
    } else {
      nextState = new State(next);
      if (flags && groups) {
        addToGroups(next, flags, groups);
      }
    }
    this.jr.push([regexp, nextState]);
    return nextState;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(input, next, flags, groups) {
    let state = this;
    const len = input.length;
    if (!len) {
      return state;
    }
    for (let i = 0; i < len - 1; i++) {
      state = state.tt(input[i]);
    }
    return state.tt(input[len - 1], next, flags, groups);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(input, next, flags, groups) {
    groups = groups || State.groups;
    const state = this;
    if (next && next.j) {
      state.j[input] = next;
      return next;
    }
    const t = next;
    let nextState, templateState = state.go(input);
    if (templateState) {
      nextState = new State();
      assign(nextState.j, templateState.j);
      nextState.jr.push.apply(nextState.jr, templateState.jr);
      nextState.jd = templateState.jd;
      nextState.t = templateState.t;
    } else {
      nextState = new State();
    }
    if (t) {
      if (groups) {
        if (nextState.t && typeof nextState.t === "string") {
          const allFlags = assign(flagsForToken(nextState.t, groups), flags);
          addToGroups(t, allFlags, groups);
        } else if (flags) {
          addToGroups(t, flags, groups);
        }
      }
      nextState.t = t;
    }
    state.j[input] = nextState;
    return nextState;
  }
};
var ta = (state, input, next, flags, groups) => state.ta(input, next, flags, groups);
var tr = (state, regexp, next, flags, groups) => state.tr(regexp, next, flags, groups);
var ts = (state, input, next, flags, groups) => state.ts(input, next, flags, groups);
var tt = (state, input, next, flags, groups) => state.tt(input, next, flags, groups);
var WORD = "WORD";
var UWORD = "UWORD";
var LOCALHOST = "LOCALHOST";
var TLD = "TLD";
var UTLD = "UTLD";
var SCHEME = "SCHEME";
var SLASH_SCHEME = "SLASH_SCHEME";
var NUM = "NUM";
var WS = "WS";
var NL$1 = "NL";
var OPENBRACE = "OPENBRACE";
var OPENBRACKET = "OPENBRACKET";
var OPENANGLEBRACKET = "OPENANGLEBRACKET";
var OPENPAREN = "OPENPAREN";
var CLOSEBRACE = "CLOSEBRACE";
var CLOSEBRACKET = "CLOSEBRACKET";
var CLOSEANGLEBRACKET = "CLOSEANGLEBRACKET";
var CLOSEPAREN = "CLOSEPAREN";
var AMPERSAND = "AMPERSAND";
var APOSTROPHE = "APOSTROPHE";
var ASTERISK = "ASTERISK";
var AT = "AT";
var BACKSLASH = "BACKSLASH";
var BACKTICK = "BACKTICK";
var CARET = "CARET";
var COLON = "COLON";
var COMMA = "COMMA";
var DOLLAR = "DOLLAR";
var DOT = "DOT";
var EQUALS = "EQUALS";
var EXCLAMATION = "EXCLAMATION";
var HYPHEN = "HYPHEN";
var PERCENT = "PERCENT";
var PIPE = "PIPE";
var PLUS = "PLUS";
var POUND = "POUND";
var QUERY = "QUERY";
var QUOTE = "QUOTE";
var SEMI = "SEMI";
var SLASH = "SLASH";
var TILDE = "TILDE";
var UNDERSCORE = "UNDERSCORE";
var EMOJI$1 = "EMOJI";
var SYM = "SYM";
var tk = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  WORD,
  UWORD,
  LOCALHOST,
  TLD,
  UTLD,
  SCHEME,
  SLASH_SCHEME,
  NUM,
  WS,
  NL: NL$1,
  OPENBRACE,
  OPENBRACKET,
  OPENANGLEBRACKET,
  OPENPAREN,
  CLOSEBRACE,
  CLOSEBRACKET,
  CLOSEANGLEBRACKET,
  CLOSEPAREN,
  AMPERSAND,
  APOSTROPHE,
  ASTERISK,
  AT,
  BACKSLASH,
  BACKTICK,
  CARET,
  COLON,
  COMMA,
  DOLLAR,
  DOT,
  EQUALS,
  EXCLAMATION,
  HYPHEN,
  PERCENT,
  PIPE,
  PLUS,
  POUND,
  QUERY,
  QUOTE,
  SEMI,
  SLASH,
  TILDE,
  UNDERSCORE,
  EMOJI: EMOJI$1,
  SYM
});
var ASCII_LETTER = /[a-z]/;
var LETTER = /\p{L}/u;
var EMOJI = /\p{Emoji}/u;
var DIGIT = /\d/;
var SPACE = /\s/;
var NL = "\n";
var EMOJI_VARIATION = "\uFE0F";
var EMOJI_JOINER = "\u200D";
var tlds = null;
var utlds = null;
function init$2(customSchemes) {
  if (customSchemes === void 0) {
    customSchemes = [];
  }
  const groups = {};
  State.groups = groups;
  const Start = new State();
  if (tlds == null) {
    tlds = decodeTlds(encodedTlds);
  }
  if (utlds == null) {
    utlds = decodeTlds(encodedUtlds);
  }
  tt(Start, "'", APOSTROPHE);
  tt(Start, "{", OPENBRACE);
  tt(Start, "[", OPENBRACKET);
  tt(Start, "<", OPENANGLEBRACKET);
  tt(Start, "(", OPENPAREN);
  tt(Start, "}", CLOSEBRACE);
  tt(Start, "]", CLOSEBRACKET);
  tt(Start, ">", CLOSEANGLEBRACKET);
  tt(Start, ")", CLOSEPAREN);
  tt(Start, "&", AMPERSAND);
  tt(Start, "*", ASTERISK);
  tt(Start, "@", AT);
  tt(Start, "`", BACKTICK);
  tt(Start, "^", CARET);
  tt(Start, ":", COLON);
  tt(Start, ",", COMMA);
  tt(Start, "$", DOLLAR);
  tt(Start, ".", DOT);
  tt(Start, "=", EQUALS);
  tt(Start, "!", EXCLAMATION);
  tt(Start, "-", HYPHEN);
  tt(Start, "%", PERCENT);
  tt(Start, "|", PIPE);
  tt(Start, "+", PLUS);
  tt(Start, "#", POUND);
  tt(Start, "?", QUERY);
  tt(Start, '"', QUOTE);
  tt(Start, "/", SLASH);
  tt(Start, ";", SEMI);
  tt(Start, "~", TILDE);
  tt(Start, "_", UNDERSCORE);
  tt(Start, "\\", BACKSLASH);
  const Num = tr(Start, DIGIT, NUM, {
    [numeric]: true
  });
  tr(Num, DIGIT, Num);
  const Word = tr(Start, ASCII_LETTER, WORD, {
    [ascii]: true
  });
  tr(Word, ASCII_LETTER, Word);
  const UWord = tr(Start, LETTER, UWORD, {
    [alpha]: true
  });
  tr(UWord, ASCII_LETTER);
  tr(UWord, LETTER, UWord);
  const Ws = tr(Start, SPACE, WS, {
    [whitespace]: true
  });
  tt(Start, NL, NL$1, {
    [whitespace]: true
  });
  tt(Ws, NL);
  tr(Ws, SPACE, Ws);
  const Emoji = tr(Start, EMOJI, EMOJI$1, {
    [emoji]: true
  });
  tr(Emoji, EMOJI, Emoji);
  tt(Emoji, EMOJI_VARIATION, Emoji);
  const EmojiJoiner = tt(Emoji, EMOJI_JOINER);
  tr(EmojiJoiner, EMOJI, Emoji);
  const wordjr = [[ASCII_LETTER, Word]];
  const uwordjr = [[ASCII_LETTER, null], [LETTER, UWord]];
  for (let i = 0; i < tlds.length; i++) {
    fastts(Start, tlds[i], TLD, WORD, wordjr);
  }
  for (let i = 0; i < utlds.length; i++) {
    fastts(Start, utlds[i], UTLD, UWORD, uwordjr);
  }
  addToGroups(TLD, {
    tld: true,
    ascii: true
  }, groups);
  addToGroups(UTLD, {
    utld: true,
    alpha: true
  }, groups);
  fastts(Start, "file", SCHEME, WORD, wordjr);
  fastts(Start, "mailto", SCHEME, WORD, wordjr);
  fastts(Start, "http", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "https", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftp", SLASH_SCHEME, WORD, wordjr);
  fastts(Start, "ftps", SLASH_SCHEME, WORD, wordjr);
  addToGroups(SCHEME, {
    scheme: true,
    ascii: true
  }, groups);
  addToGroups(SLASH_SCHEME, {
    slashscheme: true,
    ascii: true
  }, groups);
  customSchemes = customSchemes.sort((a, b) => a[0] > b[0] ? 1 : -1);
  for (let i = 0; i < customSchemes.length; i++) {
    const sch = customSchemes[i][0];
    const optionalSlashSlash = customSchemes[i][1];
    const flags = optionalSlashSlash ? {
      [scheme]: true
    } : {
      [slashscheme]: true
    };
    if (sch.indexOf("-") >= 0) {
      flags[domain] = true;
    } else if (!ASCII_LETTER.test(sch)) {
      flags[numeric] = true;
    } else if (DIGIT.test(sch)) {
      flags[asciinumeric] = true;
    } else {
      flags[ascii] = true;
    }
    ts(Start, sch, sch, flags);
  }
  ts(Start, "localhost", LOCALHOST, {
    ascii: true
  });
  Start.jd = new State(SYM);
  return {
    start: Start,
    tokens: assign({
      groups
    }, tk)
  };
}
function run$1(start, str) {
  const iterable = stringToArray(str.replace(/[A-Z]/g, (c) => c.toLowerCase()));
  const charCount = iterable.length;
  const tokens = [];
  let cursor = 0;
  let charCursor = 0;
  while (charCursor < charCount) {
    let state = start;
    let nextState = null;
    let tokenLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    let charsSinceAccepts = -1;
    while (charCursor < charCount && (nextState = state.go(iterable[charCursor]))) {
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        charsSinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts += iterable[charCursor].length;
        charsSinceAccepts++;
      }
      tokenLength += iterable[charCursor].length;
      cursor += iterable[charCursor].length;
      charCursor++;
    }
    cursor -= sinceAccepts;
    charCursor -= charsSinceAccepts;
    tokenLength -= sinceAccepts;
    tokens.push({
      t: latestAccepting.t,
      // token type/name
      v: str.slice(cursor - tokenLength, cursor),
      // string value
      s: cursor - tokenLength,
      // start index
      e: cursor
      // end index (excluding)
    });
  }
  return tokens;
}
function stringToArray(str) {
  const result = [];
  const len = str.length;
  let index = 0;
  while (index < len) {
    let first = str.charCodeAt(index);
    let second;
    let char = first < 55296 || first > 56319 || index + 1 === len || (second = str.charCodeAt(index + 1)) < 56320 || second > 57343 ? str[index] : str.slice(index, index + 2);
    result.push(char);
    index += char.length;
  }
  return result;
}
function fastts(state, input, t, defaultt, jr) {
  let next;
  const len = input.length;
  for (let i = 0; i < len - 1; i++) {
    const char = input[i];
    if (state.j[char]) {
      next = state.j[char];
    } else {
      next = new State(defaultt);
      next.jr = jr.slice();
      state.j[char] = next;
    }
    state = next;
  }
  next = new State(t);
  next.jr = jr.slice();
  state.j[input[len - 1]] = next;
  return next;
}
function decodeTlds(encoded) {
  const words = [];
  const stack = [];
  let i = 0;
  let digits = "0123456789";
  while (i < encoded.length) {
    let popDigitCount = 0;
    while (digits.indexOf(encoded[i + popDigitCount]) >= 0) {
      popDigitCount++;
    }
    if (popDigitCount > 0) {
      words.push(stack.join(""));
      for (let popCount = parseInt(encoded.substring(i, i + popDigitCount), 10); popCount > 0; popCount--) {
        stack.pop();
      }
      i += popDigitCount;
    } else {
      stack.push(encoded[i]);
      i++;
    }
  }
  return words;
}
var defaults = {
  defaultProtocol: "http",
  events: null,
  format: noop,
  formatHref: noop,
  nl2br: false,
  tagName: "a",
  target: null,
  rel: null,
  validate: true,
  truncate: Infinity,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function Options(opts, defaultRender) {
  if (defaultRender === void 0) {
    defaultRender = null;
  }
  let o = assign({}, defaults);
  if (opts) {
    o = assign(o, opts instanceof Options ? opts.o : opts);
  }
  const ignoredTags = o.ignoreTags;
  const uppercaseIgnoredTags = [];
  for (let i = 0; i < ignoredTags.length; i++) {
    uppercaseIgnoredTags.push(ignoredTags[i].toUpperCase());
  }
  this.o = o;
  if (defaultRender) {
    this.defaultRender = defaultRender;
  }
  this.ignoreTags = uppercaseIgnoredTags;
}
Options.prototype = {
  o: defaults,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(ir) {
    return ir;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(token) {
    return this.get("validate", token.toString(), token);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(key, operator, token) {
    const isCallable = operator != null;
    let option = this.o[key];
    if (!option) {
      return option;
    }
    if (typeof option === "object") {
      option = token.t in option ? option[token.t] : defaults[key];
      if (typeof option === "function" && isCallable) {
        option = option(operator, token);
      }
    } else if (typeof option === "function" && isCallable) {
      option = option(operator, token.t, token);
    }
    return option;
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(key, operator, token) {
    let obj = this.o[key];
    if (typeof obj === "function" && operator != null) {
      obj = obj(operator, token.t, token);
    }
    return obj;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(token) {
    const ir = token.render(this);
    const renderFn = this.get("render", null, token) || this.defaultRender;
    return renderFn(ir, token.t, token);
  }
};
function noop(val) {
  return val;
}
function MultiToken(value, tokens) {
  this.t = "token";
  this.v = value;
  this.tk = tokens;
}
MultiToken.prototype = {
  isLink: false,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
  */
  toHref(scheme2) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(options) {
    const val = this.toString();
    const truncate = options.get("truncate", val, this);
    const formatted = options.get("format", val, this);
    return truncate && formatted.length > truncate ? formatted.substring(0, truncate) + "\u2026" : formatted;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(options) {
    return options.get("formatHref", this.toHref(options.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(protocol) {
    if (protocol === void 0) {
      protocol = defaults.defaultProtocol;
    }
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(protocol),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(options) {
    return {
      type: this.t,
      value: this.toFormattedString(options),
      isLink: this.isLink,
      href: this.toFormattedHref(options),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(options) {
    return options.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(options) {
    const token = this;
    const href = this.toHref(options.get("defaultProtocol"));
    const formattedHref = options.get("formatHref", href, this);
    const tagName = options.get("tagName", href, token);
    const content = this.toFormattedString(options);
    const attributes = {};
    const className = options.get("className", href, token);
    const target = options.get("target", href, token);
    const rel = options.get("rel", href, token);
    const attrs = options.getObj("attributes", href, token);
    const eventListeners = options.getObj("events", href, token);
    attributes.href = formattedHref;
    if (className) {
      attributes.class = className;
    }
    if (target) {
      attributes.target = target;
    }
    if (rel) {
      attributes.rel = rel;
    }
    if (attrs) {
      assign(attributes, attrs);
    }
    return {
      tagName,
      attributes,
      content,
      eventListeners
    };
  }
};
function createTokenClass(type, props) {
  class Token extends MultiToken {
    constructor(value, tokens) {
      super(value, tokens);
      this.t = type;
    }
  }
  for (const p in props) {
    Token.prototype[p] = props[p];
  }
  Token.t = type;
  return Token;
}
var Email = createTokenClass("email", {
  isLink: true,
  toHref() {
    return "mailto:" + this.toString();
  }
});
var Text = createTokenClass("text");
var Nl = createTokenClass("nl");
var Url = createTokenClass("url", {
  isLink: true,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(scheme2) {
    if (scheme2 === void 0) {
      scheme2 = defaults.defaultProtocol;
    }
    return this.hasProtocol() ? this.v : `${scheme2}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const tokens = this.tk;
    return tokens.length >= 2 && tokens[0].t !== LOCALHOST && tokens[1].t === COLON;
  }
});
var makeState = (arg) => new State(arg);
function init$1(_ref) {
  let {
    groups
  } = _ref;
  const qsAccepting = groups.domain.concat([AMPERSAND, ASTERISK, AT, BACKSLASH, BACKTICK, CARET, DOLLAR, EQUALS, HYPHEN, NUM, PERCENT, PIPE, PLUS, POUND, SLASH, SYM, TILDE, UNDERSCORE]);
  const qsNonAccepting = [APOSTROPHE, CLOSEANGLEBRACKET, CLOSEBRACE, CLOSEBRACKET, CLOSEPAREN, COLON, COMMA, DOT, EXCLAMATION, OPENANGLEBRACKET, OPENBRACE, OPENBRACKET, OPENPAREN, QUERY, QUOTE, SEMI];
  const localpartAccepting = [AMPERSAND, APOSTROPHE, ASTERISK, BACKSLASH, BACKTICK, CARET, CLOSEBRACE, DOLLAR, EQUALS, HYPHEN, OPENBRACE, PERCENT, PIPE, PLUS, POUND, QUERY, SLASH, SYM, TILDE, UNDERSCORE];
  const Start = makeState();
  const Localpart = tt(Start, TILDE);
  ta(Localpart, localpartAccepting, Localpart);
  ta(Localpart, groups.domain, Localpart);
  const Domain = makeState(), Scheme = makeState(), SlashScheme = makeState();
  ta(Start, groups.domain, Domain);
  ta(Start, groups.scheme, Scheme);
  ta(Start, groups.slashscheme, SlashScheme);
  ta(Domain, localpartAccepting, Localpart);
  ta(Domain, groups.domain, Domain);
  const LocalpartAt = tt(Domain, AT);
  tt(Localpart, AT, LocalpartAt);
  tt(Scheme, AT, LocalpartAt);
  tt(SlashScheme, AT, LocalpartAt);
  const LocalpartDot = tt(Localpart, DOT);
  ta(LocalpartDot, localpartAccepting, Localpart);
  ta(LocalpartDot, groups.domain, Localpart);
  const EmailDomain = makeState();
  ta(LocalpartAt, groups.domain, EmailDomain);
  ta(EmailDomain, groups.domain, EmailDomain);
  const EmailDomainDot = tt(EmailDomain, DOT);
  ta(EmailDomainDot, groups.domain, EmailDomain);
  const Email$1 = makeState(Email);
  ta(EmailDomainDot, groups.tld, Email$1);
  ta(EmailDomainDot, groups.utld, Email$1);
  tt(LocalpartAt, LOCALHOST, Email$1);
  const EmailDomainHyphen = tt(EmailDomain, HYPHEN);
  ta(EmailDomainHyphen, groups.domain, EmailDomain);
  ta(Email$1, groups.domain, EmailDomain);
  tt(Email$1, DOT, EmailDomainDot);
  tt(Email$1, HYPHEN, EmailDomainHyphen);
  const EmailColon = tt(Email$1, COLON);
  ta(EmailColon, groups.numeric, Email);
  const DomainHyphen = tt(Domain, HYPHEN);
  const DomainDot = tt(Domain, DOT);
  ta(DomainHyphen, groups.domain, Domain);
  ta(DomainDot, localpartAccepting, Localpart);
  ta(DomainDot, groups.domain, Domain);
  const DomainDotTld = makeState(Url);
  ta(DomainDot, groups.tld, DomainDotTld);
  ta(DomainDot, groups.utld, DomainDotTld);
  ta(DomainDotTld, groups.domain, Domain);
  ta(DomainDotTld, localpartAccepting, Localpart);
  tt(DomainDotTld, DOT, DomainDot);
  tt(DomainDotTld, HYPHEN, DomainHyphen);
  tt(DomainDotTld, AT, LocalpartAt);
  const DomainDotTldColon = tt(DomainDotTld, COLON);
  const DomainDotTldColonPort = makeState(Url);
  ta(DomainDotTldColon, groups.numeric, DomainDotTldColonPort);
  const Url$1 = makeState(Url);
  const UrlNonaccept = makeState();
  ta(Url$1, qsAccepting, Url$1);
  ta(Url$1, qsNonAccepting, UrlNonaccept);
  ta(UrlNonaccept, qsAccepting, Url$1);
  ta(UrlNonaccept, qsNonAccepting, UrlNonaccept);
  tt(DomainDotTld, SLASH, Url$1);
  tt(DomainDotTldColonPort, SLASH, Url$1);
  const SchemeColon = tt(Scheme, COLON);
  const SlashSchemeColon = tt(SlashScheme, COLON);
  const SlashSchemeColonSlash = tt(SlashSchemeColon, SLASH);
  const UriPrefix = tt(SlashSchemeColonSlash, SLASH);
  ta(Scheme, groups.domain, Domain);
  tt(Scheme, DOT, DomainDot);
  tt(Scheme, HYPHEN, DomainHyphen);
  ta(SlashScheme, groups.domain, Domain);
  tt(SlashScheme, DOT, DomainDot);
  tt(SlashScheme, HYPHEN, DomainHyphen);
  ta(SchemeColon, groups.domain, Url$1);
  tt(SchemeColon, SLASH, Url$1);
  ta(UriPrefix, groups.domain, Url$1);
  ta(UriPrefix, qsAccepting, Url$1);
  tt(UriPrefix, SLASH, Url$1);
  const UrlOpenbrace = tt(Url$1, OPENBRACE);
  const UrlOpenbracket = tt(Url$1, OPENBRACKET);
  const UrlOpenanglebracket = tt(Url$1, OPENANGLEBRACKET);
  const UrlOpenparen = tt(Url$1, OPENPAREN);
  tt(UrlNonaccept, OPENBRACE, UrlOpenbrace);
  tt(UrlNonaccept, OPENBRACKET, UrlOpenbracket);
  tt(UrlNonaccept, OPENANGLEBRACKET, UrlOpenanglebracket);
  tt(UrlNonaccept, OPENPAREN, UrlOpenparen);
  tt(UrlOpenbrace, CLOSEBRACE, Url$1);
  tt(UrlOpenbracket, CLOSEBRACKET, Url$1);
  tt(UrlOpenanglebracket, CLOSEANGLEBRACKET, Url$1);
  tt(UrlOpenparen, CLOSEPAREN, Url$1);
  tt(UrlOpenbrace, CLOSEBRACE, Url$1);
  const UrlOpenbraceQ = makeState(Url);
  const UrlOpenbracketQ = makeState(Url);
  const UrlOpenanglebracketQ = makeState(Url);
  const UrlOpenparenQ = makeState(Url);
  ta(UrlOpenbrace, qsAccepting, UrlOpenbraceQ);
  ta(UrlOpenbracket, qsAccepting, UrlOpenbracketQ);
  ta(UrlOpenanglebracket, qsAccepting, UrlOpenanglebracketQ);
  ta(UrlOpenparen, qsAccepting, UrlOpenparenQ);
  const UrlOpenbraceSyms = makeState();
  const UrlOpenbracketSyms = makeState();
  const UrlOpenanglebracketSyms = makeState();
  const UrlOpenparenSyms = makeState();
  ta(UrlOpenbrace, qsNonAccepting);
  ta(UrlOpenbracket, qsNonAccepting);
  ta(UrlOpenanglebracket, qsNonAccepting);
  ta(UrlOpenparen, qsNonAccepting);
  ta(UrlOpenbraceQ, qsAccepting, UrlOpenbraceQ);
  ta(UrlOpenbracketQ, qsAccepting, UrlOpenbracketQ);
  ta(UrlOpenanglebracketQ, qsAccepting, UrlOpenanglebracketQ);
  ta(UrlOpenparenQ, qsAccepting, UrlOpenparenQ);
  ta(UrlOpenbraceQ, qsNonAccepting, UrlOpenbraceQ);
  ta(UrlOpenbracketQ, qsNonAccepting, UrlOpenbracketQ);
  ta(UrlOpenanglebracketQ, qsNonAccepting, UrlOpenanglebracketQ);
  ta(UrlOpenparenQ, qsNonAccepting, UrlOpenparenQ);
  ta(UrlOpenbraceSyms, qsAccepting, UrlOpenbraceSyms);
  ta(UrlOpenbracketSyms, qsAccepting, UrlOpenbracketQ);
  ta(UrlOpenanglebracketSyms, qsAccepting, UrlOpenanglebracketQ);
  ta(UrlOpenparenSyms, qsAccepting, UrlOpenparenQ);
  ta(UrlOpenbraceSyms, qsNonAccepting, UrlOpenbraceSyms);
  ta(UrlOpenbracketSyms, qsNonAccepting, UrlOpenbracketSyms);
  ta(UrlOpenanglebracketSyms, qsNonAccepting, UrlOpenanglebracketSyms);
  ta(UrlOpenparenSyms, qsNonAccepting, UrlOpenparenSyms);
  tt(UrlOpenbracketQ, CLOSEBRACKET, Url$1);
  tt(UrlOpenanglebracketQ, CLOSEANGLEBRACKET, Url$1);
  tt(UrlOpenparenQ, CLOSEPAREN, Url$1);
  tt(UrlOpenbraceQ, CLOSEBRACE, Url$1);
  tt(UrlOpenbracketSyms, CLOSEBRACKET, Url$1);
  tt(UrlOpenanglebracketSyms, CLOSEANGLEBRACKET, Url$1);
  tt(UrlOpenparenSyms, CLOSEPAREN, Url$1);
  tt(UrlOpenbraceSyms, CLOSEPAREN, Url$1);
  tt(Start, LOCALHOST, DomainDotTld);
  tt(Start, NL$1, Nl);
  return {
    start: Start,
    tokens: tk
  };
}
function run(start, input, tokens) {
  let len = tokens.length;
  let cursor = 0;
  let multis = [];
  let textTokens = [];
  while (cursor < len) {
    let state = start;
    let secondState = null;
    let nextState = null;
    let multiLength = 0;
    let latestAccepting = null;
    let sinceAccepts = -1;
    while (cursor < len && !(secondState = state.go(tokens[cursor].t))) {
      textTokens.push(tokens[cursor++]);
    }
    while (cursor < len && (nextState = secondState || state.go(tokens[cursor].t))) {
      secondState = null;
      state = nextState;
      if (state.accepts()) {
        sinceAccepts = 0;
        latestAccepting = state;
      } else if (sinceAccepts >= 0) {
        sinceAccepts++;
      }
      cursor++;
      multiLength++;
    }
    if (sinceAccepts < 0) {
      cursor -= multiLength;
      if (cursor < len) {
        textTokens.push(tokens[cursor]);
        cursor++;
      }
    } else {
      if (textTokens.length > 0) {
        multis.push(initMultiToken(Text, input, textTokens));
        textTokens = [];
      }
      cursor -= sinceAccepts;
      multiLength -= sinceAccepts;
      const Multi = latestAccepting.t;
      const subtokens = tokens.slice(cursor - multiLength, cursor);
      multis.push(initMultiToken(Multi, input, subtokens));
    }
  }
  if (textTokens.length > 0) {
    multis.push(initMultiToken(Text, input, textTokens));
  }
  return multis;
}
function initMultiToken(Multi, input, tokens) {
  const startIdx = tokens[0].s;
  const endIdx = tokens[tokens.length - 1].e;
  const value = input.slice(startIdx, endIdx);
  return new Multi(value, tokens);
}
var INIT = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: false
};
function init() {
  INIT.scanner = init$2(INIT.customSchemes);
  for (let i = 0; i < INIT.tokenQueue.length; i++) {
    INIT.tokenQueue[i][1]({
      scanner: INIT.scanner
    });
  }
  INIT.parser = init$1(INIT.scanner.tokens);
  for (let i = 0; i < INIT.pluginQueue.length; i++) {
    INIT.pluginQueue[i][1]({
      scanner: INIT.scanner,
      parser: INIT.parser
    });
  }
  INIT.initialized = true;
}
function tokenize(str) {
  if (!INIT.initialized) {
    init();
  }
  return run(INIT.parser.start, str, run$1(INIT.scanner.start, str));
}

// ptss-parser/inlineParser.ts
var import_lib = __toESM(require_lib(), 1);
var import_markdown_it_sub = __toESM(require_markdown_it_sub(), 1);
var import_markdown_it_sup = __toESM(require_markdown_it_sup(), 1);
var import_markdown_it_mark = __toESM(require_markdown_it_mark(), 1);

// ptss-parser/mdit_rules/newline_parameterized.ts
var import_utils = __toESM(require_utils(), 1);
function tokenize2(state, silent) {
  let ws, pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  const pmax = state.pending.length - 1;
  const max = state.posMax;
  if (!silent) {
    if (state.env.preserveNewlines) {
      state.pending += "\n";
    } else if (state.env.newlineIsHardBreak) {
      state.push("hardbreak", "br", 0);
    } else if (state.env.twoSpaceNewlineIsHardBreak && pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        ws = pmax - 1;
        while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
          ws--;
        state.pending = state.pending.slice(0, ws);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  if (!state.env.preserveWhitespace) {
    while (pos < max && import_utils.default.isSpace(state.src.charCodeAt(pos))) {
      pos++;
    }
  }
  state.pos = pos;
  return true;
}

// ptss-parser/mdit_rules/escape_parameterized.ts
var import_utils2 = __toESM(require_utils(), 1);
function createRule(stylesheet) {
  if (stylesheet.escapeSyntax.escapeChar === void 0) {
    throw Error(`Escape inline style enabled, but no escape char defined for ${stylesheet.name}}`);
  }
  const escapeCode = stylesheet.escapeSyntax.escapeChar[0].charCodeAt(0);
  const ESCAPE_LOOKUP = stylesheet.escapeSyntax.ESCAPE_INLINE_LOOKUP;
  function tokenize5(state, silent) {
    let pos = state.pos;
    if (state.src.charCodeAt(pos) !== escapeCode)
      return false;
    pos++;
    if (pos >= state.posMax) {
      if (state.env.backslashEOCIsHardBreak) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        state.pos = pos;
        return true;
      }
      return false;
    }
    let ch1 = state.src.charCodeAt(pos);
    if (ch1 === 10 && state.env.backslashNewlineIsHardBreak) {
      if (!silent) {
        state.push("hardbreak", "br", 0);
      }
      pos++;
      if (!state.env.preserveWhitespace) {
        while (pos < state.posMax) {
          ch1 = state.src.charCodeAt(pos);
          if (!import_utils2.default.isSpace(ch1))
            break;
          pos++;
        }
      }
      state.pos = pos;
      return true;
    }
    if (ch1 < 256 && ESCAPE_LOOKUP[ch1] !== void 0) {
      if (!silent) {
        state.pending += ESCAPE_LOOKUP[ch1];
      }
      pos++;
      state.pos = pos;
      return true;
    }
    return false;
  }
  return tokenize5;
}

// ptss-parser/mdit_rules/backticks_parameterized.ts
function createRule2(mode = "trim") {
  if (!["commonmark", "trim"].includes(mode)) {
    throw Error(`invalid backticks mode: "${mode}"`);
  }
  function tokenize5(state, silent) {
    let token, matchStart, matchEnd, closerLength, pos = state.pos;
    const ch = state.src.charCodeAt(pos);
    if (ch !== 96) {
      return false;
    }
    const start = pos;
    pos++;
    const max = state.posMax;
    while (pos < max && state.src.charCodeAt(pos) === 96) {
      pos++;
    }
    const marker = state.src.slice(start, pos);
    const openerLength = marker.length;
    if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
      if (!silent)
        state.pending += marker;
      state.pos += openerLength;
      return true;
    }
    matchEnd = pos;
    while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
      matchEnd = matchStart + 1;
      while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
        matchEnd++;
      }
      closerLength = matchEnd - matchStart;
      if (closerLength === openerLength) {
        if (!silent) {
          token = state.push("code_inline", "code", 0);
          token.markup = marker;
          if (mode === "commonmark") {
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          } else {
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").trim();
          }
        }
        state.pos = matchEnd;
        return true;
      }
      state.backticks[closerLength] = matchStart;
    }
    state.backticksScanned = true;
    if (!silent)
      state.pending += marker;
    state.pos += openerLength;
    return true;
  }
  return tokenize5;
}

// ptss-parser/mdit_rules/gfm_strikethrough.ts
function tokenize3(state, silent) {
  const start = state.pos, marker = state.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker !== 126) {
    return false;
  }
  const scanned = state.scanDelims(state.pos, true);
  const len = scanned.length;
  const ch = String.fromCharCode(marker);
  if (len > 2) {
    return false;
  }
  const pmax = state.pending.length - 1;
  if (pmax >= 0 && state.pending.charCodeAt(pmax) === 126) {
    return false;
  }
  const token = state.push("text", "", 0);
  token.content = ch.repeat(len);
  state.delimiters.push({
    marker,
    length: len,
    token: state.tokens.length - 1,
    end: -1,
    open: scanned.can_open,
    close: scanned.can_close,
    /**
     *! hack. per markdown-it release note, this field has been removed
     *  thought looks like they forgot to remove it from the d.ts file.
     *     ## [12.3.0] - 2021-12-09
     *     ### Changed
     *         - `StateInline.delimiters[].jump` is removed.
     */
    jump: -1
  });
  state.pos += scanned.length;
  return true;
}
function postProcessDelims(state, delimiters) {
  const max = delimiters.length;
  for (let i = 0; i < max; i++) {
    const startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    const endDelim = delimiters[startDelim.end];
    if (startDelim.length !== endDelim.length) {
      continue;
    }
    const openToken = state.tokens[startDelim.token];
    openToken.type = "s_open";
    openToken.tag = "s";
    openToken.nesting = 1;
    openToken.markup = openToken.content;
    openToken.content = "";
    const closeToken = state.tokens[endDelim.token];
    closeToken.type = "s_close";
    closeToken.tag = "s";
    closeToken.nesting = -1;
    closeToken.markup = closeToken.content;
    closeToken.content = "";
  }
}
function postProcess(state) {
  let curr;
  const tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
  postProcessDelims(state, state.delimiters);
  for (curr = 0; curr < max; curr++) {
    const cur = tokens_meta[curr];
    if (cur) {
      postProcessDelims(state, cur.delimiters);
    }
    if (cur && cur.delimiters) {
      postProcessDelims(state, cur.delimiters);
    }
  }
}

// ptss-parser/mdit_rules/unescaper_parameterized.ts
var import_entities = __toESM(require_entities2(), 1);
var import_utils3 = __toESM(require_utils(), 1);
var DIGITAL_ENTITY_TEST_RE = /^#(x[a-f0-9]{1,8}|[0-9]{1,8})$/i;
function replaceEntityPattern(match, name) {
  let code;
  if (Object.hasOwn(import_entities.default, name)) {
    return import_entities.default[name];
  }
  if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
    if ((0, import_utils3.isValidEntityCode)(code)) {
      return (0, import_utils3.fromCodePoint)(code);
    }
  }
  return match;
}
function createUnescaper(decodeHtmlEntities, escapeChar, ESCAPE_LOOKUP = [], syntaxEscapeOnly = false) {
  const ESCAPE_CHAR_RE = escapeChar.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const ESCAPE_RE = new RegExp(ESCAPE_CHAR_RE + `([\0-\xFF])`, "g");
  const ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
  const UNESCAPE_ALL_RE = new RegExp(ESCAPE_RE.source + "|" + ENTITY_RE.source, "gi");
  if (decodeHtmlEntities) {
    return function(str) {
      if (str.indexOf(escapeChar) < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
        if (escaped) {
          const val = ESCAPE_LOOKUP[escaped[0].charCodeAt(0)];
          if (val !== void 0) {
            return syntaxEscapeOnly ? escaped : val;
          }
          return match;
        }
        return replaceEntityPattern(match, entity);
      });
    };
  } else {
    return function(str) {
      if (str.indexOf(escapeChar) < 0) {
        return str;
      }
      return str.replace(ESCAPE_RE, function(match, escaped) {
        const val = ESCAPE_LOOKUP[escaped[0].charCodeAt(0)];
        if (val !== void 0) {
          return syntaxEscapeOnly ? escaped : val;
        }
        return match;
      });
    };
  }
}

// ptss-parser/mdit_rules/parseLinkDest_parameterized.ts
function createLinkDestParser(stylesheet) {
  const allowSpaces = stylesheet.linkDestAllowSpaces;
  if (stylesheet.escapeSyntax.escapeChar === void 0) {
    throw Error(`Escape inline style enabled, but no escape char defined for ${stylesheet.name}}`);
  }
  const escapeCode = stylesheet.escapeSyntax.escapeChar[0].charCodeAt(0);
  const ESCAPE_LOOKUP = stylesheet.escapeSyntax.ESCAPE_LINK_DEST_LOOKUP;
  const unescaper = createUnescaper(true, stylesheet.escapeSyntax.escapeChar, ESCAPE_LOOKUP, true);
  function parseLinkDestination(str, start, max) {
    let code, level, pos = start;
    const result = {
      ok: false,
      pos: 0,
      lines: 0,
      str: ""
    };
    if (str.charCodeAt(pos) === 60) {
      pos++;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 10) {
          return result;
        }
        if (code === 60) {
          return result;
        }
        if (code === 62) {
          result.pos = pos + 1;
          result.str = unescaper(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        }
        if (code === escapeCode && pos + 1 < max) {
          const ch1 = str.charCodeAt(pos + 1);
          if (ch1 < 256 && ESCAPE_LOOKUP[ch1] !== void 0) {
            pos += 2;
            continue;
          }
        }
        pos++;
      }
      return result;
    }
    level = 0;
    while (pos < max) {
      code = str.charCodeAt(pos);
      if (code === 32) {
        if (allowSpaces) {
          if (pos + 1 < max) {
            if (str.charCodeAt(pos + 1) === 34) {
              break;
            }
          }
        } else {
          break;
        }
      }
      if (code < 32 || code === 127) {
        break;
      }
      if (code === escapeCode && pos + 1 < max) {
        const ch1 = str.charCodeAt(pos + 1);
        if (ch1 < 256 && ESCAPE_LOOKUP[ch1] !== void 0) {
          pos += 2;
          continue;
        }
      }
      if (code === 40) {
        level++;
        if (level > 32) {
          return result;
        }
      }
      if (code === 41) {
        if (level === 0) {
          break;
        }
        level--;
      }
      pos++;
    }
    if (start === pos) {
      return result;
    }
    if (level !== 0) {
      return result;
    }
    result.str = unescaper(str.slice(start, pos));
    result.pos = pos;
    result.ok = true;
    return result;
  }
  return parseLinkDestination;
}

// ptss-parser/mdit_rules/reference.ts
var import_utils4 = __toESM(require_utils(), 1);
var isSpace = import_utils4.default.isSpace;
function createRule3() {
  function reference(state, silent) {
    let referent;
    let desc;
    const max = state.posMax;
    if (state.src.charCodeAt(state.pos) !== 91) {
      return false;
    }
    const anchorStart = state.pos + 1;
    const anchorEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
    if (anchorEnd < 0) {
      return false;
    }
    let pos = anchorEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40) {
      pos++;
      referent = "";
      for (; pos < max; pos++) {
        const code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 10) {
          break;
        }
      }
      let start = pos;
      let res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        referent = state.md.normalizeLink(res.str);
        if (state.md.validateLink(referent)) {
          pos = res.pos;
        } else {
          referent = "";
        }
        start = pos;
        for (; pos < max; pos++) {
          const code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          desc = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            const code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
        }
      }
      if (pos < max && state.src.charCodeAt(pos) === 41) {
        pos++;
      } else {
        pos = anchorEnd + 1;
        referent = void 0;
      }
    }
    if (referent === void 0) {
      let ref;
      if (pos < max && state.src.charCodeAt(pos) === 91 && state.src.charCodeAt(pos + 1) !== 94) {
        const start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          ref = state.src.slice(start, pos++);
        } else {
          pos = anchorEnd + 1;
        }
      }
      if (ref === void 0 || ref === "") {
        ref = state.src.slice(anchorStart, anchorEnd);
      }
      const value = state.env.namedValues.valueFor(ref);
      if (value === void 0) {
        return false;
      }
      if (value.type === "href") {
        referent = value.url;
        desc = value.desc;
      } else if (value.type === "element") {
        referent = value.element;
      } else {
        return false;
      }
    }
    if (desc !== void 0) {
    }
    if (!silent) {
      state.pos = anchorStart;
      state.posMax = anchorEnd;
      let token = state.push("link_open", "a", 1);
      token.attrs = [["referent", referent]];
      if (desc) {
        token.attrs.push(["desc", desc]);
      }
      state.linkLevel++;
      state.md.inline.tokenize(state);
      state.linkLevel--;
      token = state.push("link_close", "a", -1);
      state.posMax = max;
    }
    state.pos = pos;
    return true;
  }
  return reference;
}

// ptss-parser/mdit_rules/image.ts
var import_utils5 = __toESM(require_utils(), 1);
var isSpace2 = import_utils5.default.isSpace;
function createRule4() {
  function image(state, silent) {
    let src;
    let desc;
    const max = state.posMax;
    if (state.src.charCodeAt(state.pos) !== 33) {
      return false;
    }
    if (state.src.charCodeAt(state.pos + 1) !== 91) {
      return false;
    }
    const altStart = state.pos + 2;
    const altEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
    if (altEnd < 0) {
      return false;
    }
    let pos = altEnd + 1;
    if (pos < max && state.src.charCodeAt(pos) === 40) {
      pos++;
      src = "";
      for (; pos < max; pos++) {
        const code = state.src.charCodeAt(pos);
        if (!isSpace2(code) && code !== 10) {
          break;
        }
      }
      let start = pos;
      let res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
      if (res.ok) {
        src = state.md.normalizeLink(res.str);
        if (state.md.validateLink(src)) {
          pos = res.pos;
        } else {
          src = "";
        }
        start = pos;
        for (; pos < max; pos++) {
          const code = state.src.charCodeAt(pos);
          if (!isSpace2(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          desc = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            const code = state.src.charCodeAt(pos);
            if (!isSpace2(code) && code !== 10) {
              break;
            }
          }
        }
      }
      if (pos < max && state.src.charCodeAt(pos) === 41) {
        pos++;
      } else {
        pos = altEnd + 1;
        src = void 0;
      }
    }
    if (src === void 0) {
      let ref;
      if (pos < max && state.src.charCodeAt(pos) === 91) {
        const start = pos + 1;
        pos = state.md.helpers.parseLinkLabel(state, pos);
        if (pos >= 0) {
          ref = state.src.slice(start, pos++);
        } else {
          pos = altEnd + 1;
        }
      }
      if (ref === void 0 || ref === "") {
        ref = state.src.slice(altStart, altEnd);
      }
      const value = state.env.namedValues.valueFor(ref);
      if (value === void 0) {
        return false;
      }
      if (value.type !== "href") {
        return false;
      }
      src = value.url;
      desc = value.desc;
    }
    if (!silent) {
      const content = state.src.slice(altStart, altEnd);
      const tokens = [];
      state.md.inline.parse(
        content,
        state.md,
        state.env,
        tokens
      );
      const token = state.push("image", "img", 0);
      token.attrs = [["src", src], ["alt", ""]];
      token.children = tokens;
      token.content = content;
      if (desc) {
        token.attrs.push(["desc", desc]);
      }
    }
    state.pos = pos;
    return true;
  }
  return image;
}

// ptss-parser/mdit_rules/autolink.ts
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.-]{1,31}):([^<>\x00-\x20]*)$/;
function tokenize4(state, silent) {
  let fullUrl, token, ch, pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  const start = state.pos;
  const max = state.posMax;
  for (; ; ) {
    if (++pos >= max)
      return false;
    ch = state.src.charCodeAt(pos);
    if (ch === 60)
      return false;
    if (ch === 62)
      break;
  }
  const url = state.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token = state.push("link_open", "a", 1);
      token.attrs = [["referent", fullUrl]];
      token.markup = "autolink";
      token.info = "auto";
      token = state.push("text", "", 0);
      token.content = state.md.normalizeLinkText(url);
      token = state.push("link_close", "a", -1);
      token.markup = "autolink";
      token.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    fullUrl = state.md.normalizeLink("mailto:" + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token = state.push("link_open", "a", 1);
      token.attrs = [["referent", fullUrl]];
      token.markup = "autolink";
      token.info = "auto";
      token = state.push("text", "", 0);
      token.content = state.md.normalizeLinkText(url);
      token = state.push("link_close", "a", -1);
      token.markup = "autolink";
      token.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
}

// ptss-parser/mdit_rules/note_ref.ts
function createRule5(arg = "") {
  const flags = arg.split(",");
  const refOffset = flags.includes("segregated") ? 1 : 2;
  const noSpace = !flags.includes("spaces");
  function notRef(state, silent) {
    if (state.src.charCodeAt(state.pos) !== 91) {
      return false;
    }
    if (state.src.charCodeAt(state.pos + 1) !== 94) {
      return false;
    }
    let pos = state.pos + 2;
    const max = state.posMax;
    let code;
    while ((code = state.src.charCodeAt(pos)) !== 93) {
      if (pos >= max)
        return false;
      if (noSpace && code === 32)
        return false;
      pos++;
    }
    const ref = state.src.slice(state.pos + refOffset, pos);
    const value = state.env.namedValues.valueFor(ref);
    if (value === void 0) {
      return false;
    }
    if (value.type !== "element") {
      return false;
    }
    if (!silent) {
      const token = state.push("note_ref", "", 0);
      token.attrs = [["referent", value.element]];
    }
    state.pos = pos + 1;
    return true;
  }
  return notRef;
}

// ptss-parser/inlineParser.ts
var RE_OPEN_ANGLE = /<\s*$/;
var RE_TRAILING_SPACE_OR_OPEN_PARENS = /[ \t(]$/;
var InlineParser = class {
  _stylesheet;
  _markdownIt;
  constructor(stylesheet) {
    this._stylesheet = stylesheet;
    this._markdownIt = this.configureMarkdownIt();
  }
  configureMarkdownIt() {
    const markdownIt = new import_lib.default("zero");
    const rules = [];
    for (let styleName of this._stylesheet.inlineStyles) {
      const match = styleName.match(/^(.+?)\((.*)\)$/);
      let styleArg = void 0;
      if (match) {
        styleName = match[1];
        styleArg = match[2];
      }
      if (styleName === "html") {
        markdownIt.set({ "html": true });
      } else if (styleName === "newline") {
        markdownIt.enable("newline");
        markdownIt.inline.ruler.at("newline", tokenize2);
      } else if (styleName === "noteRef") {
        markdownIt.inline.ruler.before("link", "noteRef", createRule5(styleArg));
      } else if (styleName === "reference") {
        markdownIt.inline.ruler.before("link", "reference", createRule3());
      } else if (styleName === "image") {
        markdownIt.enable("image");
        markdownIt.inline.ruler.at("image", createRule4());
      } else if (styleName === "autolink") {
        markdownIt.enable("autolink");
        markdownIt.inline.ruler.at("autolink", tokenize4);
      } else if (styleName === "gfm_strikethrough") {
        markdownIt.inline.ruler.before("emphasis", "gfm_strikethrough", tokenize3);
        markdownIt.inline.ruler2.before("emphasis", "gfm_strikethrough", postProcess);
      } else if (styleName === "escape") {
        markdownIt.enable("escape");
        markdownIt.inline.ruler.at("escape", createRule(this._stylesheet));
      } else if (styleName === "backticks") {
        markdownIt.enable("backticks");
        markdownIt.inline.ruler.at("backticks", createRule2(styleArg));
      } else if (styleName === "bare_links") {
      } else if (styleName === "checkbox_text") {
      } else if (styleName === "subscript") {
        markdownIt.use(import_markdown_it_sub.default);
      } else if (styleName === "superscript") {
        markdownIt.use(import_markdown_it_sup.default);
      } else if (styleName === "text_highlight") {
        markdownIt.use(import_markdown_it_mark.default);
      } else {
        rules.push(styleName);
      }
    }
    markdownIt.enable(rules);
    markdownIt.normalizeLink = (s) => s;
    markdownIt.helpers.parseLinkDestination = createLinkDestParser(this._stylesheet);
    return markdownIt;
  }
  /**
   * Implements the PTSS Expressions `parse` function.
   *
   *
   * Whitespace Handling
   * -------------------
   * todo![stir, spec] ☸️ Unlike HTML and Markdown, STIR is not designed for
   *  editor convenience. It is designed for abstractness and zero-ambiguity.
   *  All whitespace is considered deliberate.
   *
   *  i.e. this except from MDN on HTML whitespace DOES NOT APPLY to STIR:
   *
   *  > These characters allow you to format your code in a way that will
   *  > make it easily readable by yourself and other people. In fact, much
   *  > of our source code is full of these whitespace characters, and we
   *  > only tend to get rid of it in a production build step to reduce
   *  > code download sizes.
   *
   *  - from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace
   *
   *  CONSIDER all of the CSS whitespace options and consider supporting
   *  some or all of them.
   *
   * @param {string} inlineText
   * @param {string[]} parseArgs - ptss `parse` expression args
   * @param {NamedValues} namedValues
   * @return {InlineSequence}
   */
  parse(inlineText, parseArgs = [], namedValues) {
    const env = {
      namedValues,
      preserveWhitespace: false,
      preserveNewlines: false,
      newlineIsHardBreak: false,
      backslashNewlineIsHardBreak: false,
      backslashEOCIsHardBreak: false,
      twoSpaceNewlineIsHardBreak: false
    };
    for (const arg of parseArgs) {
      if (arg === "preserveWhitespace")
        env.preserveWhitespace = true;
      else if (arg === "preserveNewlines")
        env.preserveNewlines = true;
      else if (arg === "newlineIsHardBreak")
        env.newlineIsHardBreak = true;
      else if (arg === "backslashNewlineIsHardBreak")
        env.backslashNewlineIsHardBreak = true;
      else if (arg === "backslashEOCIsHardBreak")
        env.backslashEOCIsHardBreak = true;
      else if (arg === "twoSpaceNewlineIsHardBreak")
        env.twoSpaceNewlineIsHardBreak = true;
      else
        throw Error(`unrecognized parse option: '${arg}'`);
    }
    if (!env.preserveWhitespace) {
      inlineText = inlineText.trim();
    }
    const tokens = new Array();
    this._markdownIt.inline.parse(inlineText, this._markdownIt, env, tokens);
    if (tokens.length === 0) {
      return "";
    }
    const tmp = new Inline2("TMP");
    this.convertTokens(tmp, tokens, namedValues);
    return tmp.body;
  }
  convertTokens(root, tokens, namedValues) {
    const bare_links = this._stylesheet.inlineStyles.includes("bare_links");
    const checkbox_text = this._stylesheet.inlineStyles.includes("checkbox_text");
    let curInline = root;
    let newInline;
    const stack = [];
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      switch (token.type) {
        case "text":
          if (i === 0 && checkbox_text) {
            if (token.content.startsWith("[ ] ")) {
              newInline = new Inline2("checkbox");
              curInline.bodyAppend(newInline);
              token.content = token.content.slice(3);
            } else if (token.content.startsWith("[x] ")) {
              newInline = new Inline2("checkbox");
              newInline.checked = true;
              curInline.bodyAppend(newInline);
              token.content = token.content.slice(3);
            }
          }
          if (bare_links && curInline.type !== "xref") {
            curInline.bodyAppend(this.parseBareLinks(token.content));
          } else {
            curInline.bodyAppend(token.content);
          }
          break;
        case "text_special":
          curInline.bodyAppend(token.content);
          break;
        case "softbreak":
          curInline.bodyAppend("\n");
          break;
        case "hardbreak":
          curInline.bodyAppend(new Inline2("linebreak"));
          break;
        case "em_open":
          stack.push(curInline);
          newInline = new Inline2("emph");
          curInline.bodyAppend(newInline);
          curInline = newInline;
          break;
        case "em_close":
          curInline = stack.pop();
          break;
        case "strong_open":
          stack.push(curInline);
          newInline = new Inline2("strong");
          curInline.bodyAppend(newInline);
          curInline = newInline;
          break;
        case "strong_close":
          curInline = stack.pop();
          break;
        case "s_open":
          stack.push(curInline);
          newInline = new Inline2("strike");
          curInline.bodyAppend(newInline);
          curInline = newInline;
          break;
        case "s_close":
          curInline = stack.pop();
          break;
        case "sub_open":
          stack.push(curInline);
          newInline = new Inline2("subscript");
          curInline.bodyAppend(newInline);
          curInline = newInline;
          break;
        case "sub_close":
          curInline = stack.pop();
          break;
        case "sup_open":
          stack.push(curInline);
          newInline = new Inline2("superscript");
          curInline.bodyAppend(newInline);
          curInline = newInline;
          break;
        case "sup_close":
          curInline = stack.pop();
          break;
        case "mark_open":
          stack.push(curInline);
          newInline = new Inline2("highlight");
          curInline.bodyAppend(newInline);
          curInline = newInline;
          break;
        case "mark_close":
          curInline = stack.pop();
          break;
        case "link_open":
          stack.push(curInline);
          newInline = new Inline2("xref");
          newInline.referent = token.attrGet("referent") || "";
          newInline.desc = token.attrGet("desc") || void 0;
          curInline.bodyAppend(newInline);
          curInline = newInline;
          break;
        case "link_close":
          if (curInline.body === void 0) {
            curInline.body = "";
          }
          curInline = stack.pop();
          break;
        case "image":
          newInline = new Inline2("image");
          newInline.referent = token.attrGet("src") || "";
          newInline.desc = token.attrGet("desc") || void 0;
          if (token.children && token.children.length > 0) {
            this.convertTokens(newInline, token.children, namedValues);
          } else {
            newInline.body = "";
          }
          curInline.bodyAppend(newInline);
          break;
        case "note_ref":
          newInline = new Inline2("note_ref");
          newInline.referent = token.attrGet("referent") || "";
          curInline.bodyAppend(newInline);
          break;
        case "code_inline":
          newInline = new Inline2("code");
          newInline.body = token.content;
          curInline.bodyAppend(newInline);
          break;
        case "html_inline":
          newInline = new Inline2("html_inline");
          newInline.body = token.content;
          curInline.bodyAppend(newInline);
          break;
        default:
          throw Error(`unknown token type: "${token.type}"`);
      }
    }
  }
  // https://linkify.js.org/docs/options.html
  // https://github.com/Hypercontext/linkifyjs
  parseBareLinks(text) {
    const tokens = tokenize(text);
    if (tokens.length === 1 && !tokens[0].isLink) {
      return text;
    }
    const seq = [];
    let canLink = true;
    for (const tok of tokens) {
      if (canLink && tok.isLink) {
        const irRef = new Inline2("xref");
        irRef.referent = tok.toHref();
        irRef.bodyAppend(tok.v);
        seq.push(irRef);
        canLink = false;
      } else {
        seq.push(tok.v);
        canLink = RE_TRAILING_SPACE_OR_OPEN_PARENS.test(tok.v) && !RE_OPEN_ANGLE.test(tok.v);
      }
    }
    return seq;
  }
};

// ptss-parser/parser.ts
var Parser = class {
  _styleSheet;
  _options;
  _inlineParser;
  constructor(ptss, options = {}) {
    this._styleSheet = ptss;
    this._options = options;
    this._inlineParser = new InlineParser(this._styleSheet);
    this._styleSheet.initAndValidate();
  }
  /**
   *  The main parsing function.  Returns an intermediate representation (IR) of the parsed document.
   */
  parse(src) {
    const namedValues = new NamedValues();
    const blockTreeParser = new BlockTreeParser(
      src,
      this._styleSheet,
      "structured_text_intermediate_representation",
      namedValues
    );
    const rootElem = blockTreeParser.parse();
    this.parseBlockInlines(rootElem, namedValues);
    this.declareExports(namedValues, rootElem);
    return rootElem;
  }
  /**
   * Recurse the tree of ir.Blocks, parsing content marked for inline parsing.
   *
   * todo[arch] style specified inline parsing and parsing dependency management
   *            ----------------------------------------------------------------
   *   UPDATE: Implementation of the plan below is in progress. The TO_INLINE_PARSE
   *   object mentioned below is implemented as a special type of ir.Inline.
   *   -----------
   *   I've had an epiphany that flies two birds on one wing:
   *   - Bird One: How to know which text fields need inline parsing. How do we
   *               *let the style design* determine this?
   *   - Bird Two: How to deal with dependencies across files when implementing
   *               TextAssembly? i.e. During File A parsing, we encounter link
   *               target name that can only be resolved after parsing File B.
   *   THE ONE WING:
   *   1. Define a TO_INLINE_PARSE object type that means "determine my final
   *      value by inline-parsing the string value I hold".
   *   2. Change the def of ir.InlineSequence to be:
   *          `string | Inline | TO_INLINE_PARSE | (Inline | string | TO_INLINE_PARSE)[]`
   *      This does NOT change the STIR spec. It's just something that TextPlain
   *      does *temporarily* *internally*.
   *   3. The Property Expression 'parseInlines' function (see note for `ir.Block.bodyIsInline`)
   *      when executed will yield a TO_INLINE_PARSE holding the value of the
   *      function's input. e.g.
   *              (parseInlines (trim (body)))
   *      will yield:
   *               TO_INLINE_PARSE{ value: <string output of (trim (body))> }
   *   4. Whenever an attempt to inline parse any value is blocked by a dependency
   *      that is not yet resolved (i.e. another file needs to be parsed
   *      first), that value will be hot-swapped with:
   *               TO_INLINE_PARSE{ value: <value>  dependency: <dependency> }
   *      Alternatively, it will be hot-swapped with
   *               TO_INLINE_PARSE{ value: <value> }
   *      and a reference will be added to a registry tracking all TO_INLINE_PARSE
   *      by dependency:
   *               registry.add( <dependency> : <ref to TO_INLINE_PARSE>
   *   5. When a dependency is resolved, the TO_INLINE_PARSE is in turn hot-swapped
   *      out by the result of inline-parsing its held value.
   *   .
   *   This solution can handle arbitrarily long and complex dependency chains, by
   *   repeatedly cycling through the registry entries until it is empty. It can
   *   handle any logically sound circular dependencies. If any cycle though the
   *   registry yields not a single success, it means we have a logical UNSOUND
   *   circular dependency. THAT SAID: I think Inlines will only ever have
   *   dependencies on file or block level artifacts, not other Inlines, so this
   *   will never occur.
   *
   * todo![now, named values, references] if an inline defined a named value,
   *     and that named value was referenced before it was defined, we'll have
   *     to resolve those within this method:
   *     - keep track of all unresolved references from the tree traversal
   *     - iterate over that list after the traversal, looking up matches
   *       in NamedValues
   *
   * todo![now, named values, references] does it make sense to hack a
   *     markdown-it inline rule to support named inline spans so that we
   *     can POC the idea and also test the implementation NOW, rather than
   *     wait for our own inline parser? IF IT IS EASY?
   */
  parseBlockInlines(root, namedValues) {
    const inlineParser = this._inlineParser;
    root.traverseBodyTree(function(b) {
      if (Array.isArray(b.title) && b.title[0] === INLINE_PARSE_FLAG) {
        if (b.title.length > 2) {
        }
        b.title = inlineParser.parse(
          b.title[1],
          b.title.slice(2),
          namedValues
        );
      }
      if (Array.isArray(b.body) && b.body[0] === INLINE_PARSE_FLAG) {
        if (b.body.length > 2) {
        }
        b.body = inlineParser.parse(
          b.body[1],
          b.body.slice(2),
          namedValues
        );
        return 1;
      }
      return 0;
    });
  }
  // todo![now, references] should we declare a TS type for the root block
  //   that includes `exports` and the other STIR root properties we're
  //   adding (e.g. in serialization.ts)?
  declareExports(namedValues, rootElem) {
    const exports = {};
    for (const name in namedValues.index) {
      const val = namedValues.index[name];
      if (val.type === "pathed elements") {
        for (const path in val.map) {
          const elem = val.map[path].element;
          if (elem instanceof Block) {
            if (elem.type === "section") {
              exports[path] = { title: elem.title };
            } else {
              exports[path] = { title: elem.type };
            }
          } else {
            exports[path] = { title: elem.type };
          }
        }
      }
    }
    rootElem.exports = exports;
  }
};

// ptss-parser/sheets/commonmark.ptss.ts
function newCommonMarkSheet(options) {
  const stylesheet = new Stylesheet("CommonMark");
  const strict = options?.strict === true;
  let defaultIndentOption;
  let leftPadding;
  let indentedCodeCanInterruptPara;
  if (strict) {
    stylesheet.sloppyMargin = 0;
    defaultIndentOption = "optional";
    leftPadding = "per first line";
    indentedCodeCanInterruptPara = true;
  } else {
    stylesheet.sloppyMargin = 3;
    defaultIndentOption = "no";
    leftPadding = "sloppy";
    indentedCodeCanInterruptPara = false;
  }
  stylesheet.escapeSyntax.escapeChar = "\\";
  stylesheet.escapeSyntax.escapeLiterals = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
  stylesheet.linkDestAllowSpaces = false;
  const para = stylesheet.get("Paragraph");
  para.lazyContinuation = !strict;
  para.irNode.body = new Expression(
    [
      "parseInlines",
      ["trim", ["body"]],
      "backslashNewlineIsHardBreak",
      "twoSpaceNewlineIsHardBreak"
    ]
  );
  const atx = new ChunkStyle("ATX Heading", stylesheet);
  atx.irNode.type = new Expression("heading");
  atx.canInterruptParagraph = true;
  atx.canInterruptLazy = true;
  atx.headPattern = /(#{1,6})(?=[ \t]|$)/ym;
  atx.bodyPattern = /(?:[ \t]+(.*?))??(?:[ \t]+#+)?[ \t]*$/ym;
  atx.maxLines = 1;
  atx.indent = defaultIndentOption;
  atx.irNode.level = new Expression(["length", ["head", 1]]);
  atx.irNode.body = new Expression(["parseInlines", ["first", ["body", 1], ""]]);
  const thematicBreak = new ChunkStyle("Thematic Break", stylesheet);
  thematicBreak.irNode.type = new Expression("thematic_break");
  thematicBreak.headPattern = /(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/ym;
  thematicBreak.maxLines = 1;
  thematicBreak.canInterruptParagraph = true;
  thematicBreak.canInterruptLazy = true;
  thematicBreak.indent = defaultIndentOption;
  const setext = new ChunkStyle("Setext Heading", stylesheet);
  setext.irNode.type = new Expression("heading");
  setext.tailPattern = /((=+|-+)[ \t]*$)/ym;
  setext.consumesBackChunk = true;
  setext.maxLines = 5;
  setext.indent = defaultIndentOption;
  setext.canInterruptParagraph = false;
  setext.canInterruptLazy = false;
  setext.lazyContinuation = false;
  setext.irNode.level = new Expression(["map", ["at", ["tail", 2], 0], { "=": 1, "-": 2 }]);
  setext.irNode.body = new Expression(["parseInlines", ["trim", ["body"]]]);
  const linkRefDef = new ChunkStyle("Link Ref Definition", stylesheet);
  linkRefDef.canInterruptParagraph = false;
  linkRefDef.canInterruptLazy = false;
  linkRefDef.lazyContinuation = false;
  linkRefDef.headPattern = /\[/y;
  linkRefDef.bodyPattern = /((?:[^\\[\]]|\\.){0,1000})]:\s*(?:<((?:[^<>\n\\\x00]|\\.)*)>|([^ <\n]\S*))\s*(\s(?:"((?:\\\S|[^"\x00])*)"|'((?:\\\S|[^'\x00])*)'|\(((?:\\\S|[^()\x00])*)\))\s*?)?$/ym;
  linkRefDef.indent = defaultIndentOption;
  linkRefDef.ptNamedValue = {
    type: "href",
    name: new Expression(["replace", ["trim", ["body", 1]], /[ \t\r\n]+/, " "]),
    value: new Expression(["first", ["body", 2], ["body", 3], ""]),
    description: new Expression(["first", ["body", 5], ["body", 6], ["body", 7], ""])
  };
  const blockQuote = new ContainerStyle("Block Quote", stylesheet);
  blockQuote.irNode.type = new Expression("block_quote");
  blockQuote.leftBorder = ">";
  blockQuote.leftPadding = leftPadding;
  blockQuote.canInterruptParagraph = true;
  blockQuote.canInterruptLazy = true;
  blockQuote.indent = defaultIndentOption;
  blockQuote.body = "BLOCKS";
  const fencedCodeTick = new ContainerStyle("Backtick Fenced Code Block", stylesheet);
  fencedCodeTick.irNode.type = new Expression("code_block");
  fencedCodeTick.topBorder = "`";
  fencedCodeTick.topBorderMinLength = 3;
  fencedCodeTick.righter = /([^`]*?)$/ym;
  fencedCodeTick.body = "RAW_NL";
  fencedCodeTick.canInterruptParagraph = true;
  fencedCodeTick.canInterruptLazy = true;
  fencedCodeTick.indent = defaultIndentOption;
  fencedCodeTick.irNode.info = new Expression(["unescape", ["trim", ["righter", 0]]]);
  const fencedCodeTilde = new ContainerStyle("Tilde Fenced Code Block", stylesheet);
  fencedCodeTilde.irNode.type = new Expression("code_block");
  fencedCodeTilde.topBorder = "~";
  fencedCodeTilde.topBorderMinLength = 3;
  fencedCodeTilde.righter = /(.*?)$/ym;
  fencedCodeTilde.body = "RAW_NL";
  fencedCodeTilde.canInterruptParagraph = true;
  fencedCodeTilde.canInterruptLazy = true;
  fencedCodeTilde.indent = defaultIndentOption;
  fencedCodeTilde.irNode.info = new Expression(["unescape", ["trim", ["righter", 0]]]);
  const indentedCode = new ContainerStyle("Indented Code Block", stylesheet);
  indentedCode.irNode.type = new Expression("code_block");
  indentedCode.indent = "markdown(4,4)";
  indentedCode.body = "RAW_NL";
  indentedCode.canInterruptParagraph = indentedCodeCanInterruptPara;
  indentedCode.canInterruptLazy = indentedCodeCanInterruptPara;
  const list = new ListStyle("List", stylesheet);
  list.unorderedMarkers = "-*+";
  list.orderedMarkers = ".)";
  list.indent = defaultIndentOption;
  const htmlCodeBlock = new HTMLBlockStyle("HTML Block", stylesheet);
  htmlCodeBlock.indent = defaultIndentOption;
  stylesheet.blockStyles.push(
    atx,
    setext,
    //! above Thematic Break in back matching mode two own '------'
    blockQuote,
    thematicBreak,
    //! above List so can match '- - -'
    list,
    linkRefDef,
    fencedCodeTick,
    fencedCodeTilde,
    indentedCode,
    htmlCodeBlock
  );
  if (strict) {
    stylesheet.remove("Indented Code Block");
    stylesheet.blockStyles.unshift(indentedCode);
  }
  stylesheet.inlineStyles = [
    "autolink",
    "backticks(commonmark)",
    "emphasis",
    "entity",
    "escape",
    "html_inline",
    "image",
    "reference",
    "newline",
    "html"
  ];
  return stylesheet;
}

// ptss-parser/sheets/commonmark-fwd.ptss.ts
function newCommonMarkFWDSheet(options) {
  const stylesheet = newCommonMarkSheet(options);
  stylesheet.name = "CommonMark-FWD";
  const setext = stylesheet.remove("Setext Heading");
  setext.consumesBackChunk = false;
  stylesheet.blockStyles.push(setext);
  return stylesheet;
}

// ptss-parser/sheets/gfm.ptss.ts
function newGFMStylesheet(options) {
  const stylesheet = newCommonMarkSheet(options);
  stylesheet.name = "GitHub-Flavored Markdown";
  const table = new TableStyle("GFM Table", stylesheet);
  table.tableType = "sv";
  table.heading = "delimited, required";
  table.headingDelim = "-";
  table.delimIntersection = "|";
  table.sideBorder = "|";
  table.sideBorderLeftRule = "lazy";
  table.sideBorderRightRule = "lazy";
  table.columnsDelim = "|";
  table.columnsNumber = "per head delim";
  table.columnsAlignIndicator = ":";
  table.bodyRowAtLeastOneMarker = "no";
  table.bodyRowTooShort = "add-empty";
  table.bodyRowTooLong = "truncate";
  table.gfmQuirks = true;
  stylesheet.insertAbove("Setext Heading", table);
  const footnote = new ContainerStyle("Footnote", stylesheet);
  footnote.hangingIndent = 4;
  footnote.marker = /\[(\^(\S+))]:/y;
  footnote.body = "BLOCKS";
  footnote.irNode.type = new Expression("note");
  footnote.irNode.subType = new Expression("footnote");
  footnote.ptNamedValue = {
    type: "element",
    // GFM has a segregated note namespace, where `^` prefixes all note names and references
    name: new Expression(["marker", 1]),
    value: "self"
  };
  stylesheet.insertAbove("Link Ref Definition", footnote);
  stylesheet.inlineStyles.splice(stylesheet.inlineStyles.indexOf("reference"), 0, "noteRef(segregated)");
  stylesheet.inlineStyles.push("gfm_strikethrough");
  stylesheet.inlineStyles.push("checkbox_text");
  return stylesheet;
}

// ptss-parser/sheets/pandoc-markdown-strict.ptss.ts
function newPandocMarkdownStrictStylesheet(options) {
  const stylesheet = newCommonMarkSheet(options);
  stylesheet.name = "Pandoc Markdown (Strict)";
  stylesheet.escapeSyntax.escapeLiterals = '\\`*_{}[]()>#+-.!"~';
  stylesheet.linkDestAllowSpaces = true;
  const linkRefDef = stylesheet.get("Link Ref Definition");
  linkRefDef.bodyPattern = /((?:[^\\[\]]|\\.){0,1000})]:\s*(?:<((?:[^<>\n\\\x00]|\\.)*)>|([^ <\n][^\n]*))\s*(\s(?:"((?:\\\S|[^"\x00])*)"|'((?:\\\S|[^'\x00])*)'|\(((?:\\\S|[^()\x00])*)\))\s*?)?$/ym;
  const para = stylesheet.get("Paragraph");
  para.irNode.body = new Expression(
    [
      "parseInlines",
      ["trim", ["body"]],
      "twoSpaceNewlineIsHardBreak"
    ]
  );
  const setext = stylesheet.remove("Setext Heading");
  setext.consumesBackChunk = false;
  setext.maxLines = 2;
  setext.canInterruptParagraph = false;
  setext.canInterruptLazy = false;
  stylesheet.insertAbove("ATX Heading", setext);
  const atx = stylesheet.get("ATX Heading");
  atx.headPattern = /(#{1,6})(?!#)/ym;
  atx.bodyPattern = /(?:[ \t]*(.*?))??(?:[ \t]+#+)?[ \t]*$/ym;
  atx.canInterruptParagraph = true;
  atx.canInterruptLazy = true;
  const list = stylesheet.get("List");
  list.orderedMarkers = ".";
  list.honorStartNum = false;
  list.canInterruptParagraph = false;
  list.canInterruptParaWithinList = true;
  list.canInterruptLazy = true;
  const th = stylesheet.get("Thematic Break");
  th.canInterruptParagraph = false;
  th.canInterruptLazy = false;
  stylesheet.remove("Backtick Fenced Code Block");
  stylesheet.remove("Tilde Fenced Code Block");
  const indentedCodeBlock = stylesheet.get("Indented Code Block");
  indentedCodeBlock.irNode.body = new Expression(["replace", ["body"], /\n$/, ""]);
  stylesheet.inlineStyles[stylesheet.inlineStyles.indexOf("backticks(commonmark)")] = "backticks(trim)";
  return stylesheet;
}

// ptss-parser/sheets/pandoc-markdown.ptss.ts
function newPandocMarkdownStylesheet(options) {
  const stylesheet = newPandocMarkdownStrictStylesheet(options);
  stylesheet.name = "Pandoc Markdown";
  const commonmark = newCommonMarkSheet(options);
  stylesheet.escapeSyntax.escapeLiterals = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ 	";
  stylesheet.escapeSyntax.escapeMappings = [[" ", "\xA0"], ["	", "\xA0"]];
  const para = stylesheet.get("Paragraph");
  para.irNode.body = new Expression(
    [
      "parseInlines",
      ["trim", ["body"]],
      "backslashNewlineIsHardBreak",
      "backslashEOCIsHardBreak",
      "twoSpaceNewlineIsHardBreak"
    ]
  );
  const atx = stylesheet.get("ATX Heading");
  atx.canInterruptParagraph = false;
  atx.canInterruptLazy = false;
  const blockquote = stylesheet.get("Block Quote");
  blockquote.canInterruptParagraph = false;
  const list = stylesheet.get("List");
  list.honorStartNum = true;
  list.orderedMarkers = ".)";
  const pipeTable = new TableStyle("Pipe Table", stylesheet);
  pipeTable.tableType = "sv";
  pipeTable.canInterruptParagraph = false;
  pipeTable.heading = "delimited, required";
  pipeTable.headingDelim = "-";
  pipeTable.delimIntersection = "|+";
  pipeTable.sideBorder = "|";
  pipeTable.sideBorderLeftRule = "lazy";
  pipeTable.sideBorderRightRule = "lazy";
  pipeTable.columnsDelim = "|";
  pipeTable.columnsNumber = "per head delim";
  pipeTable.columnsAlignIndicator = ":";
  pipeTable.bodyRowTooShort = "add-empty";
  pipeTable.bodyRowTooLong = "truncate";
  stylesheet.insertAbove("ATX Heading", pipeTable);
  const footnote = new ContainerStyle("Footnote", stylesheet);
  footnote.hangingIndent = 4;
  footnote.marker = /\[(\^(\S+))]:/y;
  footnote.body = "BLOCKS";
  footnote.irNode.type = new Expression("note");
  footnote.irNode.subType = new Expression("footnote");
  footnote.ptNamedValue = {
    type: "element",
    // Pandoc has a segregated note namespace, where `^` prefixes all note names and references
    name: new Expression(["marker", 1]),
    value: "self"
  };
  stylesheet.insertAbove("Link Ref Definition", footnote);
  const backTick = commonmark.get("Backtick Fenced Code Block");
  backTick.styleSheet = stylesheet;
  backTick.irNode.body = new Expression(["replace", ["body"], /\n$/, ""]);
  stylesheet.insertAbove("HTML Block", backTick);
  const tilde = commonmark.get("Tilde Fenced Code Block");
  tilde.styleSheet = stylesheet;
  tilde.irNode.body = new Expression(["replace", ["body"], /\n$/, ""]);
  stylesheet.insertAbove("HTML Block", tilde);
  const lineBlock = new ContainerStyle("Line Block", stylesheet);
  lineBlock.irNode.type = new Expression("pre");
  lineBlock.leftBorder = "|";
  lineBlock.leftPadding = "yes";
  lineBlock.canInterruptParagraph = false;
  lineBlock.indent = "no";
  lineBlock.body = "RAW";
  lineBlock.irNode.body = new Expression(
    [
      "parseInlines",
      [
        "replace",
        [
          "replace",
          [
            "replace",
            [
              "replace",
              ["body"],
              / +$/gm,
              ""
            ],
            /([^\n ]) +/gm,
            "$1[SP]"
          ],
          / /gm,
          "\xA0"
        ],
        /\[SP]/gm,
        " "
      ],
      "preserveNewlines",
      "preserveWhitespace"
    ]
  );
  stylesheet.blockStyles.push(lineBlock);
  stylesheet.inlineStyles.splice(stylesheet.inlineStyles.indexOf("reference"), 0, "noteRef(segregated)");
  stylesheet.inlineStyles.push("strikethrough");
  stylesheet.inlineStyles.push("subscript");
  stylesheet.inlineStyles.push("superscript");
  stylesheet.inlineStyles.push("checkbox_text");
  return stylesheet;
}

// ptss-parser/sheets/markdown_hs.ptss.ts
function newMarkdownHSStylesheet(options) {
  const stylesheet = newGFMStylesheet({ strict: true });
  stylesheet.name = "MarkdownHS";
  const setext = stylesheet.remove("Setext Heading");
  setext.name = "Setext Section Heading";
  setext.irNode.type = new Expression("section");
  setext.consumesBackChunk = false;
  setext.irNode.title = new Expression(["parseInlines", ["trim", ["body"]]]);
  delete setext.irNode.body;
  const atx = stylesheet.remove("ATX Heading");
  atx.name = "ATX Section Heading";
  atx.irNode.type = new Expression("section");
  atx.canInterruptParagraph = false;
  atx.irNode.title = new Expression(["parseInlines", ["first", ["body", 1], ""]]);
  delete atx.irNode.body;
  const thematicBreak = stylesheet.remove("Thematic Break");
  const linkRefDef = stylesheet.remove("Link Ref Definition");
  const pipeTable = stylesheet.remove("GFM Table");
  pipeTable.name = "Pipe Table SV";
  pipeTable.indent = "optional";
  pipeTable.heading = "delimited, optional";
  pipeTable.delimIntersection = "|+";
  pipeTable.sideBorderLeftRule = "optional";
  pipeTable.sideBorderRightRule = "match";
  pipeTable.gfmQuirks = false;
  const list = stylesheet.remove("List");
  const fencedCodeTick = stylesheet.remove("Backtick Fenced Code Block");
  const fencedCodeTilde = stylesheet.remove("Tilde Fenced Code Block");
  const emailBlockQuote = stylesheet.remove("Block Quote");
  emailBlockQuote.name = "Email-Style Block Quote";
  stylesheet.remove("Indented Code Block");
  const indentedBlockquote = new ContainerStyle("Indented Block Quotation", stylesheet);
  indentedBlockquote.irNode.type = new Expression("block_quote");
  indentedBlockquote.indent = "markdown(4,999)";
  const verse = new ContainerStyle("Verse", stylesheet);
  verse.irNode.type = new Expression("verse");
  verse.canInterruptParagraph = false;
  verse.canInterruptLazy = false;
  verse.indent = "markdown(2,3)";
  verse.body = "RAW_NL";
  const htmlCodeBlock = stylesheet.remove("HTML Block");
  const footnote = stylesheet.remove("Footnote");
  if (stylesheet.blockStyles.length > 0) {
    throw Error(`all inherited styles should have been temporarily removed at this point. but ${stylesheet.blockStyles[0].name} was not.`);
  }
  stylesheet.blockStyles.push(
    setext,
    atx,
    pipeTable,
    list,
    linkRefDef,
    fencedCodeTick,
    fencedCodeTilde,
    emailBlockQuote,
    thematicBreak,
    indentedBlockquote,
    verse,
    footnote,
    htmlCodeBlock
  );
  return stylesheet;
}

// ptss-parser/sheets/plainjane.ptss.ts
function newPlainJaneStylesheet(options) {
  const stylesheet = new Stylesheet("PlainJane");
  stylesheet.escapeSyntax.escapeChar = "\\";
  stylesheet.escapeSyntax.escapeLiterals = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
  const para = stylesheet.get("Paragraph");
  para.irNode.body = new Expression(
    [
      "parseInlines",
      ["trim", ["body"]],
      "newlineIsHardBreak"
    ]
  );
  const setext = new ChunkStyle("Setext Section Heading", stylesheet);
  setext.irNode.type = new Expression("section");
  setext.tailPattern = /((=+|-+)[ \t]*$)/ym;
  setext.maxLines = 5;
  setext.indent = "optional";
  setext.canInterruptParagraph = false;
  setext.irNode.level = new Expression(["map", ["at", ["tail", 2], 0], { "=": 1, "-": 2 }]);
  setext.irNode.title = new Expression(["parseInlines", ["trim", ["body"]], "newlineIsHardBreak"]);
  const indentedBlockquote = new ContainerStyle("Indented Block Quotation", stylesheet);
  indentedBlockquote.irNode.type = new Expression("block_quote");
  indentedBlockquote.indent = "yes";
  const interjectionHanging = new ContainerStyle("Interjection Hanging", stylesheet);
  interjectionHanging.indent = "optional";
  interjectionHanging.hangingIndent = "auto";
  interjectionHanging.hangingIndentRequired = true;
  interjectionHanging.marker = /‼️|⚠️|🚫|⛔|☠️|ℹ️|🚩|📌|❓|💡|✅|❌/y;
  interjectionHanging.canInterruptParagraph = true;
  interjectionHanging.irNode.type = new Expression("interjection");
  interjectionHanging.irNode.subType = new Expression(
    ["map", ["marker", 0], {
      "\u203C\uFE0F": "important",
      "\u{1F6A9}": "important",
      "\u26A0\uFE0F": "warning",
      // aka caution
      "\u{1F6AB}": "danger",
      // todo[RepoDoc] what makes danger different from warning? just more severe?
      "\u26D4": "danger",
      "\u2620\uFE0F": "danger",
      "\u2139\uFE0F": "info",
      // aka note
      "\u{1F4CC}": "info",
      "\u2753": "question",
      "\u{1F4A1}": "tip",
      "\u2705": "positive",
      "\u274C": "negative"
    }]
  );
  interjectionHanging.irNode.icon = new Expression(["marker", 0]);
  const interjectionPara = new ChunkStyle("Interjection Paragraph", stylesheet);
  interjectionPara.headPattern = /‼️|⚠️|🚫|⛔|☠️|ℹ️|🚩|📌|❓|💡|✅|❌/y;
  interjectionPara.bodyPattern = / *(?:([^\n]+)(?:\\| {2})\s*\n|[*_]{1,3}([^\n]+?)[*_]{1,3} *\n)?([\s\S]*)/y;
  interjectionPara.canInterruptParagraph = false;
  interjectionPara.canInterruptLazy = false;
  interjectionPara.irNode.type = new Expression("interjection");
  interjectionPara.irNode.subType = new Expression(
    ["map", ["head", 0], {
      "\u203C\uFE0F": "important",
      "\u{1F6A9}": "important",
      "\u26A0\uFE0F": "warning",
      // aka caution
      "\u{1F6AB}": "danger",
      // todo[RepoDoc] what makes danger different from warning? just more severe?
      "\u26D4": "danger",
      "\u2620\uFE0F": "danger",
      "\u2139\uFE0F": "info",
      // aka note
      "\u{1F4CC}": "info",
      "\u2753": "question",
      "\u{1F4A1}": "tip",
      "\u2705": "positive",
      "\u274C": "negative"
    }]
  );
  interjectionPara.irNode.icon = new Expression(["head", 0]);
  interjectionPara.irNode.title = new Expression(["parseInlines", ["trim", ["first", ["body", 1], ["body", 2]]]]);
  interjectionPara.irNode.body = new Expression(["parseInlines", ["trim", ["body", 3]]]);
  stylesheet.blockStyles.push(
    setext,
    indentedBlockquote,
    interjectionHanging,
    interjectionPara
  );
  stylesheet.inlineStyles = [
    "autolink",
    "backticks",
    "emphasis",
    "entity",
    "escape",
    "html_inline",
    "image",
    "reference",
    "newline",
    "html"
  ];
  return stylesheet;
}

// ptss-parser/sheets/gracedown.ptss.ts
function newGracedownSheet(options) {
  const stylesheet = newGFMStylesheet(options);
  stylesheet.name = "Gracedown";
  stylesheet.linkDestAllowSpaces = true;
  const interjectionPara = new ChunkStyle("Simple Interjection", stylesheet);
  interjectionPara.headPattern = /‼️|⚠️|🚫|⛔|☠️|ℹ️|🚩|📌|❓|💡|✅|❌/y;
  interjectionPara.bodyPattern = / *(?:([^\n]+)(?:\\| {2})\s*\n|[*_]{1,3}([^\n]+?)[*_]{1,3} *\n)?([\s\S]*)/y;
  interjectionPara.canInterruptParagraph = false;
  interjectionPara.canInterruptLazy = false;
  interjectionPara.irNode.type = new Expression("interjection");
  interjectionPara.irNode.subType = new Expression(
    ["map", ["head", 0], {
      "\u203C\uFE0F": "important",
      "\u{1F6A9}": "important",
      "\u26A0\uFE0F": "warning",
      // aka caution
      "\u{1F6AB}": "danger",
      // todo[RepoDoc] what makes danger different from warning? just more severe?
      "\u26D4": "danger",
      "\u2620\uFE0F": "danger",
      "\u2139\uFE0F": "info",
      // aka note
      "\u{1F4CC}": "info",
      "\u2753": "question",
      "\u{1F4A1}": "tip",
      "\u2705": "positive",
      "\u274C": "negative"
    }]
  );
  interjectionPara.irNode.icon = new Expression(["head", 0]);
  interjectionPara.irNode.title = new Expression(["parseInlines", ["trim", ["first", ["body", 1], ["body", 2]]]]);
  interjectionPara.irNode.body = new Expression(["parseInlines", ["trim", ["body", 3]]]);
  stylesheet.insertAbove("Block Quote", interjectionPara);
  const interjectionHanging = new ContainerStyle("Hanging Interjection", stylesheet);
  interjectionHanging.irNode.type = new Expression("interjection");
  interjectionHanging.indent = "no";
  interjectionHanging.hangingIndent = "marker";
  interjectionHanging.marker = /\* (‼️|⚠️|🚫|⛔|☠️|ℹ️|🚩|📌|💡|✅|❌)/y;
  interjectionHanging.bottomBorder = null;
  interjectionHanging.canInterruptParagraph = true;
  interjectionHanging.canInterruptLazy = true;
  interjectionHanging.irNode.subType = new Expression(
    ["map", ["marker", 1], {
      "\u203C\uFE0F": "important",
      "\u{1F6A9}": "important",
      "\u26A0\uFE0F": "warning",
      // aka caution
      "\u{1F6AB}": "danger",
      // todo[RepoDoc] what makes danger different from warning? just more severe?
      "\u26D4": "danger",
      "\u2620\uFE0F": "danger",
      "\u2139\uFE0F": "info",
      // aka note
      "\u{1F4CC}": "info",
      "\u{1F4A1}": "tip",
      "\u2705": "positive",
      "\u274C": "negative"
    }]
  );
  interjectionHanging.irNode.icon = new Expression(["marker", 1]);
  stylesheet.insertAbove("List", interjectionHanging);
  const interjectionIndented = new ContainerStyle("Indented Interjection", stylesheet);
  interjectionIndented.irNode.type = new Expression("interjection");
  interjectionIndented.indent = "yes";
  interjectionIndented.topBorder = "#";
  interjectionIndented.topBorderMinLength = 1;
  interjectionIndented.righter = /\s*(‼️|⚠️|🚫|⛔|☠️|ℹ️|🚩|📌|💡|✅|❌)\s*([^\n]*)(?:\n|$)/y;
  interjectionIndented.bottomBorder = null;
  interjectionIndented.canInterruptParagraph = true;
  interjectionIndented.canInterruptLazy = true;
  interjectionIndented.irNode.subType = new Expression(
    ["map", ["righter", 1], {
      "\u203C\uFE0F": "important",
      "\u{1F6A9}": "important",
      "\u26A0\uFE0F": "warning",
      // aka caution
      "\u{1F6AB}": "danger",
      // todo[RepoDoc] what makes danger different from warning? just more severe?
      "\u26D4": "danger",
      "\u2620\uFE0F": "danger",
      "\u2139\uFE0F": "info",
      // aka note
      "\u{1F4CC}": "info",
      "\u{1F4A1}": "tip",
      "\u2705": "positive",
      "\u274C": "negative"
    }]
  );
  interjectionIndented.irNode.icon = new Expression(["righter", 1]);
  interjectionIndented.irNode.title = new Expression(["parseInlines", ["trim", ["righter", 2]]]);
  stylesheet.insertAbove("Block Quote", interjectionIndented);
  const interjectionBirdTracked = new ContainerStyle("Bird-Tracked Interjection", stylesheet);
  interjectionBirdTracked.irNode.type = new Expression("interjection");
  interjectionBirdTracked.indent = "no";
  interjectionBirdTracked.topBorder = ">";
  interjectionBirdTracked.topBorderMinLength = 1;
  interjectionBirdTracked.righter = /\s*#{0,6}\s*(‼️|⚠️|🚫|⛔|☠️|ℹ️|🚩|📌|💡|✅|❌)\s*([^\n]*)(?:\n|$)/y;
  interjectionBirdTracked.bottomBorder = null;
  interjectionBirdTracked.leftBorder = ">";
  interjectionBirdTracked.leftPadding = "sloppy";
  interjectionBirdTracked.canInterruptParagraph = true;
  interjectionBirdTracked.canInterruptLazy = true;
  interjectionBirdTracked.irNode.subType = new Expression(
    ["map", ["righter", 1], {
      "\u203C\uFE0F": "important",
      "\u{1F6A9}": "important",
      "\u26A0\uFE0F": "warning",
      // aka caution
      "\u{1F6AB}": "danger",
      // todo[RepoDoc] what makes danger different from warning? just more severe?
      "\u26D4": "danger",
      "\u2620\uFE0F": "danger",
      "\u2139\uFE0F": "info",
      // aka note
      "\u{1F4CC}": "info",
      "\u{1F4A1}": "tip",
      "\u2705": "positive",
      "\u274C": "negative"
    }]
  );
  interjectionBirdTracked.irNode.icon = new Expression(["righter", 1]);
  interjectionBirdTracked.irNode.title = new Expression(["parseInlines", ["trim", ["righter", 2]]]);
  stylesheet.insertAbove("Block Quote", interjectionBirdTracked);
  const table = stylesheet.get("GFM Table");
  table.cell = new Expression(
    [
      "if",
      ["match", ["body"], /<br *\/?>/],
      [
        "parseBlocks",
        ["replace", ["body"], /<br *\/?>/g, "\n"],
        stylesheet,
        "cell"
      ],
      ["parseInlines", ["body"]]
    ]
  );
  const tickFence = stylesheet.get("Backtick Fenced Code Block");
  tickFence.body = "RAW";
  tickFence.irNode.type = new Expression(
    [
      "if",
      ["match", ["righter"], /\s*pre\s*/],
      "pre",
      "code_block"
    ]
  );
  tickFence.irNode.info = new Expression(
    [
      "if",
      ["match", ["righter"], /\s*pre\s*/],
      void 0,
      ["unescape", ["trim", ["righter", 0]]]
    ]
  );
  tickFence.irNode.body = new Expression(
    [
      "if",
      ["match", ["righter"], /\s*pre\s*/],
      ["parseInlines", ["body"], "preserveNewlines", "preserveWhitespace"],
      ["body"]
    ]
  );
  stylesheet.inlineStyles.push("text_highlight");
  return stylesheet;
}

// ptss-parser/sheets/reStructuredText.ptss.ts
function newRSTSheet(options) {
  const stylesheet = new Stylesheet("reStructuredText");
  stylesheet.escapeSyntax.escapeChar = "\\";
  stylesheet.escapeSyntax.escapeLiterals = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
  const thematicBreak = new ChunkStyle("Thematic Break", stylesheet);
  thematicBreak.irNode.type = new Expression("thematic_break");
  thematicBreak.headPattern = /(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/ym;
  thematicBreak.maxLines = 1;
  thematicBreak.canInterruptParagraph = true;
  const list = new ListStyle("List", stylesheet);
  list.unorderedMarkers = "-*+";
  list.orderedMarkers = ".)";
  const defaultIndentContainer = new ContainerStyle("Default Indent Block", stylesheet);
  defaultIndentContainer.irNode.type = new Expression("block_quote");
  defaultIndentContainer.indent = "yes";
  defaultIndentContainer.body = "BLOCKS";
  stylesheet.blockStyles.push(
    thematicBreak,
    list,
    defaultIndentContainer
  );
  stylesheet.inlineStyles = [
    // 'autolink',
    "backticks",
    "emphasis",
    // 'entity',
    "escape"
    // 'html_inline',
    // 'image',
    // 'reference',
    // 'newline',
    // 'html'
  ];
  return stylesheet;
}

// ptss-parser/sheets/kitchen-sink.ptss.ts
function newKitchenSinkStylesheet(options) {
  const stylesheet = new Stylesheet("PTSS Kitchen Sink Demonstration");
  stylesheet.escapeSyntax.escapeChar = "\\";
  stylesheet.escapeSyntax.escapeLiterals = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
  const setext = new ChunkStyle("Setext Section Heading", stylesheet);
  setext.irNode.type = new Expression("section");
  setext.tailPattern = /((=+|-+)[ \t]*$)/ym;
  setext.maxLines = 5;
  setext.indent = "optional";
  setext.canInterruptParagraph = false;
  setext.irNode.level = new Expression(["map", ["at", ["tail", 2], 0], { "=": 1, "-": 2 }]);
  setext.irNode.title = new Expression(["parseInlines", ["trim", ["body"]]]);
  const pipeTable = new TableStyle("Pipe Table SV", stylesheet);
  pipeTable.tableType = "sv";
  pipeTable.indent = "optional";
  pipeTable.heading = "delimited, optional";
  pipeTable.headingDelim = "-";
  pipeTable.delimIntersection = "|+";
  pipeTable.sideBorder = "|";
  pipeTable.sideBorderLeftRule = "optional";
  pipeTable.sideBorderRightRule = "match";
  pipeTable.columnsDelim = "|";
  pipeTable.columnsNumber = "per head delim";
  pipeTable.columnsAlignIndicator = ":";
  const list = new ListStyle("List", stylesheet);
  list.unorderedMarkers = "-*+";
  list.orderedMarkers = ".)";
  list.indent = "optional";
  const fencedCode = new ContainerStyle("Backtick Fenced Code Block", stylesheet);
  fencedCode.irNode.type = new Expression("code_block");
  fencedCode.indent = "optional";
  fencedCode.topBorder = "`";
  fencedCode.topBorderMinLength = 3;
  fencedCode.righter = /([^`]*?)$/ym;
  fencedCode.body = "RAW_NL";
  fencedCode.canInterruptParagraph = true;
  fencedCode.irNode.info = new Expression(["unescape", ["trim", ["righter", 0]]]);
  const emailBlockQuote = new ContainerStyle("Email-Style Block Quote", stylesheet);
  emailBlockQuote.irNode.type = new Expression("block_quote");
  emailBlockQuote.leftBorder = ">";
  emailBlockQuote.leftPadding = "per first line";
  emailBlockQuote.indent = "optional";
  emailBlockQuote.canInterruptParagraph = true;
  const indentedBlockquote = new ContainerStyle("Indented Block Quotation", stylesheet);
  indentedBlockquote.irNode.type = new Expression("block_quote");
  indentedBlockquote.indent = "markdown(4,999)";
  const verse = new ContainerStyle("Verse", stylesheet);
  verse.irNode.type = new Expression("verse");
  verse.canInterruptParagraph = false;
  verse.indent = "markdown(2,3)";
  verse.body = "RAW_NL";
  stylesheet.blockStyles.push(
    setext,
    pipeTable,
    list,
    fencedCode,
    emailBlockQuote,
    indentedBlockquote,
    verse
  );
  stylesheet.inlineStyles = [
    "autolink",
    "backticks",
    "emphasis",
    "entity",
    "escape",
    "html_inline",
    "image",
    "reference",
    "newline",
    "html"
  ];
  return stylesheet;
}

// ptss-parser/sheets/test-composition.ptss.ts
function newTestCompositionsSheet(options) {
  const stylesheet = new Stylesheet("PTSS Test TWO Stylesheet");
  stylesheet.escapeSyntax.escapeChar = "\\";
  stylesheet.escapeSyntax.escapeLiterals = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
  const blockQuote = new ContainerStyle("Block Quote", stylesheet);
  blockQuote.irNode.type = new Expression("block_quote");
  blockQuote.leftBorder = ">";
  blockQuote.leftPadding = "per first line";
  blockQuote.canInterruptParagraph = true;
  blockQuote.canInterruptLazy = true;
  blockQuote.indent = "optional";
  blockQuote.body = "BLOCKS";
  const list = new ListStyle("List", stylesheet);
  list.unorderedMarkers = "-*+";
  list.orderedMarkers = ".)";
  list.indent = "optional";
  stylesheet.blockStyles.push(
    blockQuote,
    list
  );
  stylesheet.inlineStyles = [
    "autolink",
    "backticks",
    "emphasis",
    "entity",
    "escape",
    "image",
    "noteRef(spaces)",
    "reference",
    "newline"
  ];
  return stylesheet;
}

// ptss-parser/sheets/test-ptss-one.ts
function newTestPtssOneSheet(options) {
  const stylesheet = new Stylesheet("PTSS Test ONE Stylesheet");
  stylesheet.escapeSyntax.escapeChar = "\\";
  stylesheet.escapeSyntax.escapeLiterals = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
  const setextOneTwo = new ChunkStyle("Level 1/2 Setext Heading", stylesheet);
  setextOneTwo.indent = "optional";
  setextOneTwo.headPattern = /(=+|-+)[ \t]*$/ym;
  setextOneTwo.tailPattern = /(=+|-+)[ \t]*$/ym;
  setextOneTwo.canInterruptParagraph = false;
  setextOneTwo.maxLines = 6;
  setextOneTwo.irNode.type = new Expression("heading");
  setextOneTwo.irNode.level = new Expression(["map", ["at", ["head", 1], 0], { "=": 1, "-": 2 }]);
  setextOneTwo.irNode.body = new Expression(["parseInlines", ["trim", ["body"]]]);
  const setextThreeFour = new ChunkStyle("Level 3/4 Setext Heading", stylesheet);
  setextThreeFour.indent = "optional";
  setextThreeFour.tailPattern = /(=+|-+)[ \t]*$/ym;
  setextThreeFour.canInterruptParagraph = false;
  setextThreeFour.maxLines = 5;
  setextThreeFour.irNode.type = new Expression("heading");
  setextThreeFour.irNode.level = new Expression(["map", ["at", ["tail", 1], 0], { "=": 3, "-": 4 }]);
  setextThreeFour.irNode.body = new Expression(["parseInlines", ["trim", ["body"]]]);
  const thematicBreak = new ChunkStyle("Thematic Break", stylesheet);
  thematicBreak.indent = "optional";
  thematicBreak.headPattern = /(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/ym;
  thematicBreak.maxLines = 1;
  thematicBreak.canInterruptParagraph = true;
  thematicBreak.irNode.type = new Expression("thematic_break");
  const warningLine = new ChunkStyle("Warning Line", stylesheet);
  warningLine.indent = "yes";
  warningLine.headPattern = /Warning:\s+/y;
  warningLine.maxLines = 1;
  warningLine.canInterruptParagraph = false;
  warningLine.irNode.type = new Expression("interjection");
  warningLine.irNode.subType = new Expression("warning");
  warningLine.irNode.body = new Expression(["parseInlines", ["body"]]);
  const note = new ChunkStyle("Note Chunk", stylesheet);
  note.headPattern = /^>>\s+/ym;
  note.tailPattern = /\s+<<\s*$/gm;
  note.canInterruptParagraph = false;
  note.irNode.type = new Expression("interjection");
  note.irNode.subType = new Expression("info");
  note.irNode.body = new Expression(["parseInlines", ["body"]]);
  const leftBorderBQ = new ContainerStyle("Left(+) Border Block Quote", stylesheet);
  leftBorderBQ.irNode.type = new Expression("block_quote");
  leftBorderBQ.leftBorder = "+";
  leftBorderBQ.leftPadding = "per first line";
  leftBorderBQ.indent = "optional";
  const fencedCode = new ContainerStyle("Fenced($) Code Block", stylesheet);
  fencedCode.irNode.type = new Expression("code_block");
  fencedCode.topBorder = "$";
  fencedCode.indent = "optional";
  fencedCode.body = "RAW_NL";
  fencedCode.canInterruptParagraph = true;
  const leftBorderCode = new ContainerStyle("Left(|) Border Code Block", stylesheet);
  leftBorderCode.irNode.type = new Expression("code_block");
  leftBorderCode.leftBorder = "|";
  leftBorderCode.leftPadding = "per first line";
  leftBorderCode.indent = "optional";
  leftBorderCode.body = "RAW_NL";
  const indentedCode = new ContainerStyle("Indent(8) Code Block", stylesheet);
  indentedCode.irNode.type = new Expression("code_block");
  indentedCode.indent = "markdown(8,8)";
  indentedCode.body = "RAW_NL";
  const fencedBQ = new ContainerStyle("Fenced(+/) Block Quote", stylesheet);
  fencedBQ.irNode.type = new Expression("block_quote");
  fencedBQ.topBorder = "+/";
  fencedBQ.indent = "optional";
  fencedBQ.canInterruptParagraph = true;
  const boxAsteriskBQ = new ContainerStyle("Asterisk Box Quote", stylesheet);
  boxAsteriskBQ.irNode.type = new Expression("block_quote");
  boxAsteriskBQ.topBorder = "*";
  boxAsteriskBQ.leftBorder = "*";
  boxAsteriskBQ.leftPadding = "per first line";
  boxAsteriskBQ.indent = "optional";
  boxAsteriskBQ.canInterruptParagraph = true;
  const boxAsciiLineBQ = new ContainerStyle("Box(\u2013|) Block Quote", stylesheet);
  boxAsciiLineBQ.irNode.type = new Expression("block_quote");
  boxAsciiLineBQ.topBorder = "\u2013";
  boxAsciiLineBQ.leftBorder = "|";
  boxAsciiLineBQ.leftPadding = "per first line";
  boxAsciiLineBQ.indent = "optional";
  boxAsciiLineBQ.canInterruptParagraph = true;
  const list = new ListStyle("List", stylesheet);
  list.unorderedMarkers = "-*+";
  list.orderedMarkers = ".)";
  const defaultIndentContainer = new ContainerStyle("Default Indent Block", stylesheet);
  defaultIndentContainer.irNode.type = new Expression("block_quote");
  defaultIndentContainer.indent = "yes";
  stylesheet.blockStyles.push(
    setextOneTwo,
    // must be above setextThreeFour which would otherwise match with same bottom border
    setextThreeFour,
    boxAsteriskBQ,
    // requires precedence over thematicBreak
    thematicBreak,
    warningLine,
    note,
    boxAsciiLineBQ,
    fencedBQ,
    leftBorderBQ,
    fencedCode,
    leftBorderCode,
    indentedCode,
    list,
    defaultIndentContainer
  );
  stylesheet.inlineStyles = [
    "autolink",
    "backticks",
    "emphasis",
    "entity",
    "escape",
    "html_inline",
    "image",
    "reference",
    "newline",
    "html"
  ];
  return stylesheet;
}

// ptss-parser/sheets/test-references.ptss.ts
function newTestReferencesSheet(options) {
  const stylesheet = new Stylesheet("PTSS Test TWO Stylesheet");
  stylesheet.escapeSyntax.escapeChar = "\\";
  stylesheet.escapeSyntax.escapeLiterals = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
  const atx = new ChunkStyle("ATX Heading", stylesheet);
  atx.irNode.type = new Expression("heading");
  atx.canInterruptParagraph = true;
  atx.canInterruptLazy = true;
  atx.headPattern = /(#{1,6})(?=[ \t]|$)/ym;
  atx.bodyPattern = /(?:[ \t]+(.*?))??(?:[ \t]+#+)?[ \t]*$/ym;
  atx.maxLines = 1;
  atx.indent = "optional";
  atx.irNode.level = new Expression(["length", ["head", 1]]);
  atx.irNode.body = new Expression(["parseInlines", ["first", ["body", 1], ""]]);
  atx.ptNamedValue = {
    type: "element",
    name: new Expression(["replace", ["trim", ["first", ["body", 1], ""]], /[ \t\r\n]+/, " "]),
    value: "self"
  };
  const footnote = new ContainerStyle("Footnote", stylesheet);
  footnote.hangingIndent = "auto";
  footnote.marker = /\[(\^([^\]]+))]:/y;
  footnote.body = "BLOCKS";
  footnote.irNode.type = new Expression("note");
  footnote.irNode.subType = new Expression("footnote");
  footnote.ptNamedValue = {
    type: "element",
    name: new Expression(["marker", 2]),
    //! test-references non-segregated namespace, so `^` is NOT included
    value: "self"
  };
  const linkDef = new ChunkStyle("Link Ref Definition", stylesheet);
  linkDef.headPattern = /\[\s*([[\w ]+)\s*]:/y;
  linkDef.bodyPattern = /\s*(?:<((?:[^<>\n\\]|\\.)*)>|([^ <\n]\S*))\s*(\s(?:"((?:\\\S|[^"])*)"|'((?:\\\S|[^'])*)'|\(((?:\\\S|[^()])*)\))\s*?)?$/ym;
  linkDef.ptNamedValue = {
    type: "href",
    name: new Expression(["head", 1]),
    value: new Expression(["first", ["body", 1], ["body", 2], ""]),
    description: new Expression(["first", ["body", 4], ["body", 5], ["body", 6], ""])
  };
  const substitutionDef = new ChunkStyle("Substitution Ref Definition", stylesheet);
  substitutionDef.headPattern = /\[\s*([[\w ]+)\s*]:/y;
  substitutionDef.bodyPattern = /\s*(.+)?\s*$/ym;
  substitutionDef.ptNamedValue = {
    type: "substitution",
    name: new Expression(["head", 1]),
    value: new Expression(["parseInlines", ["body", 1]])
  };
  const blockQuote = new ContainerStyle("Block Quote", stylesheet);
  blockQuote.irNode.type = new Expression("block_quote");
  blockQuote.leftBorder = ">";
  blockQuote.leftPadding = "per first line";
  blockQuote.canInterruptParagraph = true;
  blockQuote.canInterruptLazy = true;
  blockQuote.indent = "optional";
  blockQuote.body = "BLOCKS";
  const list = new ListStyle("List", stylesheet);
  list.unorderedMarkers = "-*+";
  list.orderedMarkers = ".)";
  list.indent = "optional";
  const indentedCode = new ContainerStyle("Indented Code Block", stylesheet);
  indentedCode.irNode.type = new Expression("code_block");
  indentedCode.indent = "markdown(4,4)";
  indentedCode.body = "RAW_NL";
  indentedCode.canInterruptParagraph = false;
  indentedCode.canInterruptLazy = false;
  stylesheet.blockStyles.push(
    // has to come first styles with 'optional'
    // indentation for it to every be recognized.
    indentedCode,
    atx,
    footnote,
    // linkDef must come before synonymDef as the latter's RHS is a superset of the former's
    linkDef,
    substitutionDef,
    blockQuote,
    list
  );
  stylesheet.inlineStyles = [
    "autolink",
    "backticks",
    "emphasis",
    "entity",
    "escape",
    "image",
    "noteRef(spaces)",
    "reference",
    "newline"
  ];
  return stylesheet;
}

// ptss-parser/sheets/test-writers-prerogative.ts
function newTestWritersPrerogativeSheet(options) {
  const stylesheet = new Stylesheet("PTSS Test TWO Stylesheet");
  stylesheet.escapeSyntax.escapeChar = "\\";
  stylesheet.escapeSyntax.escapeLiterals = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
  const markerWidthHanging = new ContainerStyle("Marker Width Hanging Indent as Interjection", stylesheet);
  markerWidthHanging.indent = "optional";
  markerWidthHanging.hangingIndent = "marker";
  markerWidthHanging.marker = /↔️/y;
  markerWidthHanging.canInterruptParagraph = true;
  markerWidthHanging.irNode.type = new Expression("interjection");
  markerWidthHanging.irNode.subType = new Expression("width");
  markerWidthHanging.irNode.icon = new Expression(["marker", 0]);
  const markedAutoWidthHanging = new ContainerStyle("Marked Auto Width Hanging Indent as Interjection", stylesheet);
  markedAutoWidthHanging.indent = "optional";
  markedAutoWidthHanging.hangingIndent = "auto";
  markedAutoWidthHanging.marker = /🚗/y;
  markedAutoWidthHanging.canInterruptParagraph = true;
  markedAutoWidthHanging.irNode.type = new Expression("interjection");
  markedAutoWidthHanging.irNode.subType = new Expression("auto");
  markedAutoWidthHanging.irNode.icon = new Expression(["marker", 0]);
  const markedFixedHanging = new ContainerStyle("Marked Fixed Hanging Indent as Interjection", stylesheet);
  markedFixedHanging.indent = "optional";
  markedFixedHanging.hangingIndent = 3;
  markedFixedHanging.marker = /📌/y;
  markedFixedHanging.canInterruptParagraph = true;
  markedFixedHanging.irNode.type = new Expression("interjection");
  markedFixedHanging.irNode.subType = new Expression("pin");
  markedFixedHanging.irNode.icon = new Expression(["marker", 0]);
  const unmarkedFixedIndentFixedHanging = new ContainerStyle("Unmarked Fixed Ident Fixed Hanging Indent as Interjection", stylesheet);
  unmarkedFixedIndentFixedHanging.indent = "optional";
  unmarkedFixedIndentFixedHanging.hangingIndent = 6;
  unmarkedFixedIndentFixedHanging.canInterruptParagraph = false;
  unmarkedFixedIndentFixedHanging.irNode.type = new Expression("interjection");
  unmarkedFixedIndentFixedHanging.irNode.subType = new Expression("unmarked fixed");
  const unmarkedAutoHanging = new ContainerStyle("Unmarked Fixed Hanging Indent as Interjection", stylesheet);
  unmarkedAutoHanging.indent = "optional";
  unmarkedAutoHanging.hangingIndent = "auto";
  unmarkedAutoHanging.canInterruptParagraph = false;
  unmarkedAutoHanging.irNode.type = new Expression("interjection");
  unmarkedAutoHanging.irNode.subType = new Expression("unmarked auto");
  const atx = new ChunkStyle("ATX Heading", stylesheet);
  atx.irNode.type = new Expression("heading");
  atx.canInterruptParagraph = true;
  atx.canInterruptLazy = true;
  atx.headPattern = /(#{1,6})(?=[ \t]|$)/ym;
  atx.bodyPattern = /(?:[ \t]+(.*?))??(?:[ \t]+#+)?[ \t]*$/ym;
  atx.maxLines = 1;
  atx.indent = "optional";
  atx.irNode.level = new Expression(["length", ["head", 1]]);
  atx.irNode.body = new Expression(["parseInlines", ["first", ["body", 1], ""]]);
  const setext = new ChunkStyle("Setext Heading", stylesheet);
  setext.irNode.type = new Expression("heading");
  setext.tailPattern = /((=+|-+)[ \t]*$)/ym;
  setext.maxLines = 3;
  setext.indent = "optional";
  setext.irNode.level = new Expression(["map", ["at", ["tail", 2], 0], { "=": 1, "-": 2 }]);
  setext.irNode.body = new Expression(["parseInlines", ["trim", ["body"]]]);
  const blockquote = new ContainerStyle("Block Quote", stylesheet);
  blockquote.irNode.type = new Expression("block_quote");
  blockquote.indent = "yes";
  stylesheet.blockStyles.push(
    // because this is an unmarked hanging indent, it must come before
    // any other block style so that said style can occur as the first
    // block within the hanging indent.
    markerWidthHanging,
    markedAutoWidthHanging,
    markedFixedHanging,
    unmarkedFixedIndentFixedHanging,
    unmarkedAutoHanging,
    setext,
    atx,
    blockquote
  );
  stylesheet.inlineStyles = [
    "autolink",
    "backticks",
    "emphasis",
    "entity",
    "escape",
    "html_inline",
    "image",
    "reference",
    "newline",
    "html"
  ];
  return stylesheet;
}

// ptss-parser/sheets/utilStyles.ts
function caseBlockStyle(stylesheet) {
  const style = new ContainerStyle("Case Block", stylesheet);
  style.irNode.type = new Expression("case_block");
  style.irNode.typeExtends = new Expression("code_block");
  style.topBorder = "`";
  style.topBorderMinLength = 25;
  style.righter = / (case|example)(.*)/ym;
  style.body = /^([\s\S]*\n)\.\n([\s\S]*)/ym;
  style.canInterruptParagraph = true;
  style.canInterruptLazy = true;
  style.irNode.class = new Expression(["righter", 1]);
  style.irNode.parameters = new Expression(["righter", 2]);
  style.irNode.input = new Expression(["first", ["body", 1], ""]);
  style.irNode.expected = new Expression(["first", ["body", 2], ""]);
  return style;
}
function catchAllAsLiteral(stylesheet) {
  const style = new ChunkStyle("Catch All As Literal", stylesheet);
  style.irNode.type = new Expression("block");
  style.irNode.class = new Expression(["pass-thru"]);
  style.irNode.body = new Expression(["body"]);
  return style;
}

// ptss-parser/sheets/case-file.ptss.ts
function newCaseFileStylesheet(options) {
  const stylesheet = newGracedownSheet(options);
  stylesheet.name = "Case File (Pandoc Markdown + case spec extension)";
  stylesheet.blockStyles.unshift(caseBlockStyle(stylesheet));
  return stylesheet;
}

// ptss-parser/sheets/case-file-manipulation.ptss.ts
function newCaseFileManipulationSheet(options) {
  const stylesheet = new Stylesheet("gen-case-expectations");
  stylesheet.sloppyMargin = 0;
  stylesheet.escapeSyntax.escapeChar = "\\";
  const caseBlocks = caseBlockStyle(stylesheet);
  stylesheet.blockStyles.push(caseBlocks);
  const indented = new ContainerStyle("Indented Text To Preserve", stylesheet);
  indented.irNode.type = new Expression("code_block");
  indented.indent = "markdown(1,4)";
  indented.body = "RAW_NL";
  indented.canInterruptParagraph = false;
  indented.canInterruptLazy = false;
  stylesheet.blockStyles.push(indented);
  const cm = newCommonMarkSheet(options);
  const backtick = cm.get("Backtick Fenced Code Block");
  backtick.styleSheet = stylesheet;
  stylesheet.blockStyles.push(backtick);
  const tilde = cm.get("Tilde Fenced Code Block");
  tilde.styleSheet = stylesheet;
  stylesheet.blockStyles.push(tilde);
  stylesheet.defaultBlockStyle = catchAllAsLiteral(stylesheet);
  return stylesheet;
}

// ptss-parser/sheets/rubyrhod.ptss.ts
function newRubyRhodStylesheet(options) {
  const stylesheet = newGracedownSheet(options);
  stylesheet.name = "Ruby Rhod evolving talking documentation style sheet";
  const atx = stylesheet.get("ATX Heading");
  atx.irNode.type = new Expression("section");
  atx.bodyPattern = /(?:[ \t]+(🟨|🟧|🟥|🏈|❌)?[ \t]*(.*?))??(?:[ \t]+#+)?[ \t]*$/ym;
  atx.irNode.title = new Expression(["parseInlines", ["first", ["body", 2], ""]]);
  delete atx.irNode.body;
  atx.irNode.class = new Expression(
    ["map", ["body", 1], {
      "\u{1F7E8}": "tentative",
      "\u{1F7E7}": "unsettled blocker",
      "\u{1F7E5}": "unsettled critical",
      "\u{1F3C8}": "unsettled punt",
      //todo[RubyDoc] "punt" is too American maybe? "non-blocker" instead?
      "\u274C": "rejected"
    }]
  );
  atx.ptNamedValue = {
    type: "element",
    name: new Expression(["replace", ["trim", ["first", ["body", 2], ""]], /[ \t\r\n]+/, " "]),
    value: "self"
  };
  const setext = stylesheet.get("Setext Heading");
  setext.irNode.type = new Expression("section");
  setext.bodyPattern = /[ \t]*(🟨|🟧|🟥|🏈|❌)?[ \t]*(.*?)[ \t]*$/ym;
  setext.irNode.title = new Expression(["parseInlines", ["trim", ["body", 2]]]);
  delete setext.irNode.body;
  setext.irNode.class = new Expression(
    ["map", ["body", 1], {
      "\u{1F7E8}": "tentative",
      "\u{1F7E7}": "unsettled blocker",
      "\u{1F7E5}": "unsettled critical",
      "\u{1F3C8}": "unsettled punt",
      //todo[RubyDoc] "punt" is to American maybe? "non-blocker" instead?
      "\u274C": "rejected"
    }]
  );
  setext.ptNamedValue = {
    type: "element",
    name: new Expression(["replace", ["trim", ["first", ["body", 2], ""]], /[ \t\r\n]+/, " "]),
    value: "self"
  };
  const devTodo = new ContainerStyle("Dev Todo", stylesheet);
  devTodo.canInterruptParagraph = true;
  devTodo.canInterruptLazy = true;
  devTodo.hangingIndent = "auto";
  devTodo.marker = /\[\/\/]:\s+#\s+["'(]todo!?\[([^"]+?)]/y;
  devTodo.indent = "no";
  devTodo.body = "BLOCKS";
  devTodo.irNode.type = new Expression("interjection");
  devTodo.irNode.subType = new Expression("todo");
  devTodo.irNode.icon = new Expression("\u{1FAA3}");
  devTodo.irNode.title = new Expression(["parseInlines", ["marker", 1]]);
  stylesheet.blockStyles.unshift(devTodo);
  stylesheet.blockStyles.unshift(caseBlockStyle(stylesheet));
  return stylesheet;
}

// ptss-parser/sheets/index.ts
function loadSheet(name, options) {
  let lower = name.toLowerCase();
  if (!lower.endsWith(".ptss")) {
    lower += ".ptss";
  }
  switch (lower) {
    case "commonmark.ptss":
      return newCommonMarkSheet(options);
    case "commonmark-fwd.ptss":
      return newCommonMarkFWDSheet(options);
    case "gfm.ptss":
      return newGFMStylesheet(options);
    case "pandoc-markdown.ptss":
      return newPandocMarkdownStylesheet(options);
    case "pandoc-markdown-strict.ptss":
      return newPandocMarkdownStrictStylesheet(options);
    case "markdown_hs.ptss":
      return newMarkdownHSStylesheet(options);
    case "plainjane.ptss":
      return newPlainJaneStylesheet(options);
    case "gracedown.ptss":
      return newGracedownSheet(options);
    case "restructuredtext.ptss":
      return newRSTSheet(options);
    case "kitchen-sink.ptss":
      return newKitchenSinkStylesheet(options);
    case "rubyrhod.ptss":
      return newRubyRhodStylesheet(options);
    case "test-composition.ptss":
      return newTestCompositionsSheet(options);
    case "test-ptss-one.ptss":
      return newTestPtssOneSheet(options);
    case "test-references.ptss":
      return newTestReferencesSheet(options);
    case "test-writers-prerogative.ptss":
      return newTestWritersPrerogativeSheet(options);
    case "case-file.ptss":
      return newCaseFileStylesheet(options);
    case "case-file-manipulation.ptss":
      return newCaseFileManipulationSheet(options);
  }
  throw new Error(`no style sheet named "${name}"`);
}

// textplain/render/stir/abstractWriter.ts
var AbstractWriter = class {
  bWriters = {};
  iWriters = {};
  useInheritance;
  constructor(useInheritance = true) {
    this.useInheritance = useInheritance;
  }
  initWriters(blockWriters, inlineWriters) {
    this.bWriters = blockWriters;
    this.iWriters = inlineWriters;
  }
  writeSequence(s, out) {
    if (s === void 0) {
    } else if (typeof s === "string") {
      this.writeText(s, out);
    } else {
      if (isBlockSequence(s)) {
        this.writeBlockSequence(s, out);
      } else {
        this.writeInlineSequence(s, out);
      }
    }
  }
  //! writeBlock must remain a shared implementation as it
  //  implements STIR rules for inheritance
  writeBlock(b, out) {
    const w = this.bWriters[b.type];
    if (w) {
      w(b, out);
    } else {
      this.perWriteBlockPerExtendedType(b, out);
    }
  }
  perWriteBlockPerExtendedType(b, out) {
    const extended = b.typeExtends;
    if (extended) {
      const input = new Block(`code_block`);
      input.body = b.input;
      const expected = new Block(`code_block`);
      expected.body = b.expected;
      const table = new Block("table");
      const col1 = new Block("cell");
      col1.colSpan = 1;
      col1.rowSpan = 1;
      col1.body = "input";
      const col2 = new Block("cell");
      col2.colSpan = 1;
      col2.rowSpan = 1;
      col2.body = "expected";
      const body1 = new Block("cell");
      body1.colSpan = 1;
      body1.rowSpan = 1;
      body1.body = [input];
      const body2 = new Block("cell");
      body2.colSpan = 1;
      body2.rowSpan = 1;
      body2.body = [expected];
      table.head = [[col1, col2]];
      table.body = [[body1, body2]];
      this.writeBlock(table, out);
    } else {
      throw new Error(`STIR block type ${b.type} is not recognized nor extends a known type.`);
    }
  }
  //! writeInline must remain a shared implementation as it
  //  implements STIR rules for inheritance
  writeInline(i, out) {
    const w = this.iWriters[i.type];
    if (w) {
      w(i, out);
    } else {
      if (this.useInheritance) {
        throw new Error("unrecognized STIR inline type: " + i.type);
      }
    }
  }
  writeBlockSequence(bSeq, out) {
    if (bSeq === void 0)
      return;
    for (const b of bSeq) {
      this.writeBlock(b, out);
    }
  }
  writeInlineSequence(iSeq, out) {
    if (iSeq === void 0) {
      this.writeText("\u274C ERROR: expected IR node InlineSequence property is undefined \u274C", out);
    } else if (typeof iSeq === "string") {
      this.writeText(iSeq, out);
    } else {
      for (const j of iSeq) {
        if (typeof j === "string") {
          this.writeText(j, out);
        } else {
          this.writeInline(j, out);
        }
      }
    }
  }
};

// vfs/memfs.ts
var import_path_browserify = __toESM(require_path_browserify(), 1);
function isDir(n) {
  return "entries" in n;
}
function pathFor(node) {
  if (node.parent === void 0) {
    return node.name;
  }
  return pathFor(node.parent) + node.name;
}
var MemFS = class {
  _root = {
    name: "/",
    parent: void 0,
    entries: {},
    modTime: /* @__PURE__ */ new Date()
  };
  _readOnly = false;
  constructor() {
  }
  makeReadOnly() {
    this._readOnly = true;
  }
  isReadOnly() {
    return this._readOnly;
  }
  _resolvePath(path, throwOnInvalidPath = true) {
    path = path.trim();
    if (!path.startsWith("/"))
      throw new Error(`path must be absolute: "${path}"`);
    if (path === "/")
      return { node: this._root, remainder: [] };
    let node = this._root;
    const isExplicitlyDirPath = path.endsWith("/");
    const segments = isExplicitlyDirPath ? path.slice(1, -1).split("/") : path.slice(1).split("/");
    let i = 0;
    for (i = 0; i < segments.length; i++) {
      const seg = segments[i];
      if (seg === "") {
        if (throwOnInvalidPath) {
          throw new Error(`invalid path: "${path}"`);
        }
      }
      if (seg === ".") {
        continue;
      }
      if (seg === "..") {
        if (node.parent !== void 0) {
          node = node.parent;
          continue;
        }
        if (throwOnInvalidPath) {
          throw new Error(`invalid path: "${path}", "${pathFor(node)}" has no parent directory`);
        }
      }
      if (!isDir(node)) {
        if (throwOnInvalidPath) {
          throw new Error(`invalid path: "${path}", "${pathFor(node)}" is not a directory`);
        }
        break;
      }
      const next = node.entries[seg];
      if (next === void 0)
        break;
      node = next;
    }
    if (isExplicitlyDirPath && i === segments.length && !isDir(node)) {
      if (throwOnInvalidPath) {
        throw new Error(`invalid path: "${path}", "${pathFor(node)}" is not a directory`);
      }
      return { node: node.parent, remainder: segments.slice(i - 1) };
    }
    return { node, remainder: segments.slice(i) };
  }
  readFileSync(path) {
    const { node, remainder } = this._resolvePath(path);
    if (node === void 0 || remainder.length > 0)
      throw new Error(`invalid path: "${path}"`);
    if (isDir(node))
      throw new Error(`${path} is not a file`);
    return node.content;
  }
  readInfoSync(path) {
    throw new Error(`not implemented`);
  }
  readDirSync(path, withInfo) {
    const { node, remainder } = this._resolvePath(path);
    if (node === void 0 || remainder.length > 0)
      throw new Error(`invalid path: "${path}"`);
    if (!isDir(node))
      throw new Error(`${path} is not a directory`);
    const entries = Object.entries(node.entries);
    return entries.map((e) => {
      const eNode = e[1];
      if (isDir(eNode)) {
        if (withInfo) {
          return {
            name: e[0],
            isFile: false,
            isDir: true,
            size: -1,
            modTime: eNode.modTime
          };
        } else {
          return { name: e[0], isFile: false, isDir: true };
        }
      } else {
        if (withInfo) {
          return {
            name: e[0],
            isFile: true,
            isDir: false,
            size: eNode.content.length,
            modTime: eNode.modTime
          };
        } else {
          return { name: e[0], isFile: true, isDir: false };
        }
      }
    });
  }
  //todo![renderAssembly]  add overwrite:boolean arg
  //  or do we want: mode: 'create'|'update'|'create or update' ?
  writeFileSync(path, data) {
    const overwrite = false;
    const { node, remainder } = this._resolvePath(path);
    if (node === void 0)
      throw new Error(`invalid path: "${path}"`);
    switch (remainder.length) {
      case 0:
        if (isDir(node))
          throw new Error(`"${path}" is a directory`);
        if (!overwrite)
          throw new Error(`"${path}" already exists`);
        node.content = data;
        break;
      case 1:
        if (!isDir(node))
          throw new Error(`Cannot create file in "${pathFor(node)}". It is not a directory.`);
        if (remainder[0] === "")
          throw new Error(`invalid filename: "${remainder[0]}"`);
        node.entries[remainder[0]] = { name: remainder[0], parent: node, content: data, modTime: /* @__PURE__ */ new Date() };
        break;
      default:
        throw new Error(`Cannot create file in "${import_path_browserify.default.join(pathFor(node), ...remainder.slice(0, -1))}". It does not exist.`);
    }
  }
  copySync(fromPath, toPath, overwrite) {
    throw new Error(`not implemented`);
  }
  mkdirSync(path, recursive = false) {
    const { node, remainder } = this._resolvePath(path);
    if (node === void 0)
      throw new Error(`invalid path: "${path}"`);
    switch (remainder.length) {
      case 0:
        throw new Error(`"${path}" already exists`);
      case 1:
        if (!isDir(node))
          throw new Error(`Cannot create subdirectory in "${pathFor(node)}". It is not a directory.`);
        if (remainder[0] === "")
          throw new Error(`invalid file name: "${remainder[0]}"`);
        node.entries[remainder[0]] = { name: remainder[0] + "/", parent: node, entries: {} };
        break;
      default:
        if (recursive) {
          if (!isDir(node))
            throw new Error(`Cannot create subdirectory in "${pathFor(node)}". It is not a directory.`);
          let dir = node;
          for (const name of remainder) {
            if (name === "")
              throw new Error(`invalid path: "${path}"`);
            const newDir = { name: name + "/", parent: dir, entries: {} };
            dir.entries[name] = newDir;
            dir = newDir;
          }
        } else {
          throw new Error(`Cannot create ${remainder.at(-1)} in "${import_path_browserify.default.join(pathFor(node), ...remainder.slice(0, -1))}". It does not exist.`);
        }
    }
  }
  existsSync(path) {
    const { node, remainder } = this._resolvePath(path, false);
    return node !== void 0 && remainder.length === 0;
  }
  toString() {
    return `MemFS[${Object.keys(this._root.entries).length} root entries]`;
  }
};

// vfs/sandboxfs.ts
var import_path_browserify2 = __toESM(require_path_browserify(), 1);
var SandboxFS = class _SandboxFS {
  _srcFs;
  _srcRoot;
  _readOnly;
  readonlyReason;
  /**
   * Initializes a SandboxFS
   *
   * @param {Vfs} srcFs
   * @param {string} srcRoot
   * @param {"empty" | "readonly" | "overwrite"} mode
   *
   * modes
   * -----
   *   - `empty` requires that the srcRoot is empty at init time. is writable
   *   - `readonly` is what it says
   *   - `overwrite` has no protection for the existing contents
   */
  constructor(src, mode = "readonly") {
    const srcFs = src.vfs;
    if (!src.path) {
      throw new Error("SandboxFS requires an explicit Vfs path");
    }
    const srcRoot = src.path.endsWith("/") ? import_path_browserify2.default.normalize(src.path) : import_path_browserify2.default.normalize(src.path + "/");
    this._srcFs = srcFs;
    this._srcRoot = srcRoot;
    switch (mode) {
      case "empty":
        if (!srcFs.existsSync(srcRoot)) {
          srcFs.mkdirSync(srcRoot, true);
          this._readOnly = false;
          this.readonlyReason = "";
        } else if (srcFs.readDirSync(srcRoot, false).length > 0) {
          this._readOnly = true;
          this.readonlyReason = `cannot write to ${this}: it is not empty`;
        } else {
          this._readOnly = false;
          this.readonlyReason = "";
        }
        break;
      case "overwrite":
        this._readOnly = false;
        this.readonlyReason = "";
        throw new Error(`mode not implemented`);
      case "readonly":
        if (!srcFs.existsSync(srcRoot)) {
          throw new Error(`cannot open readonly SandboxFS at ${srcFs} ${srcRoot}: it doesn't exist`);
        }
        this._readOnly = true;
        this.readonlyReason = `${this} is readonly`;
        break;
    }
  }
  /** throws Error if path is not absolute or violates sandbox boundary */
  _srcFsPathFor(path) {
    if (!path.startsWith("/")) {
      throw new Error(`[internal logic error] invalid path, must be absolute path starting with "/": ${path}`);
    }
    const srcPath = import_path_browserify2.default.join(this._srcRoot, path);
    if (!srcPath.startsWith(this._srcRoot)) {
      throw new Error(`[internal logic error] path violates sandbox boundary: ${path}`);
    }
    return srcPath;
  }
  isReadOnly() {
    return this._readOnly;
  }
  readFileSync(path) {
    return this._srcFs.readFileSync(this._srcFsPathFor(path));
  }
  readInfoSync(path) {
    return this._srcFs.readInfoSync(this._srcFsPathFor(path));
  }
  readDirSync(path, withInfo) {
    if (withInfo === true) {
      return this._srcFs.readDirSync(this._srcFsPathFor(path), true);
    } else {
      return this._srcFs.readDirSync(this._srcFsPathFor(path), false);
    }
  }
  writeFileSync(path, data) {
    if (this._readOnly)
      throw new Error(this.readonlyReason);
    this._srcFs.writeFileSync(this._srcFsPathFor(path), data);
  }
  copySync(fromPath, toPath, overwrite) {
    if (this._readOnly)
      throw new Error(this.readonlyReason);
    toPath = this._srcFsPathFor(toPath);
    if (typeof fromPath === "string") {
      fromPath = this._srcFsPathFor(fromPath);
      this._srcFs.copySync(fromPath, toPath);
      return;
    }
    const fromFS = fromPath.vfs;
    if (fromFS instanceof _SandboxFS && fromFS._srcFs === this._srcFs) {
      this._srcFs.copySync(fromFS._srcFsPathFor(fromPath.path), toPath, overwrite);
      return;
    }
    throw Error(`copy across different underlying file systems not yet implemented for SandboxFS.copySync`);
  }
  mkdirSync(path, recursive = false) {
    if (this._readOnly)
      throw new Error(this.readonlyReason);
    this._srcFs.mkdirSync(this._srcFsPathFor(path), recursive);
  }
  existsSync(path) {
    return this._srcFs.existsSync(this._srcFsPathFor(path));
  }
  toString() {
    return `SandboxFS[${this._srcFs}:${this._srcRoot}]`;
  }
};

// vfs/vpath.ts
var import_path_browserify3 = __toESM(require_path_browserify(), 1);
var Vpath = {
  parse(path) {
    return import_path_browserify3.default.parse(path);
  },
  parseDir(path) {
    return import_path_browserify3.default.dirname(path);
  },
  parseBase(path) {
    return import_path_browserify3.default.basename(path);
  },
  parseName(path) {
    return import_path_browserify3.default.parse(path).name;
  },
  parseExt(path) {
    return import_path_browserify3.default.extname(path);
  },
  normalize(path) {
    return import_path_browserify3.default.normalize(path);
  },
  join(...paths) {
    return import_path_browserify3.default.join(...paths);
  },
  // todo[api] not sure we need these two. If we do, they DO NOT need to have
  // same signature as Nodejs.fs API. For example i think the Node resolve
  // method is odd, in that it doesn't necessarily use all the args,
  // and relative I believe only works if the two paths given are absolute
  // (need to confirm this); if so can/should it work for non absolute paths?
  // if one or two relative paths are passed, what are the results?
  resolve(...pathSegments) {
    throw new Error(`path.resolve not implemented -- see note in vfs.ts`);
  },
  relative(fromPath, toPath) {
    throw new Error(`path.relative not implemented -- see note in vfs.ts`);
  }
};

// textplain/config.ts
var import_json52 = __toESM(require_dist(), 1);
var Config = class _Config {
  _name;
  _resolvePath;
  _isSubconfig;
  _data = {};
  _assembly;
  /**
   *
   * @param name         the name of this config. Will be the filename
   *                     when it represents the whole config file,
   *                     appended with the subsection path if it represents
   *                     and extracted subsection.
   * @param data         the config data
   * @param resolvePath  used to resolve path
   *                     values held by this Config per rules specified
   *                     {@link Config above}.
   * @param isSubconfig  whether the config values in this instance
   *                     are a branch extracted from the full Config.
   * @param textAssembly reference to the owning TextAssembly if
   *                     this Config represents one.
   */
  constructor(name, data, resolvePath2, isSubconfig = false, textAssembly) {
    this._name = name;
    Object.assign(this._data, data);
    this._resolvePath = resolvePath2;
    this._isSubconfig = isSubconfig;
    this._assembly = textAssembly;
  }
  name() {
    return this._name;
  }
  data() {
    return this._data;
  }
  //! this is not identical to `value(key) !== undefined` because
  //  undefined is a possible value for key.
  hasValue(key) {
    const keys = key.split(".");
    let d = this._data;
    for (const k of keys) {
      if (!(k in d)) {
        return false;
      }
      d = d[k];
    }
    return true;
  }
  value(key) {
    const keys = key.split(".");
    let d = this._data;
    for (const k of keys) {
      if (!(k in d)) {
        return void 0;
      }
      d = d[k];
    }
    return d;
  }
  requiredValue(key) {
    const keys = key.split(".");
    let d = this._data;
    for (const k of keys) {
      if (k.length === 0) {
        throw new Error(`invalid key: "${key}"`);
      }
      if (!(k in d)) {
        throw new Error(`expected value for ${key} in ${this._name}`);
      }
      d = d[k];
    }
    return d;
  }
  subConfig(key) {
    const d = this.value(key);
    if (d === void 0)
      return void 0;
    const name = this._isSubconfig ? `${this._name}.${key}` : `${this._name}#${key}`;
    return new _Config(name, d, this._resolvePath, true, this._assembly);
  }
  requiredSubConfig(key) {
    const d = this.requiredValue(key);
    const name = this._isSubconfig ? `${this._name}.${key}` : `${this._name}#${key}`;
    return new _Config(name, d, this._resolvePath, true, this._assembly);
  }
  subConfigs(key) {
    const d = this.value(key);
    if (d === void 0 || !Array.isArray(d))
      return void 0;
    return this._createSubConfigs(d, key);
  }
  requiredSubConfigs(key) {
    const d = this.requiredValue(key);
    if (!Array.isArray(d)) {
      throw new Error(`expected array of values for ${key} in ${this._name}`);
    }
    return this._createSubConfigs(d, key);
  }
  _createSubConfigs(d, key) {
    const configs = [];
    for (let i = 0; i < d.length; i++) {
      const name = this._isSubconfig ? `${this._name}.${key}[$i]` : `${this._name}#${key}[$i]`;
      configs.push(
        new _Config(name, d[i], this._resolvePath, true, this._assembly)
      );
    }
    return configs;
  }
  resolvedPathValue(key) {
    const value = this.value(key);
    if (value === void 0 || typeof value !== "string") {
      return void 0;
    }
    return this._resolvePath(value);
  }
  requiredResolvedPathValue(key) {
    const value = this.requiredValue(key);
    if (typeof value !== "string") {
      throw new Error(`invalid path value for ${key} in ${this._name}`);
    }
    return this._resolvePath(value);
  }
  readFileSyncAt(key) {
    const path = this.resolvedPathValue(key);
    if (path === void 0)
      return void 0;
    return path.vfs.readFileSync(path.path);
  }
  requiredReadFileSyncAt(key) {
    const path = this.requiredResolvedPathValue(key);
    return path.vfs.readFileSync(path.path);
  }
  textAssembly() {
    return this._assembly;
  }
};
function newConfigForVfsPath(configPath, assembly) {
  const vfs = configPath.vfs;
  const configPathParts = Vpath.parse(configPath.path);
  const data = import_json52.default.parse(vfs.readFileSync(configPath.path));
  const resolvePath2 = (path) => {
    if (path.startsWith("/")) {
      return { vfs, path };
    }
    path = Vpath.join(configPathParts.dir, path);
    return { vfs, path };
  };
  return new Config(configPathParts.base, data, resolvePath2, false, assembly);
}
function newConfigFromSimpleOptions(options, assembly) {
  const resolvePath2 = () => {
    throw new Error("internal application logic error: cannot resolve paths from simple config");
  };
  return new Config("options", options || {}, resolvePath2, false, assembly);
}

// textplain/registry.ts
var pipeRegistry = {};
var renderSTIRRegistry = {};
var assemblyRendererRegistry = {};
var pluginRegistry = {};
function registerPipe(name, provider12) {
  if (pipeRegistry[name]) {
    throw Error(`duplicate pipe registration for "${name}"`);
  }
  pipeRegistry[name] = provider12;
}
function lookupPipe(name) {
  return pipeRegistry[name];
}
function registerSTIRRenderer(name, provider12) {
  if (renderSTIRRegistry[name]) {
    throw Error(`duplicate STIR renderer registration for "${name}"`);
  }
  renderSTIRRegistry[name] = provider12;
}
function lookupSTIRRenderer(name) {
  return renderSTIRRegistry[name];
}
function registerAssemblyRenderer(name, provider12) {
  if (renderSTIRRegistry[name]) {
    throw Error(`duplicate STIR renderer registration for "${name}"`);
  }
  assemblyRendererRegistry[name] = provider12;
}
function lookupAssemblyRenderer(name) {
  return assemblyRendererRegistry[name];
}
function registerPlugin(name, plugin) {
  if (pluginRegistry[name]) {
    throw Error(`duplicate plugin registration for "${name}"`);
  }
  pluginRegistry[name] = plugin;
}
function lookupPlugin(name) {
  return pluginRegistry[name];
}

// textplain/render/stir/html/stir2html.ts
var import_encode = __toESM(require_encode(), 1);
var Stir2Html = class extends AbstractWriter {
  safe;
  createAttrList;
  elemID4Node;
  idStyle;
  // todo[html] CommonMark quirks, things we do just for CM test
  //  conformance, should also be made explicit and optional in the same way.
  //  If the quirks are extensive, see ALTERNATE RENDERINGS above.
  //  -
  //  That Pandoc doesn't output empty ALT attribs for images
  //  seems correct, not a quirk; thus the logic for rending image links
  //  looks backwards.
  quirks = "none";
  notEscaped;
  checkboxUnchecked = '<input type="checkbox" />';
  checkboxChecked = '<input type="checkbox" checked />';
  // todo[arch] We support generic Record for options for simple use cases
  //    such as Textplain Live. But should we? Does it make sense to always
  //    require the caller create a Config, which could take the caller's
  //    context for any necessary path resolution?
  constructor(config) {
    super();
    this.initWriters(this.initBlockWriters(), this.initInlineWriters());
    if (config === void 0 || !(config instanceof Config)) {
      config = newConfigFromSimpleOptions(config);
    }
    const options = config.data();
    const plugins = config?.subConfigs("plugins");
    if (plugins !== void 0) {
      for (const pluginConfig of plugins) {
        const providerName = pluginConfig.requiredValue("provider");
        const plugin = lookupPlugin(providerName);
        if (plugin === void 0 || plugin.install === void 0) {
          throw new Error(`invalid plugin: ${providerName}`);
        }
        plugin.install(this, pluginConfig.subConfig("config")?.data());
      }
    }
    this.safe = options.safe === true;
    this.createAttrList = options.sourcepos === true ? createAttrListWithSourceInfo : createEmptyAttrList;
    switch (options.idStyle || "default") {
      case "gfm":
        this.idStyle = "gfm";
        this.elemID4Node = elemID4Node_GFM;
        break;
      case "pandoc":
        this.idStyle = "pandoc";
        this.elemID4Node = elemID4Node_Pandoc;
        break;
      case "default":
        this.idStyle = "default";
        this.elemID4Node = elemID4Node_Default;
        break;
      default:
        throw new Error(`invalid idStyle: ${options.idStyle}}`);
    }
    switch (options.quirks) {
      case "gfm":
        this.quirks = "gfm";
        this.notEscaped = import_encode.default.defaultChars.replace("$", "") + "%";
        this.checkboxUnchecked = '<input type="checkbox" disabled />';
        this.checkboxChecked = '<input type="checkbox" checked disabled />';
        break;
      case "pandoc":
        this.quirks = "pandoc";
        this.notEscaped = import_encode.default.defaultChars + "%\\";
        this.checkboxUnchecked = '<input type="checkbox" />';
        this.checkboxChecked = '<input type="checkbox" checked="" />';
        break;
      case void 0:
      case null:
      case "":
        this.quirks = "none";
        this.notEscaped = import_encode.default.defaultChars;
        break;
      default:
        throw new Error("unrecognized quirks option");
    }
  }
  // todo[api] Overwrites the default writer; no possibility of `super.write()`
  //   - i might register a BlockWriter that only handles the case for
  //     a subset of blocks of a given type, e.g. those with a `caption` value.
  //   - i should be able to defer back to the original BlockWriter, either
  //     to say "this one isn't mine" or to prepend/append/wrap the default output
  //     with some custom stuff.
  // todo![api, stir customization, stir templates] given the complexity of some of the
  //   block writer implementations, i'm not sure this is the way to support
  //   adding custom rendering. See my notes *STIR Element-level Templates*.
  registerBlockWriter(type, bw) {
    this.bWriters[type] = bw.bind(this);
  }
  registerInlineWriter(type, iw) {
    this.iWriters[type] = iw.bind(this);
  }
  render(stir) {
    const out = {
      buf: "",
      renderPlainText: escapeText,
      phase: "main",
      takenHtmlIDs: {},
      stirID2htmlID: {},
      notesInReferencedOrder: [],
      noteBackRefs: {}
    };
    if (isBlock(stir)) {
      this.writeBlock(stir, out);
    } else {
      this.writeInlineSequence(stir, out);
    }
    if (out.notesInReferencedOrder.length > 0) {
      out.phase = "footnote";
      if (this.quirks === "gfm") {
        out.buf += '<section class="footnotes" data-footnotes="">\n<ol>';
      } else if (this.quirks === "pandoc") {
        out.buf += '<aside class="footnotes footnotes-end-of-document" id="footnotes" role="doc-endnotes">\n<hr>\n<ol>';
      } else {
        out.buf += '<aside class="footnotes" role="doc-endnotes" epub:type="endnotes"><ol>';
      }
      for (const note of out.notesInReferencedOrder) {
        this.writeBlock(note, out);
      }
      if (this.quirks === "gfm") {
        out.buf += "</ol></section>";
      } else {
        out.buf += "</ol></aside>";
      }
    }
    return out.buf;
  }
  writeText(t, out) {
    out.buf += out.renderPlainText(t);
  }
  // Helper function to produce an HTML tag.
  tag(name, attrs = [], selfClosing, out) {
    out.buf += "<";
    out.buf += name;
    if (attrs && attrs.length > 0) {
      let i = 0;
      let attrib;
      while ((attrib = attrs[i]) !== void 0) {
        out.buf += " ";
        out.buf += attrib[0];
        out.buf += '="';
        out.buf += escapeAttrib(attrib[1]);
        out.buf += '"';
        i++;
      }
    }
    if (selfClosing) {
      out.buf += " />";
    } else {
      out.buf += ">";
    }
  }
  encodeHrefAttributeValue(href) {
    try {
      return (0, import_encode.default)(href, this.notEscaped);
    } catch (err) {
      return href;
    }
  }
  /**
   * todo[api, perf, arch] I need to revisit how i'm attaching BlockWriters and
   * InlineWriters to instances of Stir2Html and other AbstractWriter classes.
   *
   * - the register methods use bind to bind `this` to *this* instance of
   *   Stir2Html. But bind doesn't work for arrow functions. It happens to
   *   work the few cases I've used register so far because:
   *   - the functions don't reference `this`
   *   - the arrow function binds to the Stir2Bootstrap instance, which is
   *     fine because it's `super` is *this* instance of Stir2Html.
   *   - in `genCaseExpectedVals.ts` I use a regular function, for which
   *     bind does work (but it didn't work until I added `bind` to the
   *     register method of Stir2Markdown)... a bug I had to figure out.
   *
   *   In other words, I don't like the fragility of it all.
   *
   * - Also, is there a performance or code complexity costs to how I define
   *   those writers (type of function, closure scope, etc, use of bind)?
   *
   *   What is the maximally lightweight way for the desired function code to
   *   be executed? Am I overthinking this? Though according to
   *   https://delicious-insights.com/en/posts/call-and-apply-in-javascript/:
   *
   *   > arrow functions at call time do not define extra entries in the Function
   *   > Environment Record mentioned earlier.
   *
   *   and later it says that the lexically bound references in arrow functions
   *   are fixed, so if it weren't for the need to bind `this`, would arrow
   *   functions be best? What about not using `this` at all and making
   *   the AbstractWriter an explicit parameter?
   *
   * - I THINK THE RIGHT THING TO DO IS USE THE SAME METHOD to setup the
   *   built-ins and the custom writers currently added via the register
   *   methods.
   *
   * - I'm currently using arrow functions for the built-ins (i.e. see below).
   *   This means distinct instances of the functions for each instantiation
   *   of Stir2Html, but (1) we don't make many instances and (2) i have a
   *   feeling the JS engine detects this and shares the Function object.
   *   There are getting lexically tied to the `this` of the init___ methods,
   *   which of course is *this* Stir2Html.
   *
   * @returns {{[p: string]: BlockWriter}}
   */
  initBlockWriters() {
    const writers = {};
    writers["structured_text_intermediate_representation"] = (b, out) => {
      this.writeSequence(b.body, out);
    };
    writers["paragraph"] = (b, out) => {
      const attrs = this.createAttrList(b);
      this.tag("p", attrs, false, out);
      this.writeInlineSequence(b.body, out);
      out.buf += "</p>\n";
    };
    writers["section"] = (b, out) => {
      const attrs = this.createAttrList(b);
      const elemID = this.elemID4Node(b, out);
      if (elemID) {
        attrs.push(["id", elemID]);
      }
      if (b.class) {
        attrs.push(["class", b.class]);
      }
      this.tag("section", attrs, false, out);
      out.buf += "\n<h";
      out.buf += b.level;
      out.buf += ">";
      this.writeInlineSequence(b.title, out);
      out.buf += "</h";
      out.buf += b.level;
      out.buf += ">\n";
      this.writeBlockSequence(b.body, out);
      out.buf += "</section>\n";
    };
    writers["heading"] = (b, out) => {
      const tag = "h" + b.level;
      const attrs = this.createAttrList(b);
      const elemID = this.elemID4Node(b, out);
      if (elemID) {
        attrs.push(["id", elemID]);
      }
      this.tag(tag, attrs, false, out);
      this.writeInlineSequence(b.body, out);
      this.tag("/" + tag, [], false, out);
      out.buf += "\n";
    };
    writers["block"] = (b, out) => {
      const attrs = this.createAttrList(b);
      if (b.class) {
        attrs.push(["class", b.class]);
      }
      this.tag("div", attrs, false, out);
      out.buf += "\n";
      this.writeSequence(b.body, out);
      out.buf += "\n</div>\n";
    };
    writers["pre"] = (b, out) => {
      if (this.quirks === "pandoc") {
        const attrs2 = this.createAttrList(b);
        attrs2.push(["class", "line-block"]);
        this.tag("div", attrs2, false, out);
        if (b.body) {
          const save = out.renderPlainText;
          out.renderPlainText = pandocRenderPlainText;
          this.writeInlineSequence(b.body, out);
          out.renderPlainText = save;
        }
        out.buf += "</div>\n";
        return;
      }
      const attrs = this.createAttrList(b);
      this.tag("pre", attrs, false, out);
      if (b.body) {
        this.writeInlineSequence(b.body, out);
      }
      out.buf += "</pre>\n";
    };
    writers["code_block"] = (b, out) => {
      const infoWords = b.info ? b.info.split(/\s+/) : [];
      const attrs = this.createAttrList(b);
      if (this.quirks === "pandoc") {
        if (infoWords.length > 0 && infoWords[0].length > 0) {
          attrs.push(["class", infoWords[0]]);
        }
        this.tag("pre", attrs, false, out);
        out.buf += "<code>";
      } else {
        if (infoWords.length > 0) {
          if (infoWords[0].length > 0) {
            attrs.push(["class", "language-" + infoWords[0]]);
          }
          if (infoWords.length > 1) {
          }
        }
        out.buf += "<pre>";
        this.tag("code", attrs, false, out);
      }
      if (b.body) {
        out.buf += escapeText(b.body);
      }
      out.buf += "</code></pre>\n";
    };
    writers["verse"] = (b, out) => {
      const attrs = this.createAttrList(b);
      this.tag("pre", attrs, false, out);
      if (b.body) {
        this.writeInlineSequence(b.body, out);
      }
      out.buf += "</pre>\n";
    };
    writers["thematic_break"] = (b, out) => {
      const attrs = this.createAttrList(b);
      this.tag("hr", attrs, true, out);
      out.buf += "\n";
    };
    writers["block_quote"] = (b, out) => {
      const attrs = this.createAttrList(b);
      this.tag("blockquote", attrs, false, out);
      out.buf += "\n";
      this.writeSequence(b.body, out);
      out.buf += "</blockquote>\n";
    };
    writers["interjection"] = (b, out) => {
      const attrs = this.createAttrList(b);
      attrs.push(["class", "interjection " + b.subType]);
      if (b.icon && typeof b.icon === "string") {
        attrs.push(["icon", b.icon]);
      }
      this.tag("div", attrs, false, out);
      out.buf += "\n";
      if (b.title) {
        const titleAttrs = createEmptyAttrList();
        this.tag("h3", titleAttrs, false, out);
        this.writeInlineSequence(b.title, out);
        this.tag("/h3", [], false, out);
      }
      if (b.body) {
        this.writeSequence(b.body, out);
      }
      out.buf += "\n</div>\n";
    };
    writers["list"] = (b, out) => {
      const tag = b.listOrdered ? "ol" : "ul";
      const attrs = this.createAttrList(b);
      const start = b.listStartNum;
      if (start != void 0 && start !== 1) {
        attrs.push(["start", start.toString()]);
      }
      if (this.quirks === "pandoc" && b.source?.style?.styleSheet?.name === "Pandoc Markdown") {
        if (b.listStyle === "decimal") {
          attrs.push(["type", "1"]);
        }
        let allAllCheckboxes = true;
        for (const listItem of b.body) {
          const liBody = listItem.body;
          if (liBody.length > 0) {
            const firstChild = liBody[0];
            if (firstChild.type === "paragraph") {
              if (firstChild.body[0].type === "checkbox") {
                if (typeof firstChild.body[1] === "string") {
                  firstChild.body[1] = firstChild.body[1].trimStart();
                }
              } else {
                allAllCheckboxes = false;
              }
            } else {
              allAllCheckboxes = false;
              break;
            }
          }
        }
        if (!b.listOrdered && allAllCheckboxes) {
          attrs.push(["class", "task-list"]);
        }
      }
      this.tag(tag, attrs, false, out);
      out.buf += "\n";
      const itemWriter = this.bWriters.list_item;
      const flags = { compact: b.hints["commonmark.list.tight"] === true };
      for (const item of b.body) {
        itemWriter(item, out, flags);
      }
      this.tag("/" + tag, [], false, out);
      out.buf += "\n";
    };
    writers["list_item"] = (b, out, flags) => {
      const attrs = this.createAttrList(b);
      this.tag("li", attrs, false, out);
      if (b.body === void 0) {
        out.buf += "</li>\n";
      } else if (isBlockSequence(b.body)) {
        const bodySequence = b.body;
        if (flags?.compact) {
          if (bodySequence[0].type !== "paragraph") {
            out.buf += "\n";
          }
          for (let i = 0; i < bodySequence.length; i++) {
            const bodyItem = bodySequence[i];
            if (bodyItem.type === "paragraph") {
              this.writeInlineSequence(bodyItem.body, out);
              if (i < bodySequence.length - 1) {
                out.buf += "\n";
              }
            } else {
              this.writeBlock(bodyItem, out);
            }
          }
          out.buf += "</li>\n";
        } else {
          out.buf += "\n";
          this.writeBlockSequence(bodySequence, out);
          out.buf += "</li>\n";
        }
      } else {
        throw new Error(`invalid list item body: ${b.body}`);
      }
    };
    writers["table"] = (b, out) => {
      const attrs = this.createAttrList(b);
      this.tag("table", attrs, false, out);
      out.buf += "\n";
      const headRows = b.head;
      const bodyRows = b.body;
      const headMeta = b.tableMeta?.head;
      const bodyMeta = b.tableMeta?.body;
      if (headRows) {
        const attrByCol = genPerColumnCellAttribs(headMeta, this.quirks === "gfm");
        out.buf += "<thead>\n";
        for (const headRow of headRows) {
          out.buf += "<tr>";
          for (let i = 0; i < headRow.length; i++) {
            const cell = headRow[i];
            if (attrByCol[i]) {
              this.tag("th", attrByCol[i], false, out);
            } else {
              out.buf += "<th>";
            }
            this.writeBlock(cell, out);
            out.buf += "</th>";
          }
          out.buf += "</tr>\n";
        }
        out.buf += "</thead>\n";
      }
      if (bodyRows !== void 0) {
        const attrByCol = genPerColumnCellAttribs(bodyMeta, this.quirks === "gfm");
        if (bodyRows.length > 0 || this.quirks === "pandoc") {
          out.buf += "<tbody>\n";
        }
        for (const headRow of bodyRows) {
          out.buf += "<tr>";
          for (let i = 0; i < headRow.length; i++) {
            const cell = headRow[i];
            if (attrByCol[i]) {
              this.tag("td", attrByCol[i], false, out);
            } else {
              out.buf += "<td>";
            }
            this.writeBlock(cell, out);
            out.buf += "</td>";
          }
          out.buf += "</tr>\n";
        }
        if (bodyRows.length > 0 || this.quirks === "pandoc") {
          out.buf += "</tbody>\n";
        }
      }
      out.buf += "</table>\n";
    };
    writers["cell"] = (b, out) => {
      this.writeSequence(b.body, out);
    };
    writers["note"] = (b, out) => {
      if (out.phase === "main") {
      } else {
        const noteNum = out.notesInReferencedOrder.indexOf(b) + 1;
        const attrs = this.createAttrList(b);
        attrs.push(["id", out.stirID2htmlID[b.id]]);
        this.tag("li", attrs, false, out);
        out.buf += "\n";
        this.writeSequence(b.body, out);
        const backrefs = out.noteBackRefs[b.id];
        if (backrefs?.length > 0) {
          const endsWithPara = out.buf.endsWith("</p>\n");
          if (endsWithPara) {
            out.buf = out.buf.slice(0, -5);
          }
          for (let i = 0; i < backrefs.length; i++) {
            const backref = backrefs[i];
            if (this.quirks === "pandoc") {
              out.buf += `<a href="#${backref}" class="footnote-back" role="doc-backlink">\u21A9\uFE0E</a>`;
            } else if (this.quirks === "gfm") {
              out.buf += ` <a href="#${backref}" class="footnote-backref" data-footnote-backref=""`;
              if (i === 0) {
                out.buf += ` aria-label="Back to reference ${noteNum}">\u21A9</a>`;
              } else {
                out.buf += ` aria-label="Back to reference ${noteNum}-${i + 1}">\u21A9<sup class="footnote-ref">${i + 1}</sup></a>`;
              }
            } else {
              out.buf += ` <a href="#${backref}" class="footnote-backref" role="doc-backlink">\u21A9\uFE0E</a>`;
            }
          }
          if (endsWithPara) {
            out.buf += "</p>\n";
          }
        }
        out.buf += "\n</li>\n";
      }
    };
    writers["html_block"] = (b, out) => {
      if (this.safe) {
        out.buf += "<!-- raw HTML omitted -->";
      } else {
        out.buf += b.body;
      }
      out.buf += "\n";
    };
    return writers;
  }
  initInlineWriters() {
    const writers = {};
    writers["linebreak"] = (i, out) => {
      out.buf += "<br>\n";
    };
    writers["xref"] = (i, out) => {
      const attrs = [];
      const href = typeof i.referent === "object" ? "#" + this.elemID4Node(i.referent, out) : i.referent;
      if (!(this.safe && potentiallyUnsafe(href))) {
        attrs.push(["href", this.encodeHrefAttributeValue(href)]);
      }
      if (i.desc) {
        attrs.push(["title", i.desc]);
      }
      this.tag("a", attrs, false, out);
      this.writeInlineSequence(i.body, out);
      out.buf += "</a>";
    };
    writers["note_ref"] = (i, out) => {
      if (this.quirks === "gfm") {
        out.buf += '<sup class="footnote-ref">';
      } else if (this.quirks === "none") {
        if (out.buf.endsWith("</sup>"))
          out.buf += " ";
        out.buf += '<sup class="footnote-ref">';
      }
      const attrs = [];
      const referent = i.referent;
      const noteID = this.elemID4Node(referent, out);
      const noteHREF = "#" + noteID;
      const noteNum = out.notesInReferencedOrder.indexOf(referent) + 1;
      let refID = noteID?.replace(/fn/, "fnref");
      if (refID in out.takenHtmlIDs) {
        let newID;
        for (let i2 = 2; i2 < Number.MAX_VALUE; i2++) {
          newID = `${refID}-${i2}`;
          if (!(newID in out.takenHtmlIDs)) {
            refID = newID;
            break;
          }
        }
      }
      out.takenHtmlIDs[refID] = true;
      if (out.noteBackRefs[referent.id] === void 0) {
        out.noteBackRefs[referent.id] = [refID];
      } else {
        out.noteBackRefs[referent.id].push(refID);
      }
      attrs.push(["id", refID]);
      if (!(this.safe && potentiallyUnsafe(noteHREF))) {
        attrs.push(["href", this.encodeHrefAttributeValue(noteHREF)]);
      }
      if (this.quirks === "pandoc") {
        attrs.push(["class", "footnote-ref"]);
        attrs.push(["role", "doc-noteref"]);
      } else if (this.quirks === "gfm") {
        attrs.push(["data-footnote-ref", ""]);
      } else {
        attrs.push(["epub:type", "noteref"]);
        attrs.push(["role", "doc-noteref"]);
      }
      this.tag("a", attrs, false, out);
      if (this.quirks === "pandoc") {
        out.buf += `<sup>${noteNum}</sup>`;
      } else {
        out.buf += noteNum;
      }
      out.buf += "</a>";
      if (this.quirks !== "pandoc") {
        out.buf += "</sup>";
      }
    };
    writers["image"] = (i, out) => {
      const href = typeof i.referent === "object" ? "#" + this.elemID4Node(i.referent, out) : i.referent;
      if (this.safe && potentiallyUnsafe(href)) {
        out.buf += '<img src="';
      } else {
        out.buf += '<img src="';
        out.buf += this.encodeHrefAttributeValue(href);
      }
      if (i.body || !(this.quirks === "pandoc")) {
        out.buf += '" alt="';
        this.writeInlineSequence(inlineBodyText(i.body), out);
      }
      if (i.desc) {
        out.buf += '" title="';
        out.buf += i.desc;
      }
      out.buf += '" />';
    };
    writers["emph"] = (i, out) => {
      out.buf += "<em>";
      this.writeInlineSequence(i.body, out);
      out.buf += "</em>";
    };
    writers["strong"] = (i, out) => {
      out.buf += "<strong>";
      this.writeInlineSequence(i.body, out);
      out.buf += "</strong>";
    };
    writers["strike"] = (i, out) => {
      out.buf += "<del>";
      this.writeInlineSequence(i.body, out);
      out.buf += "</del>";
    };
    writers["subscript"] = (i, out) => {
      out.buf += "<sub>";
      this.writeInlineSequence(i.body, out);
      out.buf += "</sub>";
    };
    writers["superscript"] = (i, out) => {
      out.buf += "<sup>";
      this.writeInlineSequence(i.body, out);
      out.buf += "</sup>";
    };
    writers["highlight"] = (i, out) => {
      out.buf += "<mark>";
      this.writeInlineSequence(i.body, out);
      out.buf += "</mark>";
    };
    writers["code"] = (i, out) => {
      out.buf += "<code>";
      out.buf += escapeText(i.body);
      out.buf += "</code>";
    };
    writers["checkbox"] = (i, out) => {
      if (i.checked === true) {
        out.buf += this.checkboxChecked;
      } else {
        out.buf += this.checkboxUnchecked;
      }
    };
    writers["html_inline"] = (i, out) => {
      if (this.safe) {
        out.buf += "<!-- raw HTML omitted -->";
      } else {
        out.buf += i.body;
      }
    };
    return writers;
  }
};
function createEmptyAttrList() {
  return [];
}
function createAttrListWithSourceInfo(ire) {
  if (!ire.source) {
    return [];
  }
  const att = [];
  const lineStart = ire.source.lineStart;
  const lineEnd = ire.source.lineEnd;
  if (lineStart != void 0) {
    att.push(["data-src-line", String(lineStart) + "-" + String(lineEnd)]);
  }
  return att;
}
function genPerColumnCellAttribs(columns, gfmQuirk) {
  const perColAttribs = [];
  if (columns) {
    if (gfmQuirk) {
      for (const c of columns) {
        switch (c.align) {
          case "L":
            perColAttribs.push([["align", "left"]]);
            break;
          case "R":
            perColAttribs.push([["align", "right"]]);
            break;
          case "C":
            perColAttribs.push([["align", "center"]]);
            break;
          default:
            perColAttribs.push(void 0);
        }
      }
    } else {
      for (const c of columns) {
        switch (c.align) {
          case "L":
            perColAttribs.push([["style", "text-align:left"]]);
            break;
          case "R":
            perColAttribs.push([["style", "text-align:right"]]);
            break;
          case "C":
            perColAttribs.push([["style", "text-align:center"]]);
            break;
          default:
            perColAttribs.push(void 0);
        }
      }
    }
  }
  return perColAttribs;
}
var reTextSpecial2 = /[\n&<>]/g;
var pandocRenderPlainText = function(s) {
  if (reTextSpecial2.test(s)) {
    return s.replace(reTextSpecial2, function(s2) {
      switch (s2) {
        case "\n":
          return "<br>";
        case "&":
          return "&amp;";
        case "<":
          return "&lt;";
        case ">":
          return "&gt;";
        default:
          return s2;
      }
    });
  } else {
    return s;
  }
};
var reUnsafeProtocol = /^javascript:|vbscript:|file:|data:/i;
var reSafeDataProtocol = /^data:image\/(?:png|gif|jpeg|webp)/i;
var potentiallyUnsafe = function(url) {
  return reUnsafeProtocol.test(url) && !reSafeDataProtocol.test(url);
};
function elemID4Node_Pandoc(node, out) {
  if (isInline(node)) {
    throw Error("not implemented");
  }
  const stirID = node.id;
  if (stirID === void 0) {
    return void 0;
  }
  if (out.stirID2htmlID[stirID]) {
    return out.stirID2htmlID[stirID];
  }
  let htmlID;
  if (node.type === "note") {
    if (node.subType !== "footnote") {
      throw Error("not implemented");
    }
    let n = out.notesInReferencedOrder.indexOf(node);
    if (n === -1) {
      out.notesInReferencedOrder.push(node);
      htmlID = "fn" + out.notesInReferencedOrder.length;
    } else {
      n++;
      htmlID = "fn" + n;
    }
  } else {
    htmlID = stirID.toLowerCase().replace(/[^\p{L}\p{N}\s_./-]+/gu, "").trim().replace(/\s+/g, "-").replace(/^[^\p{L}]+/gu, "").replace(/^$/, "section");
    if (htmlID in out.takenHtmlIDs) {
      let newID;
      for (let i = 1; i < Number.MAX_VALUE; i++) {
        newID = `${htmlID}-${i}`;
        if (!(newID in out.takenHtmlIDs)) {
          htmlID = newID;
          break;
        }
      }
    }
  }
  out.stirID2htmlID[stirID] = htmlID;
  out.takenHtmlIDs[htmlID] = true;
  return htmlID;
}
function elemID4Node_GFM(node, out) {
  if (isInline(node)) {
    throw Error("not implemented");
  }
  const stirID = node.id;
  if (stirID === void 0) {
    return void 0;
  }
  if (out.stirID2htmlID[stirID]) {
    return out.stirID2htmlID[stirID];
  }
  let htmlID;
  if (node.type === "note") {
    if (node.subType !== "footnote") {
      throw Error("not implemented");
    }
    htmlID = "fn-" + stirID.slice(1);
    if (out.notesInReferencedOrder.indexOf(node) === -1) {
      out.notesInReferencedOrder.push(node);
    }
  } else {
    htmlID = stirID.toLowerCase().replace(/[^\p{L}\p{N}\s_./-]+/gu, "").trim().replace(/\s+/g, "-").replace(/^$/, "section");
    if (htmlID in out.takenHtmlIDs) {
      let newID;
      for (let i = 2; i < Number.MAX_VALUE; i++) {
        newID = `${htmlID}-${i}`;
        if (!(newID in out.takenHtmlIDs)) {
          htmlID = newID;
          break;
        }
      }
    }
  }
  out.stirID2htmlID[stirID] = htmlID;
  out.takenHtmlIDs[htmlID] = true;
  return htmlID;
}
function elemID4Node_Default(node, out) {
  if (isInline(node)) {
    throw Error("not implemented");
  }
  const stirID = node.id;
  if (stirID === void 0) {
    return void 0;
  }
  if (out.stirID2htmlID[stirID]) {
    return out.stirID2htmlID[stirID];
  }
  let htmlID;
  if (node.type === "note") {
    if (node.subType !== "footnote") {
      throw Error("not implemented");
    }
    let n = out.notesInReferencedOrder.indexOf(node);
    if (n === -1) {
      out.notesInReferencedOrder.push(node);
      htmlID = "fn:" + out.notesInReferencedOrder.length;
    } else {
      n++;
      htmlID = "fn:" + n;
    }
  } else {
    htmlID = stirID.toLowerCase().replace(/[^\p{L}\p{N}\s_./-]+/gu, "").trim().replace(/\s+/g, "-").replace(/^$/, "section");
    if (htmlID in out.takenHtmlIDs) {
      let newID;
      for (let i = 2; i < Number.MAX_VALUE; i++) {
        newID = `${htmlID}-${i}`;
        if (!(newID in out.takenHtmlIDs)) {
          htmlID = newID;
          break;
        }
      }
    }
  }
  out.stirID2htmlID[stirID] = htmlID;
  out.takenHtmlIDs[htmlID] = true;
  return htmlID;
}
var provider = {
  async configure(config) {
    const stir2Html = new Stir2Html(config);
    return function(stir) {
      return stir2Html.render(stir);
    };
  }
};
registerSTIRRenderer("Stir2Html", provider);

// textplain/render/stir/html/stir2bootstrap-html.ts
var import_handlebars2 = __toESM(require_handlebars(), 1);

// textplain/render/stir/html/handlebars.ts
var import_handlebars = __toESM(require_handlebars(), 1);
import_handlebars.default.registerHelper("concat", function(a, b) {
  return a + b;
});
import_handlebars.default.registerHelper("json", function(context, indent) {
  const st = stirType(context);
  if (st === "unknown" || st === void 0) {
    return JSON.stringify(context, void 0, indent);
  }
  return toJSON(context, indent, true);
});
import_handlebars.default.registerHelper({
  eq: (a, b) => a === b,
  ne: (a, b) => a !== b,
  lt: (a, b) => a < b,
  gt: (a, b) => a > b,
  lte: (a, b) => a <= b,
  gte: (a, b) => a >= b,
  and: (a, b) => a && b,
  or: (a, b) => a || b
});
import_handlebars.default.registerHelper("match", function(text, pattern) {
  return new RegExp(pattern).test(text);
});
import_handlebars.default.registerHelper("match_i", function(text, pattern) {
  return new RegExp(pattern, "i").test(text);
});

// textplain/render/stir/html/stir2bootstrap-html.ts
var intOpenTmpl = import_handlebars2.default.compile('<div class="alert alert-{{subType}}" role="alert">');
var intCloseTmpl = import_handlebars2.default.compile("</div>");
var Stir2BootstrapHtml = class extends Stir2Html {
  constructor(options) {
    super(options);
    this.registerBlockWriter("interjection", (b, out) => {
      out.buf += intOpenTmpl(b);
      if (b.title) {
        this.tag("h3", [], false, out);
        this.writeInlineSequence(b.title, out);
        this.tag("/h3", [], false, out);
        this.tag("hr/", [], false, out);
        out.buf += "\n";
      }
      this.writeSequence(b.body, out);
      out.buf += intCloseTmpl(b);
      out.buf += "\n";
    });
  }
};
var provider2 = {
  async configure(config) {
    const stir2bootstrapHtml = new Stir2BootstrapHtml(config);
    return function(stir) {
      return stir2bootstrapHtml.render(stir);
    };
  }
};
registerSTIRRenderer("Stir2BootstrapHtml", provider2);

// textplain/render/stir/stir2markdown.ts
var Stir2Markdown = class extends AbstractWriter {
  useATX = false;
  constructor(options = {}) {
    super();
    this.useATX = options.useATX === true;
    this.initWriters(this.initBlockWriters(), this.initInlineWriters());
  }
  registerBlockWriter(type, bw) {
    this.bWriters[type] = bw.bind(this);
  }
  registerInlineWriter(type, iw) {
    this.iWriters[type] = iw.bind(this);
  }
  render(stir) {
    const out = {
      buf: "",
      prefix: "",
      isFirstInContainer: false,
      blockFirstLinePrefix: void 0
    };
    if (isBlock(stir)) {
      this.writeBlock(stir, out);
    } else {
      this.writeInlineSequence(stir, out);
    }
    return out.buf;
  }
  writeText(t, out) {
    out.buf += t;
  }
  writeBlankLine(out) {
    out.buf += out.prefix.trimEnd();
    out.buf += "\n";
  }
  writeLeadingBlankIfNecessary(out) {
    if (out.isFirstInContainer) {
      out.isFirstInContainer = false;
    } else {
      this.writeBlankLine(out);
    }
  }
  writeBlockFirstLinePrefix(out) {
    this.writeLeadingBlankIfNecessary(out);
    if (out.blockFirstLinePrefix) {
      out.buf += out.blockFirstLinePrefix;
      out.blockFirstLinePrefix = void 0;
    } else {
      out.buf += out.prefix;
    }
  }
  writePrefixedTextBlock(textBlock, out) {
    if (!textBlock)
      return;
    for (const t of textBlock.split("\n")) {
      out.buf += out.prefix;
      out.buf += t;
      out.buf += "\n";
    }
  }
  // hack to remove blank line inside the end of a container
  //   that results from the current code's putting a blank
  //   line after every block in a block sequence. Obviously
  //   we can do better but I got higher priorities at the
  //   moment!
  hackRemoveTrailingPrefixedBlankLine(out) {
    const toRemove = out.prefix + "\n";
    if (out.buf.endsWith(toRemove)) {
      out.buf = out.buf.slice(0, -toRemove.length);
    }
  }
  initBlockWriters() {
    const writers = {};
    writers["structured_text_intermediate_representation"] = (b, out) => {
      out.isFirstInContainer = true;
      this.writeBlockSequence(b.body, out);
    };
    writers["paragraph"] = (b, out) => {
      this.writeBlockFirstLinePrefix(out);
      this.writeInlineSequence(b.body, out);
      out.buf += "\n";
    };
    writers["section"] = (b, out) => {
      out.buf += `\u274C\u274C\u274C\u274C NOT IMPLEMENTED: ${b.type} \u274C\u274C\u274C\u274C
`;
    };
    writers["heading"] = (b, out) => {
      this.writeBlockFirstLinePrefix(out);
      if (!this.useATX && b.level < 3) {
        const before = out.buf.length;
        this.writeInlineSequence(b.body, out);
        const len = out.buf.length - before;
        out.buf += "\n";
        out.buf += out.prefix;
        const ch = b.level === 1 ? "=" : "-";
        out.buf += ch.repeat(len);
        out.buf += "\n";
      } else {
        out.buf += "#".repeat(b.level);
        out.buf += " ";
        this.writeInlineSequence(b.body, out);
        out.buf += "\n";
      }
    };
    writers["block"] = (b, out) => {
      out.buf += `\u274C\u274C\u274C\u274C NOT IMPLEMENTED: ${b.type} \u274C\u274C\u274C\u274C
`;
    };
    writers["code_block"] = (b, out) => {
      this.writeBlockFirstLinePrefix(out);
      out.buf += "```";
      if (b.info) {
        out.buf += b.info;
      }
      out.buf += "\n";
      this.writePrefixedTextBlock(b.body, out);
      out.buf += out.prefix;
      out.buf += "```\n";
    };
    writers["verse"] = (b, out) => {
      out.buf += `\u274C\u274C\u274C\u274C NOT IMPLEMENTED: ${b.type} \u274C\u274C\u274C\u274C
`;
    };
    writers["thematic_break"] = (b, out) => {
      this.writeBlockFirstLinePrefix(out);
      out.buf += "---\n";
    };
    writers["block_quote"] = (b, out) => {
      this.writeLeadingBlankIfNecessary(out);
      const basePrefix = out.prefix;
      out.prefix += "> ";
      out.isFirstInContainer = true;
      this.writeBlockSequence(b.body, out);
      this.hackRemoveTrailingPrefixedBlankLine(out);
      out.prefix = basePrefix;
    };
    writers["interjection"] = (b, out) => {
      out.buf += `\u274C\u274C\u274C\u274C NOT IMPLEMENTED: ${b.type} \u274C\u274C\u274C\u274C
`;
    };
    writers["list"] = (b, out) => {
      this.writeLeadingBlankIfNecessary(out);
      const compact = b.hints["commonmark.list.tight"] === true;
      const flags = {
        ordered: b.listOrdered,
        num: b.listStartNum ? b.listStartNum : 1,
        compact
      };
      const itemWriter = this.bWriters.list_item;
      for (let i = 0; i < b.body.length; i++) {
        const item = b.body[i];
        if (i !== 0 && !compact) {
          this.writeBlankLine(out);
        }
        itemWriter(item, out, flags);
        flags.num++;
      }
    };
    writers["list_item"] = (b, out, flags) => {
      const marker = flags?.ordered ? flags.num + ". " : "- ";
      const basePrefix = out.prefix;
      out.blockFirstLinePrefix = basePrefix + marker;
      out.prefix = basePrefix + " ".repeat(marker.length);
      if (b.body === void 0) {
        out.buf += "\n";
      } else if (isBlockSequence(b.body)) {
        const bodySequence = b.body;
        if (flags?.compact) {
          for (let i = 0; i < bodySequence.length; i++) {
            out.isFirstInContainer = true;
            const bodyItem = bodySequence[i];
            if (bodyItem.type === "paragraph") {
              this.writeBlockFirstLinePrefix(out);
              this.writeInlineSequence(bodyItem.body, out);
              out.buf += "\n";
            } else {
              this.writeBlock(bodyItem, out);
            }
          }
        } else {
          out.isFirstInContainer = true;
          this.writeBlockSequence(bodySequence, out);
        }
      } else {
        throw new Error(`invalid list item body: ${b.body}`);
      }
      out.prefix = basePrefix;
    };
    writers["table"] = (b, out) => {
      out.buf += `\u274C\u274C\u274C\u274C NOT IMPLEMENTED: ${b.type} \u274C\u274C\u274C\u274C
`;
    };
    writers["cell"] = (b, out) => {
      out.buf += `\u274C\u274C\u274C\u274C NOT IMPLEMENTED: ${b.type} \u274C\u274C\u274C\u274C
`;
    };
    writers["html_block"] = (b, out) => {
      out.buf += `\u274C\u274C\u274C\u274C NOT IMPLEMENTED: ${b.type} \u274C\u274C\u274C\u274C
`;
    };
    return writers;
  }
  initInlineWriters() {
    const writers = {};
    writers["linebreak"] = (i, out) => {
      out.buf += " \\\n";
      out.buf += out.prefix;
    };
    writers["xref"] = (i, out) => {
      out.buf += "[";
      this.writeInlineSequence(i.body, out);
      out.buf += `](${i.referent})`;
    };
    writers["image"] = (i, out) => {
      out.buf += "![";
      this.writeInlineSequence(i.body, out);
      out.buf += `](${i.referent})`;
    };
    writers["emph"] = (i, out) => {
      out.buf += "*";
      this.writeInlineSequence(i.body, out);
      out.buf += "*";
    };
    writers["strong"] = (i, out) => {
      out.buf += "**";
      this.writeInlineSequence(i.body, out);
      out.buf += "**";
    };
    writers["code"] = (i, out) => {
      out.buf += "`";
      this.writeInlineSequence(i.body, out);
      out.buf += "`";
    };
    writers["html_inline"] = (i, out) => {
      this.writeInlineSequence(i.body, out);
    };
    return writers;
  }
};

// textplain/render/stir/stir2string.ts
var Stir2String = class extends AbstractWriter {
  constructor() {
    super();
    this.initWriters(this.initBlockWriters(), this.initInlineWriters());
  }
  render(stir) {
    const out = { buf: "", depth: 0 };
    if (isBlock(stir)) {
      this.writeBlock(stir, out);
    } else {
      this.writeInlineSequence(stir, out);
    }
    return out.buf;
  }
  writeIndent(out) {
    out.buf += "    ".repeat(out.depth);
  }
  writeText(t, out) {
    this.writeIndent(out);
    out.buf += '"';
    out.buf += t;
    out.buf += '"\n';
  }
  writeIndentedLine(line, out) {
    this.writeIndent(out);
    out.buf += line;
    out.buf += "\n";
  }
  writeIndentedTextBlock(textBlock, out) {
    if (!textBlock)
      return;
    for (const t of textBlock.split("\n")) {
      this.writeIndentedLine("|" + t, out);
    }
  }
  initBlockWriters() {
    const writers = {};
    writers["structured_text_intermediate_representation"] = (b, out) => {
      this.writeIndentedLine("STIR:", out);
      out.depth++;
      this.writeSequence(b.body, out);
      out.depth--;
    };
    writers["paragraph"] = (b, out) => {
      this.writeIndentedLine("PARA:", out);
      out.depth++;
      this.writeInlineSequence(b.body, out);
      out.depth--;
    };
    writers["section"] = (b, out) => {
      this.writeIndentedLine(`SECTION "${inlineBodyText(b.title)}" (level ${b.level})${b.class ? " (class=" + b.class + ")" : ""}:`, out);
      out.depth++;
      this.writeBlockSequence(b.body, out);
      out.depth--;
    };
    writers["heading"] = (b, out) => {
      this.writeIndentedLine(`HEADING ${b.level}:`, out);
      out.depth++;
      this.writeInlineSequence(b.body, out);
      out.depth--;
    };
    writers["block"] = (b, out) => {
      this.writeIndentedLine(`BLOCK (class=${b.class}):`, out);
      out.depth++;
      this.writeSequence(b.body, out);
      out.depth--;
    };
    writers["pre"] = (b, out) => {
      this.writeIndentedLine(`PRE:`, out);
      out.depth++;
      this.writeSequence(b.body, out);
      out.depth--;
    };
    writers["code_block"] = (b, out) => {
      this.writeIndentedLine(`CODE_BLOCK (info=${b.info}):`, out);
      out.depth++;
      this.writeIndentedTextBlock(b.body, out);
      out.depth--;
    };
    writers["verse"] = (b, out) => {
      this.writeIndentedLine(`VERSE:`, out);
      out.depth++;
      this.writeIndentedTextBlock(b.body, out);
      out.depth--;
    };
    writers["thematic_break"] = (b, out) => {
      this.writeIndentedLine("THEMATIC_BREAK", out);
    };
    writers["block_quote"] = (b, out) => {
      this.writeIndentedLine("BLOCK_QUOTE:", out);
      out.depth++;
      this.writeSequence(b.body, out);
      out.depth--;
    };
    writers["interjection"] = (b, out) => {
      this.writeIndentedLine(`INTERJECTION (subtype=${b.subType}):`, out);
      out.depth++;
      this.writeInlineSequence(b.title, out);
      this.writeSequence(b.body, out);
      out.depth--;
    };
    writers["list"] = (b, out) => {
      this.writeIndentedLine(`LIST (${b.listOrdered ? "ordered" : "unordered"}` + (b.listOrdered ? ` start=${b.listStartNum}, buf, indent):` : "):"), out);
      out.depth++;
      const itemWriter = this.bWriters.list_item;
      const flags = { compact: b.hints["commonmark.list.tight"] === true };
      for (const item of b.body) {
        itemWriter(item, out, flags);
      }
      out.depth--;
    };
    writers["list_item"] = (b, out, flags) => {
      this.writeIndentedLine("LIST_ITEM:", out);
      if (b.body === void 0) {
        return;
      } else if (isBlockSequence(b.body)) {
        out.depth++;
        const bodySequence = b.body;
        if (flags?.compact) {
          for (let i = 0; i < bodySequence.length; i++) {
            const bodyItem = bodySequence[i];
            if (bodyItem.type === "paragraph") {
              this.writeInlineSequence(bodyItem.body, out);
            } else {
              this.writeBlock(bodyItem, out);
            }
          }
        } else {
          this.writeBlockSequence(bodySequence, out);
        }
        out.depth--;
      } else {
        throw new Error(`invalid list item body: ${b.body}`);
      }
    };
    writers["table"] = (b, out) => {
      this.writeIndentedLine("TABLE:", out);
      out.depth++;
      const headRows = b.head;
      if (headRows) {
        for (const headRow of headRows) {
          this.writeIndentedLine("HEADER:", out);
          out.depth++;
          for (let i = 0; i < headRow.length; i++) {
            this.writeBlock(headRow[i], out);
          }
          out.depth--;
        }
      }
      const bodyRows = b.body;
      if (bodyRows !== void 0) {
        for (const headRow of bodyRows) {
          this.writeIndentedLine("ROW:", out);
          out.depth++;
          for (let i = 0; i < headRow.length; i++) {
            const cell = headRow[i];
            this.writeBlock(cell, out);
          }
          out.depth--;
        }
      }
      out.depth--;
    };
    writers["cell"] = (b, out) => {
      this.writeIndentedLine("CELL:", out);
      out.depth++;
      this.writeSequence(b.body, out);
      out.depth--;
    };
    writers["note"] = (b, out) => {
      this.writeIndentedLine(`NOTE (subtype=${b.subType}, orig ref name=${b.ptRefNameDELETE_ME}):`, out);
      out.depth++;
      this.writeSequence(b.body, out);
      out.depth--;
    };
    writers["html_block"] = (b, out) => {
      this.writeIndentedLine("HTML_BLOCK:", out);
      out.depth++;
      this.writeIndentedTextBlock(b.body, out);
      out.depth--;
    };
    return writers;
  }
  initInlineWriters() {
    const writers = {};
    writers["linebreak"] = (i, out) => {
      this.writeIndent(out);
      out.buf += "<LINEBREAK>";
      out.buf += "\n";
    };
    writers["xref"] = (i, out) => {
      this.writeIndent(out);
      out.buf += `XREF ${i.referent} "${i.desc}":`;
      out.buf += "\n";
      out.depth++;
      this.writeInlineSequence(i.body, out);
      out.depth--;
    };
    writers["note_ref"] = (i, out) => {
      this.writeIndent(out);
      out.buf += `NOTE_REF ${i.referent} "${i.desc}":`;
      out.buf += "\n";
      out.depth++;
      this.writeInlineSequence(i.body, out);
      out.depth--;
    };
    writers["image"] = (i, out) => {
      this.writeIndent(out);
      out.buf += `IMAGE ${i.referent} "${i.desc}":`;
      out.buf += "\n";
      out.depth++;
      this.writeInlineSequence(i.body, out);
      out.depth--;
    };
    writers["emph"] = (i, out) => {
      this.writeIndent(out);
      out.buf += "EM:";
      out.buf += "\n";
      out.depth++;
      this.writeInlineSequence(i.body, out);
      out.depth--;
    };
    writers["strong"] = (i, out) => {
      this.writeIndent(out);
      out.buf += "STRONG:";
      out.buf += "\n";
      out.depth++;
      this.writeInlineSequence(i.body, out);
      out.depth--;
    };
    writers["strike"] = (i, out) => {
      this.writeIndent(out);
      out.buf += "STRIKEOUT:";
      out.buf += "\n";
      out.depth++;
      this.writeInlineSequence(i.body, out);
      out.depth--;
    };
    writers["subscript"] = (i, out) => {
      this.writeIndent(out);
      out.buf += "SUBSCRIPT:";
      out.buf += "\n";
      out.depth++;
      this.writeInlineSequence(i.body, out);
      out.depth--;
    };
    writers["superscript"] = (i, out) => {
      this.writeIndent(out);
      out.buf += "SUPERSCRIPT:";
      out.buf += "\n";
      out.depth++;
      this.writeInlineSequence(i.body, out);
      out.depth--;
    };
    writers["highlight"] = (i, out) => {
      this.writeIndent(out);
      out.buf += "HIGHLIGHT:";
      out.buf += "\n";
      out.depth++;
      this.writeInlineSequence(i.body, out);
      out.depth--;
    };
    writers["code"] = (i, out) => {
      this.writeIndent(out);
      out.buf += "CODE:";
      out.buf += "\n";
      out.depth++;
      this.writeInlineSequence(i.body, out);
      out.depth--;
    };
    writers["checkbox"] = (i, out) => {
      this.writeIndent(out);
      if (i.checked === true) {
        out.buf += "<CHECKBOX (checked)>";
      } else {
        out.buf += "<CHECKBOX>";
      }
      out.buf += "\n";
    };
    writers["html_inline"] = (i, out) => {
      this.writeIndent(out);
      out.buf += "HTML_INLINE:";
      out.buf += "\n";
      out.depth++;
      this.writeInlineSequence(i.body, out);
      out.depth--;
    };
    return writers;
  }
};

// textplain/pipe.ts
async function configPipeProvider(config) {
  const providerName = config.requiredValue("provider");
  const onSwitch = config.value("onSwitch");
  if (onSwitch !== void 0) {
    if (process.argv.includes(onSwitch)) {
    } else {
      return void 0;
    }
  }
  const offSwitch = config.value("offSwitch");
  if (offSwitch !== void 0 && process.argv.includes(offSwitch)) {
    return void 0;
  }
  const provider12 = lookupPipe(providerName);
  if (provider12 === void 0 || provider12.configure === void 0) {
    throw new Error(`invalid pipe: ${providerName}`);
  }
  const providerConfig = config.subConfig("config");
  const pipe = await provider12.configure(providerConfig);
  return (stir) => {
    pipe(stir);
  };
}

// textplain/pipe/convertHeadingsToSections.ts
var transform = (root) => {
  if (!isBlock(root)) {
    return;
  }
  if (root.hasSections()) {
    return;
  }
  const exports = root.exports || {};
  const origBody = root.body;
  if (origBody === void 0 || !isBlockSequence(origBody)) {
    return;
  }
  root.body = void 0;
  let curSection = root;
  const sectionStack = [];
  for (const b of origBody) {
    if (b.type === "heading") {
      const newSection = new Block("section");
      for (const k in b) {
        if (k !== "type" && k !== "body") {
          newSection[k] = b[k];
        }
      }
      newSection.title = b.body;
      newSection.level = b.level;
      if (exports[b.id]) {
        exports[b.id] = { title: newSection.title };
      }
      if (curSection === root || curSection.level < newSection.level) {
        curSection.appendToBody(newSection);
        sectionStack.push(curSection);
        curSection = newSection;
      } else if (curSection.level === newSection.level) {
        curSection = sectionStack.pop();
        curSection.appendToBody(newSection);
        sectionStack.push(curSection);
        curSection = newSection;
      } else {
        do {
          curSection = sectionStack.pop();
        } while (curSection !== root && curSection.level >= newSection.level);
        curSection.appendToBody(newSection);
        sectionStack.push(curSection);
        curSection = newSection;
      }
    } else {
      curSection.appendToBody(b);
    }
  }
  return;
};
async function configure() {
  return transform;
}
var provider3 = {
  async configure() {
    return configure();
  }
};
registerPipe("ConvertHeadingsToSections", provider3);

// textplain/pipe/exportAllSectionsOrHeadings.ts
async function configure2(config) {
  const transform2 = (stir) => {
    if (!isBlock(stir)) {
      return;
    }
    const sections = stir.hasSections();
    const targetType = sections ? "section" : "heading";
    const field = sections ? "title" : "body";
    const exports = stir.exported || {};
    if (stir.exported === void 0) {
      stir.exports = exports;
    }
    stir.traverseBodyTree(function(node) {
      if (node.isSectioningRoot()) {
        return 1;
      }
      if (node.type === targetType) {
        const title = node[field];
        const name = normalizeName(inlineBodyText(title));
        const { path, sectioningRoot } = idPath(node.parent);
        if (sectioningRoot !== void 0) {
          return 1;
        }
        const id = path ? path + "/" + name : name;
        if (id in exports) {
          return 1;
        }
        node.id = id;
        exports[id] = { title };
      }
      return 0;
    });
  };
  return transform2;
}
var provider4 = {
  async configure(config) {
    return configure2(config);
  }
};
registerPipe("ExportAllSectionsOrHeadings", provider4);

// textplain/textAssembly/node.ts
function resolvePath(path, context) {
  path = path.trim();
  if (path === "")
    return void 0;
  let from;
  if (path.startsWith("/")) {
    if (path === "/")
      return context.assemblyRoot();
    from = context.assemblyRoot();
    path = path.slice(1);
  } else {
    const match = path.match(/^{(\w*)}\/(.*)/);
    if (match !== null) {
      from = context.assemblyRoot(true).assemblyForID(match[1]);
      if (from === void 0) {
        return void 0;
      }
      path = match[2];
      if (path === "")
        return from;
    } else {
      from = context;
    }
  }
  let node = from.isFolder() ? from : from.parent;
  const isExplicitlyFolderPath = path.endsWith("/");
  const segments = isExplicitlyFolderPath ? path.slice(0, -1).split("/") : path.slice(0).split("/");
  const last2 = segments.length - 1;
  nextSegment:
    for (let i = 0; i <= last2; i++) {
      const s = segments[i];
      if (s === "") {
        return void 0;
      }
      if (s === ".") {
        continue;
      }
      if (s === "..") {
        if (node.parent === void 0 || node.isAssemblyRoot()) {
          return void 0;
        }
        node = node.parent;
        continue;
      }
      if (s === node.openingContent?.name) {
        return !isExplicitlyFolderPath && i === last2 ? node.openingContent : void 0;
      }
      for (const child of node.content) {
        if (s === (child.name.endsWith("/") ? child.name.slice(0, -1) : child.name)) {
          if (child.isFile()) {
            return !isExplicitlyFolderPath && i === last2 ? child : void 0;
          }
          node = child;
          continue nextSegment;
        }
      }
      return void 0;
    }
  return node;
}

// textplain/textAssembly/file.ts
var File = class {
  name;
  parent;
  stir;
  title;
  isIndexable = false;
  // todo[arch] haven't decided if this is how we'll use an index like this.
  // exported deep link targets, resolved to #anchor string 
  deepLinkTargets = {};
  // the render status
  // values with the same prefix shown in order of valid state transition:
  status;
  outNode;
  constructor(name = "[[GENERATED]]", parent) {
    this.name = name;
    this.parent = parent;
  }
  nameSansExt() {
    return Vpath.parseName(this.name);
  }
  extension() {
    return Vpath.parseExt(this.name);
  }
  isFile() {
    return true;
  }
  isFolder() {
    return false;
  }
  isAssemblyRoot() {
    return false;
  }
  assemblyRoot(crossAssemblyBoundary) {
    return this.parent.assemblyRoot(crossAssemblyBoundary);
  }
  isOpeningContent() {
    return this === this.parent.openingContent;
  }
  // todo[arch] this avoids two things: 
  //  - a name that is 'undefined'
  //  - an additional boolean field
  isGenerated() {
    return this.name === "[[GENERATED]]";
  }
  innerAssemblyPath() {
    return this.parent.innerAssemblyPath() + this.name;
  }
  outerAssemblyPath() {
    return this.parent.outerAssemblyPath() + this.name;
  }
  crossAssemblyPath() {
    return this.parent.crossAssemblyPath() + this.name;
  }
  resolvePath(path) {
    return resolvePath(path, this);
  }
  searchUpForFile(name, crossAssemblyBoundary = false) {
    if (this.name === name) {
      return this;
    }
    if (this.parent === void 0) {
      return void 0;
    }
    return this.parent.searchUpForFile(name, crossAssemblyBoundary);
  }
  searchUpForProperty(property, crossAssemblyBoundary = false) {
    if (property in this) {
      const value = this[property];
      if (value !== void 0) {
        return { node: this, value };
      }
    }
    return this.parent.searchUpForProperty(property, crossAssemblyBoundary);
  }
  readFileSync() {
    return this.parent.assemblyRoot().srcFS().readFileSync(this.innerAssemblyPath());
  }
};

// textplain/textAssembly/subfolder.ts
var Subfolder = class {
  // Must have trailing slash. See https://www.w3.org/TR/ldp-bp/#include-a-trailing-slash-in-container-uris
  name;
  /**
   * subfolder *always* has parent.
   * Root folders are type {@link Assembly}
   */
  parent;
  get title() {
    return this.openingContent?.title;
  }
  get isIndexable() {
    return this.openingContent !== void 0;
  }
  openingContent;
  content = [];
  hasIncludedContent = false;
  sortSpec;
  textplainConfig;
  pipeline;
  outNode;
  constructor(name, parent) {
    this.name = name;
    this.parent = parent;
  }
  isFile() {
    return false;
  }
  isFolder() {
    return true;
  }
  isAssemblyRoot() {
    return false;
  }
  assemblyRoot(crossAssemblyBoundary = false) {
    return this.parent.assemblyRoot(crossAssemblyBoundary);
  }
  innerAssemblyPath() {
    return this.parent.innerAssemblyPath() + this.name;
  }
  outerAssemblyPath() {
    return this.parent.outerAssemblyPath() + this.name;
  }
  crossAssemblyPath() {
    return this.parent.crossAssemblyPath() + this.name;
  }
  resolvePath(path) {
    return resolvePath(path, this);
  }
  searchUpForFile(name, crossAssemblyBoundary = false) {
    for (const c of this.content) {
      if (c.isFile() && c.name === name) {
        return c;
      }
    }
    if (this.parent === void 0) {
      return void 0;
    }
    return this.parent.searchUpForFile(name, crossAssemblyBoundary);
  }
  searchUpForProperty(property, crossAssemblyBoundary = false) {
    if (property in this) {
      const value = this[property];
      if (value !== void 0) {
        return { node: this, value };
      }
    }
    return this.parent.searchUpForProperty(property, crossAssemblyBoundary);
  }
};

// textplain/textAssembly/traverse.ts
function traverse(fromNode, preorderVisit, postorderVisit) {
  const stack = [];
  if (preorderVisit) {
    stack.push([fromNode, false]);
  } else if (postorderVisit) {
    stack.push([fromNode, true]);
  } else {
    return;
  }
  let n;
  let isPost;
  while (stack.length > 0) {
    [n, isPost] = stack.pop();
    if (isPost) {
      if (postorderVisit?.(n) === "abort traversal") {
        return;
      }
    } else {
      if (n.isFile()) {
        switch (preorderVisit?.(n)) {
          case "continue":
            if (postorderVisit?.(n) === "abort traversal") {
              return;
            }
            break;
          case "abort branch":
            break;
          case "abort traversal":
            return;
        }
      } else {
        switch (preorderVisit?.(n)) {
          case "continue":
            if (postorderVisit) {
              stack.push([n, true]);
            }
            for (let i = n.content.length - 1; i >= 0; i--) {
              stack.push([n.content[i], false]);
            }
            if (n.openingContent) {
              stack.push([n.openingContent, false]);
            }
            break;
          case "abort branch":
            break;
          case "abort traversal":
            return;
        }
      }
    }
  }
}
async function traverseAsync(fromNode, preorderVisit, postorderVisit) {
  const stack = [];
  if (preorderVisit) {
    stack.push([fromNode, false]);
  } else if (postorderVisit) {
    stack.push([fromNode, true]);
  } else {
    return;
  }
  let n;
  let isPost;
  while (stack.length > 0) {
    [n, isPost] = stack.pop();
    if (isPost) {
      if (await postorderVisit?.(n) === "abort traversal") {
        return;
      }
    } else {
      if (n.isFile()) {
        switch (await preorderVisit?.(n)) {
          case "continue":
            if (await postorderVisit?.(n) === "abort traversal") {
              return;
            }
            break;
          case "abort branch":
            break;
          case "abort traversal":
            return;
        }
      } else {
        switch (await preorderVisit?.(n)) {
          case "continue":
            if (postorderVisit) {
              stack.push([n, true]);
            }
            for (let i = n.content.length - 1; i >= 0; i--) {
              stack.push([n.content[i], false]);
            }
            if (n.openingContent) {
              stack.push([n.openingContent, false]);
            }
            break;
          case "abort branch":
            break;
          case "abort traversal":
            return;
        }
      }
    }
  }
}

// textplain/textAssembly/assembly.ts
var Assembly = class {
  /** text assembly source folder via SandboxFS */
  _src;
  /**
   * will only have a value for subassemblies. must be unique across all
   * assemblies participating in the composite assembly.
   */
  assemblyID;
  // only defined on the root (outer) assembly
  assemblyIndex;
  // Must have trailing slash. See https://www.w3.org/TR/ldp-bp/#include-a-trailing-slash-in-container-uris
  name;
  /**
   * Undefined if standalone assembly,
   * {@link Folder} if subassembly
   */
  parent;
  get title() {
    return this.openingContent?.title;
  }
  get isIndexable() {
    return true;
  }
  openingContent;
  content = [];
  hasIncludedContent = false;
  sortSpec;
  textplainConfig;
  pipeline;
  outNode;
  /** @internal */
  constructor(src, parent, virtualFolderName = "/", assemblyID = "") {
    this.name = virtualFolderName;
    this.parent = parent;
    this._src = src;
    this.assemblyID = assemblyID;
    if (!src.isReadOnly()) {
      throw new Error(`assembly volume must be initialized as readonly`);
    }
    if (parent === void 0) {
      this.assemblyIndex = {
        [assemblyID]: this
      };
    } else {
      if (assemblyID.length < 1) {
        throw new Error("missing subassembly ID");
      }
      const idx = this.assemblyRoot(true).assemblyIndex;
      if (idx === void 0) {
        throw new Error("invalid assembly state: root assembly missing subassembly index");
      }
      if (idx[assemblyID] !== void 0) {
        throw new Error(`duplicate assembly ID: ${assemblyID}`);
      }
      idx[assemblyID] = this;
    }
  }
  isFile() {
    return false;
  }
  isFolder() {
    return true;
  }
  isAssemblyRoot() {
    return true;
  }
  assemblyRoot(crossAssemblyBoundary = false) {
    if (crossAssemblyBoundary && this.parent !== void 0) {
      return this.parent.assemblyRoot(true);
    }
    return this;
  }
  assemblyForID(id) {
    return this.assemblyIndex === void 0 ? this.assemblyRoot(true).assemblyForID(id) : this.assemblyIndex[id];
  }
  srcFS() {
    return this._src;
  }
  innerAssemblyPath() {
    return "/";
  }
  outerAssemblyPath() {
    return this.parent === void 0 ? "/" : this.parent.outerAssemblyPath() + this.name;
  }
  crossAssemblyPath() {
    return this.assemblyID === void 0 ? "{}/" : `{${this.assemblyID}}/`;
  }
  resolvePath(path) {
    return resolvePath(path, this);
  }
  searchUpForFile(name, crossAssemblyBoundary = false) {
    for (const c of this.content) {
      if (c.isFile() && c.name === name) {
        return c;
      }
    }
    if (this.parent === void 0 || !crossAssemblyBoundary) {
      return void 0;
    }
    return this.parent.searchUpForFile(name, crossAssemblyBoundary);
  }
  searchUpForProperty(property, crossAssemblyBoundary = false) {
    if (property in this) {
      const value = this[property];
      if (value !== void 0) {
        return { node: this, value };
      }
    }
    if (this.parent === void 0 || !crossAssemblyBoundary) {
      return void 0;
    }
    return this.parent.searchUpForProperty(property, crossAssemblyBoundary);
  }
  toString() {
    let s = "";
    let level = 0;
    traverse(
      this,
      (n) => {
        s += "    ".repeat(level);
        s += n.name;
        if (n.isFolder()) {
          if (n.openingContent)
            s += ` (${n.openingContent.name})`;
          if (n.isAssemblyRoot())
            s += ` \u{1F4E6}{${n.assemblyID}} ${n._src}`;
          if (n.textplainConfig)
            s += ` \u2699\uFE0F ${n.textplainConfig.name()}`;
          level++;
        }
        s += "\n";
        return "continue";
      },
      (n) => {
        if (n.isFolder()) {
          level--;
        }
        return "continue";
      }
    );
    return s;
  }
};

// textplain/textAssembly/read.ts
var import_json53 = __toESM(require_dist(), 1);
var TEXTASSEMBLY_SORT_SPEC_FILENAME = "sort";
var TEXTPLAIN_PIPELINE_CONFIG_FILENAME = "pipeline.json5";
function readAssembly(sourcePath) {
  if (!sourcePath.path.endsWith("/")) {
    sourcePath = { vfs: sourcePath.vfs, path: sourcePath.path + "/" };
  }
  const sandboxFs = new SandboxFS(sourcePath, "readonly");
  const assembly = new Assembly(sandboxFs);
  readFolderContent(assembly, sourcePath);
  determineOpeningContent(assembly);
  sortContent(assembly);
  return assembly;
}
function readSubAssembly(sourcePath, parent, virtualFolderName, assemblyID) {
  const volume = new SandboxFS(sourcePath, "readonly");
  const assembly = new Assembly(volume, parent, virtualFolderName, assemblyID);
  readFolderContent(assembly, sourcePath);
  return assembly;
}
function readFolderContent(f, folderSrc) {
  const sandboxFs = f.assemblyRoot().srcFS();
  const sandboxPath = f.innerAssemblyPath();
  const dirents = sandboxFs.readDirSync(sandboxPath, true).filter((n) => !n.name.startsWith("."));
  dirents.forEach((dirent) => {
    if (dirent.name === "node_modules") {
      return;
    }
    if (dirent.isDir) {
      const subdir = new Subfolder(dirent.name + "/", f);
      readFolderContent(subdir, { vfs: folderSrc.vfs, path: folderSrc.path + dirent.name + "/" });
      f.content.push(subdir);
    } else {
      const filePath = sandboxPath + dirent.name;
      if (dirent.name === TEXTPLAIN_PIPELINE_CONFIG_FILENAME) {
        const file = new File(dirent.name, f);
        const data = import_json53.default.parse(file.readFileSync());
        const configPathResolver = (path) => {
          const match = path.match(/^{(\w*)}\/(.*)/);
          if (match !== null) {
            const assembly = f.assemblyRoot(true).assemblyForID(match[1]);
            if (assembly === void 0) {
              throw new Error(`no such subassembly: {${match[1]}}`);
            } else {
              const node = resolvePath(match[2], assembly);
              if (node === void 0)
                throw new Error(`no file at path: ${path}`);
              return { vfs: node.assemblyRoot().srcFS(), path: node.innerAssemblyPath() };
            }
          }
          if (path.startsWith("/")) {
            return { vfs: sandboxFs, path };
          }
          path = Vpath.join(f.innerAssemblyPath(), path);
          return { vfs: sandboxFs, path };
        };
        f.textplainConfig = new Config(dirent.name, data, configPathResolver, false, f.assemblyRoot());
        return;
      }
      if (dirent.size < 256) {
        const content = sandboxFs.readFileSync(filePath);
        if (content.startsWith("graftpoint:")) {
          const lines = content.split("\n");
          if (lines.length > 1 && lines[1].startsWith("subassembly:")) {
            const id = lines[0].slice("graftpoint:".length).trim();
            const path = lines[1].slice("subassembly:".length).trim();
            let fullPath = path.startsWith("/") ? path : folderSrc.path + path;
            if (!fullPath.endsWith("/"))
              fullPath += "/";
            if (!folderSrc.vfs.existsSync(fullPath)) {
              throw new Error(`invalid subassembly path "${path}" specified in graftpoint ${folderSrc.path + dirent.name}`);
            }
            const vfsPath = { vfs: folderSrc.vfs, path: fullPath };
            if (id.length > 0 && path.length > 0) {
              const sass = readSubAssembly(vfsPath, f, `${dirent.name}/`, id);
              f.content.push(sass);
              return;
            }
          }
        }
      }
      if (dirent.name === TEXTASSEMBLY_SORT_SPEC_FILENAME) {
        f.sortSpec = sandboxFs.readFileSync(filePath).trim().split(/\s*\n\s*/);
        return;
      }
      f.content.push(new File(dirent.name, f));
    }
  });
}
function determineOpeningContent(assembly) {
  traverse(assembly, (n) => {
    if (n.isFolder()) {
      for (let i = 0; i < n.content.length; i++) {
        const c = n.content[i];
        if (c.name === "README.md" && c.isFile()) {
          n.openingContent = c;
          n.content.splice(i, 1);
          break;
        }
      }
    }
    return "continue";
  }, void 0);
}
function sortContent(assembly) {
  traverse(assembly, (n) => {
    if (n.isFolder()) {
      const sorter = getNodeSorter(n.searchUpForProperty("sortSpec", true)?.value);
      n.content.sort(sorter);
    }
    return "continue";
  }, void 0);
}
function relativeNodeSortOrder(sortSpec, n) {
  return sortSpec.findIndex(
    function(r) {
      const regExp = new RegExp("^" + r + "$", "i");
      if (n.isFolder()) {
        return regExp.test(n.name) || regExp.test(n.name.slice(0, -1));
      } else {
        return regExp.test(n.name);
      }
    }
  );
}
function getNodeSorter(sortSpec) {
  if (sortSpec === void 0) {
    return placeholderDefaultTextAssemblySort;
  }
  return (a, b) => {
    const len = sortSpec.length;
    const iDefault = (() => {
      const i = sortSpec.indexOf("...");
      return i === -1 ? len : i;
    })();
    const iFolderDefault = (() => {
      const i = sortSpec.indexOf(".../");
      return i === -1 ? iDefault : i;
    })();
    let iA = relativeNodeSortOrder(sortSpec, a);
    if (iA === -1)
      iA = a.isFolder() ? iFolderDefault : iDefault;
    let iB = relativeNodeSortOrder(sortSpec, b);
    if (iB === -1)
      iB = b.isFolder() ? iFolderDefault : iDefault;
    if (iA === iB) {
      return placeholderDefaultTextAssemblySort(a, b);
    }
    return -1 * len + iA - (-1 * len + iB);
  };
}
function placeholderDefaultTextAssemblySort(a, b) {
  const aName = a.name.toLocaleLowerCase();
  const bName = b.name.toLocaleLowerCase();
  const aSansExt = a.isFolder() ? aName : a.nameSansExt().toLocaleLowerCase();
  const bSansExt = b.isFolder() ? bName : b.nameSansExt().toLocaleLowerCase();
  return aSansExt === bSansExt ? aName < bName ? -1 : 1 : aSansExt < bSansExt ? -1 : 1;
}

// textplain/textAssembly/defaults.ts
var import_path_browserify4 = __toESM(require_path_browserify(), 1);
function defaultFileTitle(file) {
  if (file.isOpeningContent()) {
    if (file.parent.name === "/") {
      return "\u{1F3E0}";
    } else {
      return niceNameFromFilename(file.parent.name?.slice(0, -1));
    }
  }
  return niceNameFromFilename(import_path_browserify4.default.parse(file.name).name);
}
function niceNameFromFilename(n) {
  return n;
}

// node_modules/htmlnorm/lib/htmlnorm.js
var import_Parser = __toESM(require_Parser(), 1);

// node_modules/htmlnorm/lib/util.js
var import_style_to_object = __toESM(require_style_to_object(), 1);
var reTextSpecial3 = new RegExp("[&<>]", "g");
var escapeTextChar2 = function(s) {
  switch (s) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    default:
      return s;
  }
};
var escapeForHTML = function(s) {
  if (reTextSpecial3.test(s)) {
    return s.replace(reTextSpecial3, escapeTextChar2);
  } else {
    return s;
  }
};
var normalizeStyle = function(style) {
  const parsed = (0, import_style_to_object.default)(style);
  if (!parsed)
    return style;
  const props = [];
  Object.keys(parsed).forEach((prop) => props.push(prop + ": " + parsed[prop]));
  return props.sort().join("; ");
};

// node_modules/htmlnorm/lib/htmlnorm.js
var INDENT = "  ";
var DEFAULTS = {
  white_space: "standard",
  closing_tags: "as-is",
  attributeExcludes: {}
};
var eofWS = /[\t\n\f\r ]$/;
function htmlnorm(src, options) {
  const opts = { ...DEFAULTS, ...options };
  if (!src || typeof src !== "string") {
    return src;
  }
  const { handler, readResult } = initHandler(opts);
  const parser = new import_Parser.Parser(handler, { xmlMode: false, recognizeSelfClosing: false });
  try {
    parser.parseComplete(eofWS.test(src) ? src : src + "\n");
  } catch (e) {
    if (e instanceof Error && e.message.startsWith("[htmlnorm] malformed html:")) {
      return src;
    }
    throw e;
  }
  return readResult();
}
function initHandler(options) {
  const conservativeWS = options.white_space === "conservative";
  const explicitClose = options.closing_tags === "explicit";
  const attributeExcludes = Object.entries(options.attributeExcludes).reduce((m, e) => {
    m.set(e[0], new Set(e[1]));
    return m;
  }, /* @__PURE__ */ new Map());
  let out = "";
  const inlineBuf = [];
  const textBuf = [];
  let blockDepth = 0;
  let hardLineBreak = false;
  let inlineBufLeadingWS = false;
  let trailingWS = false;
  let trimLeadingWS = true;
  let inPre = 0;
  let nestingFormat = "container";
  function popPreText() {
    out += textBuf.join("");
    textBuf.length = 0;
    return;
  }
  function popText(trimTrailingWS, dontPopTrailingWS = false) {
    if (textBuf.length === 0) {
      trailingWS = false;
      return;
    }
    let s = textBuf.join("");
    textBuf.length = 0;
    if (s === "") {
      trailingWS = false;
      return;
    }
    s = s.replace(/[\t\n\f\r ]+/g, " ");
    if (dontPopTrailingWS && s.endsWith(" ")) {
      textBuf.push(" ");
      s = s.slice(0, -1);
      if (s === "") {
        trailingWS = false;
        return;
      }
    }
    if (s === " ") {
      if (inlineBuf.length === 0) {
        inlineBufLeadingWS = true;
      }
      trailingWS = true;
      if (trimLeadingWS || trimTrailingWS) {
        return;
      }
      pushInline(" ");
    } else {
      if (s.startsWith(" ")) {
        if (inlineBuf.length === 0) {
          inlineBufLeadingWS = true;
        }
        if (trimLeadingWS) {
          s = s.slice(1);
        }
      }
      trailingWS = s.endsWith(" ");
      if (trailingWS && trimTrailingWS) {
        s = s.slice(0, -1);
      }
      s = escapeForHTML(s);
      pushInline(s);
    }
  }
  function pushInline(s) {
    if (inlineBuf.length === 0) {
      inlineBuf.push(s);
    } else {
      inlineBuf[inlineBuf.length - 1] += s;
    }
  }
  function popInline(asAnonymousBlock, trimTrailingWS, dontPopTrailingWS = false) {
    popText(trimTrailingWS, dontPopTrailingWS);
    if (!inlineBuf[0]) {
      inlineBufLeadingWS = false;
      return;
    }
    const numLines = inlineBuf.length;
    if (asAnonymousBlock && (!conservativeWS || inlineBufLeadingWS)) {
      breakAndIndentLine();
    }
    out += inlineBuf[0];
    hardLineBreak = false;
    for (let i = 1; i < numLines; i++) {
      if (inlineBuf[i] === "") {
        hardLineBreak = true;
        break;
      }
      breakAndIndentLine();
      if (!asAnonymousBlock) {
        out += "    ";
      }
      out += inlineBuf[i];
    }
    inlineBuf.length = 0;
    inlineBufLeadingWS = false;
  }
  function breakAndIndentLine() {
    if (out.length === 0) {
      return;
    }
    out += "\n";
    if (blockDepth > 0) {
      out += INDENT.repeat(blockDepth);
    }
  }
  function breakAndIndentLineIfCan() {
    if (!conservativeWS || trailingWS || hardLineBreak) {
      breakAndIndentLine();
    }
  }
  const handler = {
    p: new import_Parser.Parser(),
    onparserinit(p) {
      this.p = p;
    },
    onopentag(name, attribs, isImplied) {
      if (isImplied) {
        throw new Error(`[htmlnorm] malformed html: closing ${name} tag did not have matching open tag`);
      }
      const a = Object.entries(attribs).filter((attr) => {
        var _a3;
        return !((_a3 = attributeExcludes.get(name)) === null || _a3 === void 0 ? void 0 : _a3.has(attr[0]));
      }).sort(([a2], [b]) => {
        if (a2 < b)
          return -1;
        if (a2 > b)
          return 1;
        return 0;
      }).map(([name2, value]) => {
        if (htmlSpecBoolAttribs.has(name2) && (value === "" || value === name2)) {
          return `${name2}`;
        }
        if (name2 === "class") {
          value = value.trim().split(/[\t\n\f\r ]+/g).sort().join(" ");
        } else if (name2 === "style") {
          value = normalizeStyle(value);
        }
        if (value.indexOf('"') >= 0) {
          if (value.indexOf("'") === -1) {
            return `${name2}='${value}'`;
          } else {
            return `${name2}="${value.replace(/"/g, "&quot;")}"`;
          }
        }
        return `${name2}="${value}"`;
      }).join(" ");
      const s = `<${name}${a ? " " : ""}${a}>`;
      if (inPre !== 0) {
        popPreText();
        out += s;
        if (name === "pre") {
          inPre++;
        }
      } else if (name === "pre") {
        popInline(true, true);
        if ((!conservativeWS || trailingWS || hardLineBreak) && out.length !== 0) {
          out += "\n";
        }
        out += s;
        inPre++;
      } else if (leafBlockTags.has(name)) {
        popInline(true, true);
        breakAndIndentLineIfCan();
        out += s;
        if (voidTags.has(name)) {
          trimLeadingWS = true;
        } else {
          trimLeadingWS = !conservativeWS;
          blockDepth++;
          nestingFormat = "leaf";
        }
      } else if (containerBlockTags.has(name)) {
        popInline(true, true);
        breakAndIndentLineIfCan();
        out += s;
        trimLeadingWS = true;
        blockDepth++;
        nestingFormat = formatAsLeafIfNoNestedBlocks.has(name) ? "container-as-leaf" : "container";
      } else {
        popText(name === "br");
        pushInline(s);
        if (name === "br") {
          inlineBuf.push("");
          if (nestingFormat === "container-as-leaf") {
            nestingFormat = "container";
          }
          trimLeadingWS = true;
        } else {
          trimLeadingWS = false;
        }
      }
    },
    // onopentagname (name: string): void {
    //     console.log(`${'    '.repeat(blockDepth)}OPEN TAG NAME:`, name)
    // },
    // onattribute (name: string, value: string, quote?: string | undefined | null): void {
    //     console.log(`${'    '.repeat(blockDepth)}ATTRIBUTE:`, name, value, quote)
    // },
    onclosetag(name, isImplied) {
      if (voidTags.has(name)) {
        return;
      }
      const s = `</${name}>`;
      if (inPre !== 0) {
        popPreText();
        if (explicitClose || !isImplied) {
          out += s;
        }
        if (name === "pre") {
          inPre--;
          if (inPre === 0) {
            trimLeadingWS = true;
          }
        }
      } else if (leafBlockTags.has(name)) {
        if (nestingFormat === "leaf") {
          blockDepth--;
          popInline(false, !conservativeWS, isImplied);
          if (hardLineBreak && (explicitClose || !isImplied)) {
            breakAndIndentLine();
            out += "    ";
          }
          nestingFormat = "container";
        } else {
          popInline(true, !conservativeWS, isImplied);
          blockDepth--;
          if (explicitClose || !isImplied) {
            breakAndIndentLineIfCan();
          }
        }
        if (explicitClose || !isImplied) {
          out += s;
        }
        trimLeadingWS = true;
      } else if (containerBlockTags.has(name)) {
        if (nestingFormat === "container-as-leaf") {
          blockDepth--;
          popInline(false, true, isImplied);
          nestingFormat = "container";
        } else {
          popInline(true, true, false);
          blockDepth--;
          if (explicitClose || !isImplied) {
            breakAndIndentLineIfCan();
          }
        }
        if (explicitClose || !isImplied) {
          out += s;
        }
        trimLeadingWS = true;
      } else {
        if (explicitClose || !isImplied) {
          popText(false, isImplied);
          pushInline(s);
          trimLeadingWS = false;
        }
      }
    },
    ontext(text) {
      textBuf.push(text);
    },
    // oncomment (data: string): void {
    //     console.log(`${'    '.repeat(blockDepth)}COMMENT:`, JSON.stringify(data))
    // },
    // oncommentend (): void {
    //     console.log(`${'    '.repeat(blockDepth)}COMMENT END`)
    // },
    // oncdatastart (): void {
    //     console.log(`${'    '.repeat(blockDepth)}DATA START`)
    // },
    // oncdataend (): void {
    //     console.log(`${'    '.repeat(blockDepth)}DATA END`)
    // },
    onprocessinginstruction(_name, data) {
      out += `<${data}>`;
      trimLeadingWS = true;
    },
    /**
     * Note: this is triggered by incorrect USAGE of htmlparser2, not
     * anything to do with the HTML being parsed. So irrelevant for
     * htmlnorm's needs. ignore and let htmlparser2 throw an Error.
     */
    // onerror (error: Error): void {
    //     console.log(`ERROR "${error}" ${this.p.startIndex}:${this.p.endIndex}`)
    // },
    onend() {
      popInline(true, true);
    }
    // onreset (): void {
    //     console.log(`RESET`)
    // }
  };
  function readResult() {
    return out;
  }
  return { handler, readResult };
}
var inlineTags = /* @__PURE__ */ new Set([
  "a",
  "abbr",
  "area",
  "audio",
  "b",
  "bdi",
  "bdo",
  "br",
  "button",
  "canvas",
  "cite",
  "code",
  "data",
  "datalist",
  "del",
  "dfn",
  "em",
  "embed",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "map",
  "mark",
  "math",
  "meter",
  "noscript",
  "object",
  "output",
  "progress",
  "q",
  "ruby",
  "s",
  "samp",
  "select",
  "small",
  "span",
  "strong",
  "sub",
  "sup",
  "svg",
  "template",
  "textarea",
  "time",
  "u",
  "var",
  "video",
  "wbr",
  "text",
  // obsolete inline tags
  "acronym",
  "big",
  "strike",
  "tt"
]);
var leafBlockTags = /* @__PURE__ */ new Set(["p", "h1", "h2", "h3", "h4", "h5", "h6", "hr", "title", "meta", "link"]);
var containerBlockTags = /* @__PURE__ */ new Set([
  "html",
  "head",
  "body",
  "article",
  "section",
  "nav",
  "aside",
  "main",
  "div",
  "header",
  "footer",
  "hgroup",
  "figure",
  "figcaption",
  "blockquote",
  "ul",
  "ol",
  "li",
  "table",
  "thead",
  "tbody",
  "tr",
  "th",
  "td",
  "caption",
  "pre",
  "address",
  "dl",
  "dt",
  "dd"
]);
var formatAsLeafIfNoNestedBlocks = /* @__PURE__ */ new Set(["li", "th", "td", "dt", "dd", "caption", "figcaption"]);
var voidTags = /* @__PURE__ */ new Set([
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
if ([...inlineTags, ...leafBlockTags, ...containerBlockTags].length !== inlineTags.size + leafBlockTags.size + containerBlockTags.size) {
  throw new Error("internal logic bug: HTML element categories overlap");
}
var htmlSpecBoolAttribs = /* @__PURE__ */ new Set([
  "allowfullscreen",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "ismap",
  "itemscope",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
]);

// textplain/pipe/renderCaseActuals.ts
var import_json54 = __toESM(require_dist(), 1);
var provider5 = {
  async configure(config) {
    if (config === void 0) {
      throw new Error("missing RenderCaseBlockTransform configuration");
    }
    const textAssembly = config.textAssembly();
    if (textAssembly === void 0) {
      throw new Error("This pipe only works in a TextAssembly context");
    }
    const normalize = config.value("normalize") === true;
    const htmlnormConfigForSpecFiles = (() => {
      if (normalize) {
        return import_json54.default.parse(config.requiredReadFileSyncAt("htmlnormConfigPath"));
      } else {
        return {};
      }
    })();
    const pipelineConfigName = config.requiredValue("pipelineConfigName");
    if (typeof pipelineConfigName !== "string") {
      throw `Invalid pipelineConfigName: ${pipelineConfigName}`;
    }
    async function configurationVisitor(n) {
      if (n.isFile()) {
        if (n.name === pipelineConfigName) {
          const pipeline = await simplePipelineFromConfigFile({ vfs: n.assemblyRoot().srcFS(), path: n.innerAssemblyPath() });
          const transformSection = (sectionRoot) => {
            let fails = 0;
            const body = sectionRoot.body;
            if (!isBlockSequence(body)) {
              return 0;
            }
            for (const b of body) {
              if (b.type === "section") {
                fails += transformSection(b);
              } else if (b.type === "case_block") {
                b.actual = pipeline.pump(b.input.replace(/^\uFEFF/, "").replace(/→/g, "	")).replace(/\t/g, "\u2192");
                if (normalize) {
                  b.actual = htmlnorm(b.actual);
                  b.expected = htmlnorm(b.expected, htmlnormConfigForSpecFiles);
                }
                if (b.actual !== b.expected) {
                  b.failed = true;
                  fails++;
                }
              }
            }
            sectionRoot.fails = fails;
            return fails;
          };
          n.parent.renderCaseBlocks = (caseFileRoot) => transformSection(caseFileRoot);
        }
      }
      return "continue";
    }
    await traverseAsync(textAssembly, configurationVisitor, void 0);
    function transform2(stir) {
      try {
        const tStir = stir;
        const r = tStir._tunnel.srcFile.searchUpForProperty("renderCaseBlocks", true);
        if (r !== void 0) {
          r.value(stir);
        }
      } catch (e) {
        process.exit(-1);
      }
    }
    return transform2;
  }
};
registerPipe("RenderCaseActuals", provider5);

// textplain/pipe/addTOC.ts
function extractTOC(root, fillLevelGapsWithEmptyTOCHeadings = false) {
  const sections = root.hasSections();
  const targetType = sections ? "section" : "heading";
  const field = sections ? "title" : "body";
  const tocRoot = { heading: void 0, subheadings: [] };
  let curTOCHeading = tocRoot;
  let curTOCHeadingLevel = 0;
  const stack = [];
  const seenIDs = {};
  root.traverseBodyTree(function(node) {
    if (node.id !== void 0) {
      seenIDs[node.id] = true;
    }
    if (node.isSectioningRoot()) {
      return 1;
    }
    if (node.type === targetType) {
      const nodeLevel = node.level;
      if (fillLevelGapsWithEmptyTOCHeadings) {
        while (nodeLevel > curTOCHeadingLevel + 1) {
          const newTOCHeading2 = {
            heading: void 0,
            subheadings: []
          };
          if (curTOCHeading.subheadings === void 0) {
            curTOCHeading.subheadings = [];
          }
          curTOCHeading.subheadings.push(newTOCHeading2);
          stack.push([curTOCHeading, curTOCHeadingLevel]);
          curTOCHeading = newTOCHeading2;
          curTOCHeadingLevel++;
        }
      }
      while (nodeLevel <= curTOCHeadingLevel) {
        [curTOCHeading, curTOCHeadingLevel] = stack.pop();
      }
      if (curTOCHeading.subheadings === void 0) {
        curTOCHeading.subheadings = [];
      }
      if (node.id === void 0) {
        assignUniqueID(node, seenIDs);
      }
      const newTOCHeading = {
        heading: node[field],
        referentID: node.id,
        referent: node
      };
      for (const k in node) {
        if (k === field || k === "level" || k === "type" || k === "id") {
          continue;
        }
        const v = node[k];
        if (typeof v === "string" || typeof v === "number" || typeof v === "boolean") {
          newTOCHeading[k] = v;
        }
      }
      curTOCHeading.subheadings.push(newTOCHeading);
      stack.push([curTOCHeading, curTOCHeadingLevel]);
      curTOCHeading = newTOCHeading;
      curTOCHeadingLevel = nodeLevel;
    }
    return 0;
  });
  return tocRoot.subheadings;
}
var provider6 = {
  async configure(config) {
    const fillLevelGapsWithEmptyTOCHeadings = config?.value("fillLevelGapsWithEmptyTOCHeadings");
    return (root) => {
      if (isBlock(root)) {
        if (root._tunnel === void 0) {
          root._tunnel = {};
        }
        root._tunnel.toc = extractTOC(root, fillLevelGapsWithEmptyTOCHeadings);
      }
    };
  }
};
registerPipe("AddTOC", provider6);

// textplain/pipe/validateSTIR.ts
var validate = (root) => {
  if (isBlock(root)) {
    const srcInfo = root._tunnel?.srcFile?.crossAssemblyPath() ? `
  src: ${root._tunnel.srcFile.crossAssemblyPath()}` : "";
    const seenIDs = {};
    root.traverseBodyTree(function(b) {
      if (b.id !== void 0) {
        if (b.id in seenIDs) {
          throw new TypeError(`stir node has duplicate id: ${b.toDebugString()}${srcInfo}`);
        }
        seenIDs[b.id] = true;
      }
      if (b !== root) {
        if (!isBlock(b.parent)) {
          throw new TypeError(`stir node missing parent: ${b.toDebugString()}${srcInfo}`);
        }
      }
      return 0;
    });
  }
  return;
};
async function configure3() {
  return validate;
}
var provider7 = {
  async configure() {
    return configure3();
  }
};
registerPipe("ValidateSTIR", provider7);

// textplain/render/stir/html/mermaid-plugin.ts
function install(stir2html, options) {
  const defaultBlockWriter = stir2html.bWriters["code_block"];
  stir2html.registerBlockWriter("code_block", (b, out) => {
    if (b.info?.startsWith("mermaid")) {
      out.buf += `<div class="mermaid">
${b.body}
</div>`;
    } else {
      defaultBlockWriter(b, out);
    }
  });
}
var provider8 = {
  install: (renderer, options = {}) => {
    install(renderer, options);
  }
};
registerPlugin("Mermaid2HtmlPlugin", provider8);

// textplain/render/stir/html/caseblock-plugin.ts
var import_handlebars4 = __toESM(require_handlebars(), 1);
var CASE_TEMPLATE = `<div class="case">
  <div class="input">
<pre><code class="language-markdown">{{input}}</code></pre>
  </div>
  <div class="output">
    <div class="expected rendered">
      <iframe height="100%" srcdoc="<head><link href='/_resources/body.css' rel='stylesheet' type='text/css'></head><body>{{realTabs expected}}</body>"></iframe>
    </div>
    <div class="expected html hidden">
<pre><code class="language-html">{{expected}}</code></pre>
    </div>
  </div>
</div>
`;
var ERROR_CASE_TEMPLATE = `<div class="case">
  <div class="input">
<pre><code class="language-markdown">{{input}}</code></pre>
  </div>
  <div class="output error">
    <div class="expected rendered">
      <iframe height="100%" srcdoc="<head><link href='/_resources/body.css' rel='stylesheet' type='text/css'></head><body>{{realTabs expected}}</body>"></iframe>
    </div>
    <div class="expected html hidden">
<pre><code class="language-html">{{expected}}</code></pre>
    </div>
    <div class="actual rendered hidden">
      <iframe height="100%" srcdoc="<head><link href='/_resources/body.css' rel='stylesheet' type='text/css'></head><body>{{realTabs actual}}</body>"></iframe>
    </div>
    <div class="actual html hidden">
<pre><code class="language-html">{{actual}}</code></pre>
    </div>
  </div>
</div>
`;
var caseTemplate = import_handlebars4.default.compile(CASE_TEMPLATE);
var caseErrorTemplate = import_handlebars4.default.compile(ERROR_CASE_TEMPLATE);
import_handlebars4.default.registerHelper("realTabs", function(text) {
  return text.replace(/→/g, "	");
});
function install2(renderer, options) {
  renderer.registerBlockWriter("case_block", function(b, out) {
    if (b.failed) {
      out.buf += caseErrorTemplate(b);
    } else {
      out.buf += caseTemplate(b);
    }
  });
}
var provider9 = {
  install: (renderer, options = {}) => {
    install2(renderer, options);
  }
};
registerPlugin("CaseBlock2HtmlPlugin", provider9);

// textplain/render/stir/html-template/templateAPI.ts
function toc(aTOC, render) {
  const hTOC = [];
  for (const aEntry of aTOC) {
    if (aEntry.heading === void 0) {
      hTOC.push({
        heading: void 0,
        subheadings: toc(aEntry.subheadings, render)
      });
    } else {
      const items = {
        heading: render(aEntry.heading),
        // todo![spec, html, rollout] figure out the right rules for this.
        //   I think the replacement below is too strict. From what I've
        //   read, IDs can have anything except whitespace, and the real
        //   reason you want to exclude certain chars has to do with not
        //   forcing the need for escaping when using the ID in a CSS
        //   selector. See https://www.w3.org/TR/CSS21/syndata.html#value-def-identifier.
        //   But since these IDs will also be used as fragment identifiers,
        //   we want to play nice with URL syntax and URL parsers as well.
        //   https://stackoverflow.com/questions/26088849/url-fragment-allowed-characters
        id: aEntry.referentID.toLowerCase().replace(/[^\p{L}\p{N}\s_./-]+/gu, "").trim().replace(/\s+/g, "-").replace(/^$/, "section")
      };
      for (const k in aEntry) {
        if (k !== "heading" && k !== "referentID" && k !== "referent") {
          items[k] = aEntry[k];
        }
      }
      if (aEntry.subheadings !== void 0) {
        items.subheadings = toc(aEntry.subheadings, render);
      }
      hTOC.push(items);
    }
  }
  return hTOC;
}

// textplain/render/stir/html-template/stir2template.ts
var import_handlebars5 = __toESM(require_handlebars(), 1);
var stirRenderer = function(config, renderStir) {
  const defaultHBS = config.requiredReadFileSyncAt("templates.default");
  const defaultTemplate = import_handlebars5.default.compile(defaultHBS);
  const render = (stir) => {
    const page = {};
    page.body = renderStir(stir);
    if (isBlock(stir)) {
      page.toc = () => {
        return toc(extractTOC(stir), renderStir);
      };
    }
    page.stir = stir;
    page.title = "not implemented";
    return defaultTemplate(page, {
      allowProtoMethodsByDefault: true,
      allowProtoPropertiesByDefault: true
    });
  };
  return render;
};
var assemblyRenderer = function(config, renderStir) {
  const indexHBS = config.requiredReadFileSyncAt("templates.section");
  const standardHBS = config.requiredReadFileSyncAt("templates.page");
  const indexTemplate = import_handlebars5.default.compile(indexHBS);
  const casePageTemplate = import_handlebars5.default.compile(standardHBS);
  const render = (stir) => {
    const tunnel = stir._tunnel;
    const file = tunnel.srcFile;
    const page = file;
    page.body = renderStir(stir);
    if (isBlock(stir) && tunnel.toc !== void 0) {
      page.toc = () => toc(tunnel.toc, renderStir);
    }
    page.site = tunnel.srcAssembly;
    page.stir = stir;
    page.debug = {};
    if (file.isOpeningContent()) {
      page.debug.templatePath = config.requiredValue("templates.section");
      return indexTemplate(page, {
        //todo![template api] unsafe to allow proto methods.
        // See Template API docs.
        allowProtoMethodsByDefault: true,
        allowProtoPropertiesByDefault: true
      });
    } else {
      page.debug = { templatePath: config.requiredValue("templates.page") };
      return casePageTemplate(page, {
        allowProtoMethodsByDefault: true,
        allowProtoPropertiesByDefault: true
      });
    }
  };
  return render;
};
var provider10 = {
  async configure(config) {
    if (config === void 0) {
      throw new Error("missing RenderSTIRProvider configuration");
    }
    const internalRendererConfig = config.requiredSubConfig("renderer");
    const providerName = internalRendererConfig.requiredValue("provider");
    const provider12 = lookupSTIRRenderer(providerName);
    if (provider12 === void 0 || provider12.configure === void 0) {
      throw new Error(`invalid renderer: ${providerName}`);
    }
    const providerConfig = internalRendererConfig.subConfig("config");
    const renderStir = await provider12.configure(providerConfig);
    if (config.textAssembly() === void 0) {
      return stirRenderer(config, renderStir);
    } else {
      return assemblyRenderer(config, renderStir);
    }
  }
};
registerSTIRRenderer("Stir2Template", provider10);

// textplain/renderSTIR.ts
async function configRenderSTIRProvider(config) {
  const providerName = config.requiredValue("provider");
  const provider12 = lookupSTIRRenderer(providerName);
  if (provider12 === void 0 || provider12.configure === void 0) {
    throw new Error(`invalid outlet: ${providerName}`);
  }
  const providerConfig = config.subConfig("config");
  const outlet = await provider12.configure(providerConfig);
  return (stir) => {
    const out = outlet(stir);
    return out;
  };
}

// textplain/filetypes.ts
var extMap = {};
function registerFileType(name, type, role, mimetype, userDefined, ...extensions) {
  extensions.forEach((ext2) => {
    ext2 = ext2.toLowerCase();
    if (extMap[ext2] !== void 0) {
      throw new Error(`duplicate filetype registration for extension: ${ext2}`);
    }
    extMap[ext2] = { name, type, role, userDefined, mimetype };
  });
}
function registerBuiltinFileType(name, type, role, mimetype, ...extensions) {
  registerFileType(name, type, role, mimetype, false, ...extensions);
}
var UNKNOWN = { name: "unknown", type: "unknown", role: "unknown", userDefined: false, mimetype: void 0 };
function ext(f) {
  return f.slice((f.lastIndexOf(".") - 1 >>> 0) + 2);
}
function fileTypeByFilename(name) {
  const e = ext(name);
  return extMap[e] || extMap["$" + name] || UNKNOWN;
}
registerBuiltinFileType("HTML", "text", "content", "text/html", "html", "htm");
registerBuiltinFileType("MARKDOWN", "text", "content", "text/markdown", "md", "markdown");
registerBuiltinFileType("STIR (JSON)", "text", "content", "text/json+stir", "stir");
registerBuiltinFileType("TEXT", "text", "content", "text/plain", "txt");
registerBuiltinFileType("JPEG", "media", "content", "image/jpeg", "jpeg", "jpg");
registerBuiltinFileType("PNG", "media", "content", "image/png", "png");
registerBuiltinFileType("GIF", "media", "content", "image/gif", "gif");
registerBuiltinFileType("SVG", "media", "content", "image/svg+xml", "svg");
registerBuiltinFileType("CSS", "resource", "resource", "text/css", "css");
registerBuiltinFileType("ICO", "resource", "resource", void 0, "ico");
registerBuiltinFileType("JS", "resource", "resource", "text/javascript", "js");
registerBuiltinFileType("TextAssembly sort spec", "resource", "assembly meta", void 0, "$sort");

// textplain/render/assembly/assembly2website.ts
var import_handlebars6 = __toESM(require_handlebars(), 1);
var import_path_browserify5 = __toESM(require_path_browserify(), 1);
var import_encode2 = __toESM(require_encode(), 1);

// node_modules/minisearch/dist/es/index.js
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
var ENTRIES = "ENTRIES";
var KEYS = "KEYS";
var VALUES = "VALUES";
var LEAF = "";
var TreeIterator = (
  /** @class */
  function() {
    function TreeIterator2(set, type) {
      var node = set._tree;
      var keys = Array.from(node.keys());
      this.set = set;
      this._type = type;
      this._path = keys.length > 0 ? [{ node, keys }] : [];
    }
    TreeIterator2.prototype.next = function() {
      var value = this.dive();
      this.backtrack();
      return value;
    };
    TreeIterator2.prototype.dive = function() {
      if (this._path.length === 0) {
        return { done: true, value: void 0 };
      }
      var _a3 = last$1(this._path), node = _a3.node, keys = _a3.keys;
      if (last$1(keys) === LEAF) {
        return { done: false, value: this.result() };
      }
      var child = node.get(last$1(keys));
      this._path.push({ node: child, keys: Array.from(child.keys()) });
      return this.dive();
    };
    TreeIterator2.prototype.backtrack = function() {
      if (this._path.length === 0) {
        return;
      }
      var keys = last$1(this._path).keys;
      keys.pop();
      if (keys.length > 0) {
        return;
      }
      this._path.pop();
      this.backtrack();
    };
    TreeIterator2.prototype.key = function() {
      return this.set._prefix + this._path.map(function(_a3) {
        var keys = _a3.keys;
        return last$1(keys);
      }).filter(function(key) {
        return key !== LEAF;
      }).join("");
    };
    TreeIterator2.prototype.value = function() {
      return last$1(this._path).node.get(LEAF);
    };
    TreeIterator2.prototype.result = function() {
      switch (this._type) {
        case VALUES:
          return this.value();
        case KEYS:
          return this.key();
        default:
          return [this.key(), this.value()];
      }
    };
    TreeIterator2.prototype[Symbol.iterator] = function() {
      return this;
    };
    return TreeIterator2;
  }()
);
var last$1 = function(array) {
  return array[array.length - 1];
};
var fuzzySearch = function(node, query, maxDistance) {
  var results = /* @__PURE__ */ new Map();
  if (query === void 0)
    return results;
  var n = query.length + 1;
  var m = n + maxDistance;
  var matrix = new Uint8Array(m * n).fill(maxDistance + 1);
  for (var j = 0; j < n; ++j)
    matrix[j] = j;
  for (var i = 1; i < m; ++i)
    matrix[i * n] = i;
  recurse(node, query, maxDistance, results, matrix, 1, n, "");
  return results;
};
var recurse = function(node, query, maxDistance, results, matrix, m, n, prefix) {
  var e_1, _a3;
  var offset = m * n;
  try {
    key:
      for (var _b = __values(node.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var key = _c.value;
        if (key === LEAF) {
          var distance = matrix[offset - 1];
          if (distance <= maxDistance) {
            results.set(prefix, [node.get(key), distance]);
          }
        } else {
          var i = m;
          for (var pos = 0; pos < key.length; ++pos, ++i) {
            var char = key[pos];
            var thisRowOffset = n * i;
            var prevRowOffset = thisRowOffset - n;
            var minDistance = matrix[thisRowOffset];
            var jmin = Math.max(0, i - maxDistance - 1);
            var jmax = Math.min(n - 1, i + maxDistance);
            for (var j = jmin; j < jmax; ++j) {
              var different = char !== query[j];
              var rpl = matrix[prevRowOffset + j] + +different;
              var del = matrix[prevRowOffset + j + 1] + 1;
              var ins = matrix[thisRowOffset + j] + 1;
              var dist = matrix[thisRowOffset + j + 1] = Math.min(rpl, del, ins);
              if (dist < minDistance)
                minDistance = dist;
            }
            if (minDistance > maxDistance) {
              continue key;
            }
          }
          recurse(node.get(key), query, maxDistance, results, matrix, i, n, prefix + key);
        }
      }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a3 = _b.return))
        _a3.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
};
var SearchableMap = (
  /** @class */
  function() {
    function SearchableMap2(tree, prefix) {
      if (tree === void 0) {
        tree = /* @__PURE__ */ new Map();
      }
      if (prefix === void 0) {
        prefix = "";
      }
      this._size = void 0;
      this._tree = tree;
      this._prefix = prefix;
    }
    SearchableMap2.prototype.atPrefix = function(prefix) {
      var e_1, _a3;
      if (!prefix.startsWith(this._prefix)) {
        throw new Error("Mismatched prefix");
      }
      var _b = __read(trackDown(this._tree, prefix.slice(this._prefix.length)), 2), node = _b[0], path = _b[1];
      if (node === void 0) {
        var _c = __read(last(path), 2), parentNode = _c[0], key = _c[1];
        try {
          for (var _d = __values(parentNode.keys()), _e = _d.next(); !_e.done; _e = _d.next()) {
            var k = _e.value;
            if (k !== LEAF && k.startsWith(key)) {
              var node_1 = /* @__PURE__ */ new Map();
              node_1.set(k.slice(key.length), parentNode.get(k));
              return new SearchableMap2(node_1, prefix);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_e && !_e.done && (_a3 = _d.return))
              _a3.call(_d);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      return new SearchableMap2(node, prefix);
    };
    SearchableMap2.prototype.clear = function() {
      this._size = void 0;
      this._tree.clear();
    };
    SearchableMap2.prototype.delete = function(key) {
      this._size = void 0;
      return remove(this._tree, key);
    };
    SearchableMap2.prototype.entries = function() {
      return new TreeIterator(this, ENTRIES);
    };
    SearchableMap2.prototype.forEach = function(fn) {
      var e_2, _a3;
      try {
        for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
          fn(key, value, this);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    };
    SearchableMap2.prototype.fuzzyGet = function(key, maxEditDistance) {
      return fuzzySearch(this._tree, key, maxEditDistance);
    };
    SearchableMap2.prototype.get = function(key) {
      var node = lookup(this._tree, key);
      return node !== void 0 ? node.get(LEAF) : void 0;
    };
    SearchableMap2.prototype.has = function(key) {
      var node = lookup(this._tree, key);
      return node !== void 0 && node.has(LEAF);
    };
    SearchableMap2.prototype.keys = function() {
      return new TreeIterator(this, KEYS);
    };
    SearchableMap2.prototype.set = function(key, value) {
      if (typeof key !== "string") {
        throw new Error("key must be a string");
      }
      this._size = void 0;
      var node = createPath(this._tree, key);
      node.set(LEAF, value);
      return this;
    };
    Object.defineProperty(SearchableMap2.prototype, "size", {
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/size
       */
      get: function() {
        if (this._size) {
          return this._size;
        }
        this._size = 0;
        var iter = this.entries();
        while (!iter.next().done)
          this._size += 1;
        return this._size;
      },
      enumerable: false,
      configurable: true
    });
    SearchableMap2.prototype.update = function(key, fn) {
      if (typeof key !== "string") {
        throw new Error("key must be a string");
      }
      this._size = void 0;
      var node = createPath(this._tree, key);
      node.set(LEAF, fn(node.get(LEAF)));
      return this;
    };
    SearchableMap2.prototype.fetch = function(key, initial) {
      if (typeof key !== "string") {
        throw new Error("key must be a string");
      }
      this._size = void 0;
      var node = createPath(this._tree, key);
      var value = node.get(LEAF);
      if (value === void 0) {
        node.set(LEAF, value = initial());
      }
      return value;
    };
    SearchableMap2.prototype.values = function() {
      return new TreeIterator(this, VALUES);
    };
    SearchableMap2.prototype[Symbol.iterator] = function() {
      return this.entries();
    };
    SearchableMap2.from = function(entries) {
      var e_3, _a3;
      var tree = new SearchableMap2();
      try {
        for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
          var _b = __read(entries_1_1.value, 2), key = _b[0], value = _b[1];
          tree.set(key, value);
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (entries_1_1 && !entries_1_1.done && (_a3 = entries_1.return))
            _a3.call(entries_1);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      return tree;
    };
    SearchableMap2.fromObject = function(object) {
      return SearchableMap2.from(Object.entries(object));
    };
    return SearchableMap2;
  }()
);
var trackDown = function(tree, key, path) {
  var e_4, _a3;
  if (path === void 0) {
    path = [];
  }
  if (key.length === 0 || tree == null) {
    return [tree, path];
  }
  try {
    for (var _b = __values(tree.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var k = _c.value;
      if (k !== LEAF && key.startsWith(k)) {
        path.push([tree, k]);
        return trackDown(tree.get(k), key.slice(k.length), path);
      }
    }
  } catch (e_4_1) {
    e_4 = { error: e_4_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a3 = _b.return))
        _a3.call(_b);
    } finally {
      if (e_4)
        throw e_4.error;
    }
  }
  path.push([tree, key]);
  return trackDown(void 0, "", path);
};
var lookup = function(tree, key) {
  var e_5, _a3;
  if (key.length === 0 || tree == null) {
    return tree;
  }
  try {
    for (var _b = __values(tree.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var k = _c.value;
      if (k !== LEAF && key.startsWith(k)) {
        return lookup(tree.get(k), key.slice(k.length));
      }
    }
  } catch (e_5_1) {
    e_5 = { error: e_5_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a3 = _b.return))
        _a3.call(_b);
    } finally {
      if (e_5)
        throw e_5.error;
    }
  }
};
var createPath = function(node, key) {
  var e_6, _a3;
  var keyLength = key.length;
  outer:
    for (var pos = 0; node && pos < keyLength; ) {
      try {
        for (var _b = (e_6 = void 0, __values(node.keys())), _c = _b.next(); !_c.done; _c = _b.next()) {
          var k = _c.value;
          if (k !== LEAF && key[pos] === k[0]) {
            var len = Math.min(keyLength - pos, k.length);
            var offset = 1;
            while (offset < len && key[pos + offset] === k[offset])
              ++offset;
            var child_1 = node.get(k);
            if (offset === k.length) {
              node = child_1;
            } else {
              var intermediate = /* @__PURE__ */ new Map();
              intermediate.set(k.slice(offset), child_1);
              node.set(key.slice(pos, pos + offset), intermediate);
              node.delete(k);
              node = intermediate;
            }
            pos += offset;
            continue outer;
          }
        }
      } catch (e_6_1) {
        e_6 = { error: e_6_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_6)
            throw e_6.error;
        }
      }
      var child = /* @__PURE__ */ new Map();
      node.set(key.slice(pos), child);
      return child;
    }
  return node;
};
var remove = function(tree, key) {
  var _a3 = __read(trackDown(tree, key), 2), node = _a3[0], path = _a3[1];
  if (node === void 0) {
    return;
  }
  node.delete(LEAF);
  if (node.size === 0) {
    cleanup(path);
  } else if (node.size === 1) {
    var _b = __read(node.entries().next().value, 2), key_1 = _b[0], value = _b[1];
    merge(path, key_1, value);
  }
};
var cleanup = function(path) {
  if (path.length === 0) {
    return;
  }
  var _a3 = __read(last(path), 2), node = _a3[0], key = _a3[1];
  node.delete(key);
  if (node.size === 0) {
    cleanup(path.slice(0, -1));
  } else if (node.size === 1) {
    var _b = __read(node.entries().next().value, 2), key_2 = _b[0], value = _b[1];
    if (key_2 !== LEAF) {
      merge(path.slice(0, -1), key_2, value);
    }
  }
};
var merge = function(path, key, value) {
  if (path.length === 0) {
    return;
  }
  var _a3 = __read(last(path), 2), node = _a3[0], nodeKey = _a3[1];
  node.set(nodeKey + key, value);
  node.delete(nodeKey);
};
var last = function(array) {
  return array[array.length - 1];
};
var _a2;
var OR = "or";
var AND = "and";
var AND_NOT = "and_not";
var MiniSearch = (
  /** @class */
  function() {
    function MiniSearch2(options) {
      if ((options === null || options === void 0 ? void 0 : options.fields) == null) {
        throw new Error('MiniSearch: option "fields" must be provided');
      }
      var autoVacuum = options.autoVacuum == null || options.autoVacuum === true ? defaultAutoVacuumOptions : options.autoVacuum;
      this._options = __assign(__assign(__assign({}, defaultOptions), options), { autoVacuum, searchOptions: __assign(__assign({}, defaultSearchOptions), options.searchOptions || {}), autoSuggestOptions: __assign(__assign({}, defaultAutoSuggestOptions), options.autoSuggestOptions || {}) });
      this._index = new SearchableMap();
      this._documentCount = 0;
      this._documentIds = /* @__PURE__ */ new Map();
      this._idToShortId = /* @__PURE__ */ new Map();
      this._fieldIds = {};
      this._fieldLength = /* @__PURE__ */ new Map();
      this._avgFieldLength = [];
      this._nextId = 0;
      this._storedFields = /* @__PURE__ */ new Map();
      this._dirtCount = 0;
      this._currentVacuum = null;
      this._enqueuedVacuum = null;
      this._enqueuedVacuumConditions = defaultVacuumConditions;
      this.addFields(this._options.fields);
    }
    MiniSearch2.prototype.add = function(document) {
      var e_1, _a3, e_2, _b, e_3, _c;
      var _d = this._options, extractField = _d.extractField, tokenize5 = _d.tokenize, processTerm = _d.processTerm, fields = _d.fields, idField = _d.idField;
      var id = extractField(document, idField);
      if (id == null) {
        throw new Error('MiniSearch: document does not have ID field "'.concat(idField, '"'));
      }
      if (this._idToShortId.has(id)) {
        throw new Error("MiniSearch: duplicate ID ".concat(id));
      }
      var shortDocumentId = this.addDocumentId(id);
      this.saveStoredFields(shortDocumentId, document);
      try {
        for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
          var field = fields_1_1.value;
          var fieldValue = extractField(document, field);
          if (fieldValue == null)
            continue;
          var tokens = tokenize5(fieldValue.toString(), field);
          var fieldId = this._fieldIds[field];
          var uniqueTerms = new Set(tokens).size;
          this.addFieldLength(shortDocumentId, fieldId, this._documentCount - 1, uniqueTerms);
          try {
            for (var tokens_1 = (e_2 = void 0, __values(tokens)), tokens_1_1 = tokens_1.next(); !tokens_1_1.done; tokens_1_1 = tokens_1.next()) {
              var term = tokens_1_1.value;
              var processedTerm = processTerm(term, field);
              if (Array.isArray(processedTerm)) {
                try {
                  for (var processedTerm_1 = (e_3 = void 0, __values(processedTerm)), processedTerm_1_1 = processedTerm_1.next(); !processedTerm_1_1.done; processedTerm_1_1 = processedTerm_1.next()) {
                    var t = processedTerm_1_1.value;
                    this.addTerm(fieldId, shortDocumentId, t);
                  }
                } catch (e_3_1) {
                  e_3 = { error: e_3_1 };
                } finally {
                  try {
                    if (processedTerm_1_1 && !processedTerm_1_1.done && (_c = processedTerm_1.return))
                      _c.call(processedTerm_1);
                  } finally {
                    if (e_3)
                      throw e_3.error;
                  }
                }
              } else if (processedTerm) {
                this.addTerm(fieldId, shortDocumentId, processedTerm);
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (tokens_1_1 && !tokens_1_1.done && (_b = tokens_1.return))
                _b.call(tokens_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (fields_1_1 && !fields_1_1.done && (_a3 = fields_1.return))
            _a3.call(fields_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    MiniSearch2.prototype.addAll = function(documents) {
      var e_4, _a3;
      try {
        for (var documents_1 = __values(documents), documents_1_1 = documents_1.next(); !documents_1_1.done; documents_1_1 = documents_1.next()) {
          var document_1 = documents_1_1.value;
          this.add(document_1);
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (documents_1_1 && !documents_1_1.done && (_a3 = documents_1.return))
            _a3.call(documents_1);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    };
    MiniSearch2.prototype.addAllAsync = function(documents, options) {
      var _this = this;
      if (options === void 0) {
        options = {};
      }
      var _a3 = options.chunkSize, chunkSize = _a3 === void 0 ? 10 : _a3;
      var acc = { chunk: [], promise: Promise.resolve() };
      var _b = documents.reduce(function(_a4, document, i) {
        var chunk2 = _a4.chunk, promise2 = _a4.promise;
        chunk2.push(document);
        if ((i + 1) % chunkSize === 0) {
          return {
            chunk: [],
            promise: promise2.then(function() {
              return new Promise(function(resolve) {
                return setTimeout(resolve, 0);
              });
            }).then(function() {
              return _this.addAll(chunk2);
            })
          };
        } else {
          return { chunk: chunk2, promise: promise2 };
        }
      }, acc), chunk = _b.chunk, promise = _b.promise;
      return promise.then(function() {
        return _this.addAll(chunk);
      });
    };
    MiniSearch2.prototype.remove = function(document) {
      var e_5, _a3, e_6, _b, e_7, _c;
      var _d = this._options, tokenize5 = _d.tokenize, processTerm = _d.processTerm, extractField = _d.extractField, fields = _d.fields, idField = _d.idField;
      var id = extractField(document, idField);
      if (id == null) {
        throw new Error('MiniSearch: document does not have ID field "'.concat(idField, '"'));
      }
      var shortId = this._idToShortId.get(id);
      if (shortId == null) {
        throw new Error("MiniSearch: cannot remove document with ID ".concat(id, ": it is not in the index"));
      }
      try {
        for (var fields_2 = __values(fields), fields_2_1 = fields_2.next(); !fields_2_1.done; fields_2_1 = fields_2.next()) {
          var field = fields_2_1.value;
          var fieldValue = extractField(document, field);
          if (fieldValue == null)
            continue;
          var tokens = tokenize5(fieldValue.toString(), field);
          var fieldId = this._fieldIds[field];
          var uniqueTerms = new Set(tokens).size;
          this.removeFieldLength(shortId, fieldId, this._documentCount, uniqueTerms);
          try {
            for (var tokens_2 = (e_6 = void 0, __values(tokens)), tokens_2_1 = tokens_2.next(); !tokens_2_1.done; tokens_2_1 = tokens_2.next()) {
              var term = tokens_2_1.value;
              var processedTerm = processTerm(term, field);
              if (Array.isArray(processedTerm)) {
                try {
                  for (var processedTerm_2 = (e_7 = void 0, __values(processedTerm)), processedTerm_2_1 = processedTerm_2.next(); !processedTerm_2_1.done; processedTerm_2_1 = processedTerm_2.next()) {
                    var t = processedTerm_2_1.value;
                    this.removeTerm(fieldId, shortId, t);
                  }
                } catch (e_7_1) {
                  e_7 = { error: e_7_1 };
                } finally {
                  try {
                    if (processedTerm_2_1 && !processedTerm_2_1.done && (_c = processedTerm_2.return))
                      _c.call(processedTerm_2);
                  } finally {
                    if (e_7)
                      throw e_7.error;
                  }
                }
              } else if (processedTerm) {
                this.removeTerm(fieldId, shortId, processedTerm);
              }
            }
          } catch (e_6_1) {
            e_6 = { error: e_6_1 };
          } finally {
            try {
              if (tokens_2_1 && !tokens_2_1.done && (_b = tokens_2.return))
                _b.call(tokens_2);
            } finally {
              if (e_6)
                throw e_6.error;
            }
          }
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (fields_2_1 && !fields_2_1.done && (_a3 = fields_2.return))
            _a3.call(fields_2);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      this._storedFields.delete(shortId);
      this._documentIds.delete(shortId);
      this._idToShortId.delete(id);
      this._fieldLength.delete(shortId);
      this._documentCount -= 1;
    };
    MiniSearch2.prototype.removeAll = function(documents) {
      var e_8, _a3;
      if (documents) {
        try {
          for (var documents_2 = __values(documents), documents_2_1 = documents_2.next(); !documents_2_1.done; documents_2_1 = documents_2.next()) {
            var document_2 = documents_2_1.value;
            this.remove(document_2);
          }
        } catch (e_8_1) {
          e_8 = { error: e_8_1 };
        } finally {
          try {
            if (documents_2_1 && !documents_2_1.done && (_a3 = documents_2.return))
              _a3.call(documents_2);
          } finally {
            if (e_8)
              throw e_8.error;
          }
        }
      } else if (arguments.length > 0) {
        throw new Error("Expected documents to be present. Omit the argument to remove all documents.");
      } else {
        this._index = new SearchableMap();
        this._documentCount = 0;
        this._documentIds = /* @__PURE__ */ new Map();
        this._idToShortId = /* @__PURE__ */ new Map();
        this._fieldLength = /* @__PURE__ */ new Map();
        this._avgFieldLength = [];
        this._storedFields = /* @__PURE__ */ new Map();
        this._nextId = 0;
      }
    };
    MiniSearch2.prototype.discard = function(id) {
      var _this = this;
      var shortId = this._idToShortId.get(id);
      if (shortId == null) {
        throw new Error("MiniSearch: cannot discard document with ID ".concat(id, ": it is not in the index"));
      }
      this._idToShortId.delete(id);
      this._documentIds.delete(shortId);
      this._storedFields.delete(shortId);
      (this._fieldLength.get(shortId) || []).forEach(function(fieldLength, fieldId) {
        _this.removeFieldLength(shortId, fieldId, _this._documentCount, fieldLength);
      });
      this._fieldLength.delete(shortId);
      this._documentCount -= 1;
      this._dirtCount += 1;
      this.maybeAutoVacuum();
    };
    MiniSearch2.prototype.maybeAutoVacuum = function() {
      if (this._options.autoVacuum === false) {
        return;
      }
      var _a3 = this._options.autoVacuum, minDirtFactor = _a3.minDirtFactor, minDirtCount = _a3.minDirtCount, batchSize = _a3.batchSize, batchWait = _a3.batchWait;
      this.conditionalVacuum({ batchSize, batchWait }, { minDirtCount, minDirtFactor });
    };
    MiniSearch2.prototype.discardAll = function(ids) {
      var e_9, _a3;
      var autoVacuum = this._options.autoVacuum;
      try {
        this._options.autoVacuum = false;
        try {
          for (var ids_1 = __values(ids), ids_1_1 = ids_1.next(); !ids_1_1.done; ids_1_1 = ids_1.next()) {
            var id = ids_1_1.value;
            this.discard(id);
          }
        } catch (e_9_1) {
          e_9 = { error: e_9_1 };
        } finally {
          try {
            if (ids_1_1 && !ids_1_1.done && (_a3 = ids_1.return))
              _a3.call(ids_1);
          } finally {
            if (e_9)
              throw e_9.error;
          }
        }
      } finally {
        this._options.autoVacuum = autoVacuum;
      }
      this.maybeAutoVacuum();
    };
    MiniSearch2.prototype.replace = function(updatedDocument) {
      var _a3 = this._options, idField = _a3.idField, extractField = _a3.extractField;
      var id = extractField(updatedDocument, idField);
      this.discard(id);
      this.add(updatedDocument);
    };
    MiniSearch2.prototype.vacuum = function(options) {
      if (options === void 0) {
        options = {};
      }
      return this.conditionalVacuum(options);
    };
    MiniSearch2.prototype.conditionalVacuum = function(options, conditions) {
      var _this = this;
      if (this._currentVacuum) {
        this._enqueuedVacuumConditions = this._enqueuedVacuumConditions && conditions;
        if (this._enqueuedVacuum != null) {
          return this._enqueuedVacuum;
        }
        this._enqueuedVacuum = this._currentVacuum.then(function() {
          var conditions2 = _this._enqueuedVacuumConditions;
          _this._enqueuedVacuumConditions = defaultVacuumConditions;
          return _this.performVacuuming(options, conditions2);
        });
        return this._enqueuedVacuum;
      }
      if (this.vacuumConditionsMet(conditions) === false) {
        return Promise.resolve();
      }
      this._currentVacuum = this.performVacuuming(options);
      return this._currentVacuum;
    };
    MiniSearch2.prototype.performVacuuming = function(options, conditions) {
      return __awaiter(this, void 0, void 0, function() {
        var initialDirtCount, batchSize, batchWait_1, i, _a3, _b, _c, term, fieldsData, fieldsData_1, fieldsData_1_1, _d, fieldId, fieldIndex, fieldIndex_1, fieldIndex_1_1, _e, shortId, e_10_1;
        var e_10, _f, e_11, _g, e_12, _h;
        return __generator(this, function(_j) {
          switch (_j.label) {
            case 0:
              initialDirtCount = this._dirtCount;
              if (!this.vacuumConditionsMet(conditions))
                return [3, 10];
              batchSize = options.batchSize || defaultVacuumOptions.batchSize;
              batchWait_1 = options.batchWait || defaultVacuumOptions.batchWait;
              i = 1;
              _j.label = 1;
            case 1:
              _j.trys.push([1, 7, 8, 9]);
              _a3 = __values(this._index), _b = _a3.next();
              _j.label = 2;
            case 2:
              if (!!_b.done)
                return [3, 6];
              _c = __read(_b.value, 2), term = _c[0], fieldsData = _c[1];
              try {
                for (fieldsData_1 = (e_11 = void 0, __values(fieldsData)), fieldsData_1_1 = fieldsData_1.next(); !fieldsData_1_1.done; fieldsData_1_1 = fieldsData_1.next()) {
                  _d = __read(fieldsData_1_1.value, 2), fieldId = _d[0], fieldIndex = _d[1];
                  try {
                    for (fieldIndex_1 = (e_12 = void 0, __values(fieldIndex)), fieldIndex_1_1 = fieldIndex_1.next(); !fieldIndex_1_1.done; fieldIndex_1_1 = fieldIndex_1.next()) {
                      _e = __read(fieldIndex_1_1.value, 1), shortId = _e[0];
                      if (this._documentIds.has(shortId)) {
                        continue;
                      }
                      if (fieldIndex.size <= 1) {
                        fieldsData.delete(fieldId);
                      } else {
                        fieldIndex.delete(shortId);
                      }
                    }
                  } catch (e_12_1) {
                    e_12 = { error: e_12_1 };
                  } finally {
                    try {
                      if (fieldIndex_1_1 && !fieldIndex_1_1.done && (_h = fieldIndex_1.return))
                        _h.call(fieldIndex_1);
                    } finally {
                      if (e_12)
                        throw e_12.error;
                    }
                  }
                }
              } catch (e_11_1) {
                e_11 = { error: e_11_1 };
              } finally {
                try {
                  if (fieldsData_1_1 && !fieldsData_1_1.done && (_g = fieldsData_1.return))
                    _g.call(fieldsData_1);
                } finally {
                  if (e_11)
                    throw e_11.error;
                }
              }
              if (this._index.get(term).size === 0) {
                this._index.delete(term);
              }
              if (!(i % batchSize === 0))
                return [3, 4];
              return [4, new Promise(function(resolve) {
                return setTimeout(resolve, batchWait_1);
              })];
            case 3:
              _j.sent();
              _j.label = 4;
            case 4:
              i += 1;
              _j.label = 5;
            case 5:
              _b = _a3.next();
              return [3, 2];
            case 6:
              return [3, 9];
            case 7:
              e_10_1 = _j.sent();
              e_10 = { error: e_10_1 };
              return [3, 9];
            case 8:
              try {
                if (_b && !_b.done && (_f = _a3.return))
                  _f.call(_a3);
              } finally {
                if (e_10)
                  throw e_10.error;
              }
              return [
                7
                /*endfinally*/
              ];
            case 9:
              this._dirtCount -= initialDirtCount;
              _j.label = 10;
            case 10:
              return [4, null];
            case 11:
              _j.sent();
              this._currentVacuum = this._enqueuedVacuum;
              this._enqueuedVacuum = null;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    MiniSearch2.prototype.vacuumConditionsMet = function(conditions) {
      if (conditions == null) {
        return true;
      }
      var minDirtCount = conditions.minDirtCount, minDirtFactor = conditions.minDirtFactor;
      minDirtCount = minDirtCount || defaultAutoVacuumOptions.minDirtCount;
      minDirtFactor = minDirtFactor || defaultAutoVacuumOptions.minDirtFactor;
      return this.dirtCount >= minDirtCount && this.dirtFactor >= minDirtFactor;
    };
    Object.defineProperty(MiniSearch2.prototype, "isVacuuming", {
      /**
       * Is `true` if a vacuuming operation is ongoing, `false` otherwise
       */
      get: function() {
        return this._currentVacuum != null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MiniSearch2.prototype, "dirtCount", {
      /**
       * The number of documents discarded since the most recent vacuuming
       */
      get: function() {
        return this._dirtCount;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MiniSearch2.prototype, "dirtFactor", {
      /**
       * A number between 0 and 1 giving an indication about the proportion of
       * documents that are discarded, and can therefore be cleaned up by vacuuming.
       * A value close to 0 means that the index is relatively clean, while a higher
       * value means that the index is relatively dirty, and vacuuming could release
       * memory.
       */
      get: function() {
        return this._dirtCount / (1 + this._documentCount + this._dirtCount);
      },
      enumerable: false,
      configurable: true
    });
    MiniSearch2.prototype.has = function(id) {
      return this._idToShortId.has(id);
    };
    MiniSearch2.prototype.getStoredFields = function(id) {
      var shortId = this._idToShortId.get(id);
      if (shortId == null) {
        return void 0;
      }
      return this._storedFields.get(shortId);
    };
    MiniSearch2.prototype.search = function(query, searchOptions) {
      var e_13, _a3;
      if (searchOptions === void 0) {
        searchOptions = {};
      }
      var rawResults = this.executeQuery(query, searchOptions);
      var results = [];
      try {
        for (var rawResults_1 = __values(rawResults), rawResults_1_1 = rawResults_1.next(); !rawResults_1_1.done; rawResults_1_1 = rawResults_1.next()) {
          var _b = __read(rawResults_1_1.value, 2), docId = _b[0], _c = _b[1], score = _c.score, terms = _c.terms, match = _c.match;
          var quality = terms.length || 1;
          var result = {
            id: this._documentIds.get(docId),
            score: score * quality,
            terms: Object.keys(match),
            match
          };
          Object.assign(result, this._storedFields.get(docId));
          if (searchOptions.filter == null || searchOptions.filter(result)) {
            results.push(result);
          }
        }
      } catch (e_13_1) {
        e_13 = { error: e_13_1 };
      } finally {
        try {
          if (rawResults_1_1 && !rawResults_1_1.done && (_a3 = rawResults_1.return))
            _a3.call(rawResults_1);
        } finally {
          if (e_13)
            throw e_13.error;
        }
      }
      if (query === MiniSearch2.wildcard && searchOptions.boostDocument == null && this._options.searchOptions.boostDocument == null) {
        return results;
      }
      results.sort(byScore);
      return results;
    };
    MiniSearch2.prototype.autoSuggest = function(queryString, options) {
      var e_14, _a3, e_15, _b;
      if (options === void 0) {
        options = {};
      }
      options = __assign(__assign({}, this._options.autoSuggestOptions), options);
      var suggestions = /* @__PURE__ */ new Map();
      try {
        for (var _c = __values(this.search(queryString, options)), _d = _c.next(); !_d.done; _d = _c.next()) {
          var _e = _d.value, score = _e.score, terms = _e.terms;
          var phrase = terms.join(" ");
          var suggestion = suggestions.get(phrase);
          if (suggestion != null) {
            suggestion.score += score;
            suggestion.count += 1;
          } else {
            suggestions.set(phrase, { score, terms, count: 1 });
          }
        }
      } catch (e_14_1) {
        e_14 = { error: e_14_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a3 = _c.return))
            _a3.call(_c);
        } finally {
          if (e_14)
            throw e_14.error;
        }
      }
      var results = [];
      try {
        for (var suggestions_1 = __values(suggestions), suggestions_1_1 = suggestions_1.next(); !suggestions_1_1.done; suggestions_1_1 = suggestions_1.next()) {
          var _f = __read(suggestions_1_1.value, 2), suggestion = _f[0], _g = _f[1], score = _g.score, terms = _g.terms, count = _g.count;
          results.push({ suggestion, terms, score: score / count });
        }
      } catch (e_15_1) {
        e_15 = { error: e_15_1 };
      } finally {
        try {
          if (suggestions_1_1 && !suggestions_1_1.done && (_b = suggestions_1.return))
            _b.call(suggestions_1);
        } finally {
          if (e_15)
            throw e_15.error;
        }
      }
      results.sort(byScore);
      return results;
    };
    Object.defineProperty(MiniSearch2.prototype, "documentCount", {
      /**
       * Total number of documents available to search
       */
      get: function() {
        return this._documentCount;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MiniSearch2.prototype, "termCount", {
      /**
       * Number of terms in the index
       */
      get: function() {
        return this._index.size;
      },
      enumerable: false,
      configurable: true
    });
    MiniSearch2.loadJSON = function(json, options) {
      if (options == null) {
        throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");
      }
      return this.loadJS(JSON.parse(json), options);
    };
    MiniSearch2.getDefault = function(optionName) {
      if (defaultOptions.hasOwnProperty(optionName)) {
        return getOwnProperty(defaultOptions, optionName);
      } else {
        throw new Error('MiniSearch: unknown option "'.concat(optionName, '"'));
      }
    };
    MiniSearch2.loadJS = function(js, options) {
      var e_16, _a3, e_17, _b, e_18, _c;
      var index = js.index, documentCount = js.documentCount, nextId = js.nextId, documentIds = js.documentIds, fieldIds = js.fieldIds, fieldLength = js.fieldLength, averageFieldLength = js.averageFieldLength, storedFields = js.storedFields, dirtCount = js.dirtCount, serializationVersion = js.serializationVersion;
      if (serializationVersion !== 1 && serializationVersion !== 2) {
        throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");
      }
      var miniSearch = new MiniSearch2(options);
      miniSearch._documentCount = documentCount;
      miniSearch._nextId = nextId;
      miniSearch._documentIds = objectToNumericMap(documentIds);
      miniSearch._idToShortId = /* @__PURE__ */ new Map();
      miniSearch._fieldIds = fieldIds;
      miniSearch._fieldLength = objectToNumericMap(fieldLength);
      miniSearch._avgFieldLength = averageFieldLength;
      miniSearch._storedFields = objectToNumericMap(storedFields);
      miniSearch._dirtCount = dirtCount || 0;
      miniSearch._index = new SearchableMap();
      try {
        for (var _d = __values(miniSearch._documentIds), _e = _d.next(); !_e.done; _e = _d.next()) {
          var _f = __read(_e.value, 2), shortId = _f[0], id = _f[1];
          miniSearch._idToShortId.set(id, shortId);
        }
      } catch (e_16_1) {
        e_16 = { error: e_16_1 };
      } finally {
        try {
          if (_e && !_e.done && (_a3 = _d.return))
            _a3.call(_d);
        } finally {
          if (e_16)
            throw e_16.error;
        }
      }
      try {
        for (var index_1 = __values(index), index_1_1 = index_1.next(); !index_1_1.done; index_1_1 = index_1.next()) {
          var _g = __read(index_1_1.value, 2), term = _g[0], data = _g[1];
          var dataMap = /* @__PURE__ */ new Map();
          try {
            for (var _h = (e_18 = void 0, __values(Object.keys(data))), _j = _h.next(); !_j.done; _j = _h.next()) {
              var fieldId = _j.value;
              var indexEntry = data[fieldId];
              if (serializationVersion === 1) {
                indexEntry = indexEntry.ds;
              }
              dataMap.set(parseInt(fieldId, 10), objectToNumericMap(indexEntry));
            }
          } catch (e_18_1) {
            e_18 = { error: e_18_1 };
          } finally {
            try {
              if (_j && !_j.done && (_c = _h.return))
                _c.call(_h);
            } finally {
              if (e_18)
                throw e_18.error;
            }
          }
          miniSearch._index.set(term, dataMap);
        }
      } catch (e_17_1) {
        e_17 = { error: e_17_1 };
      } finally {
        try {
          if (index_1_1 && !index_1_1.done && (_b = index_1.return))
            _b.call(index_1);
        } finally {
          if (e_17)
            throw e_17.error;
        }
      }
      return miniSearch;
    };
    MiniSearch2.prototype.executeQuery = function(query, searchOptions) {
      var _this = this;
      if (searchOptions === void 0) {
        searchOptions = {};
      }
      if (query === MiniSearch2.wildcard) {
        return this.executeWildcardQuery(searchOptions);
      }
      if (typeof query !== "string") {
        var options_1 = __assign(__assign(__assign({}, searchOptions), query), { queries: void 0 });
        var results_1 = query.queries.map(function(subquery) {
          return _this.executeQuery(subquery, options_1);
        });
        return this.combineResults(results_1, options_1.combineWith);
      }
      var _a3 = this._options, tokenize5 = _a3.tokenize, processTerm = _a3.processTerm, globalSearchOptions = _a3.searchOptions;
      var options = __assign(__assign({ tokenize: tokenize5, processTerm }, globalSearchOptions), searchOptions);
      var searchTokenize = options.tokenize, searchProcessTerm = options.processTerm;
      var terms = searchTokenize(query).flatMap(function(term) {
        return searchProcessTerm(term);
      }).filter(function(term) {
        return !!term;
      });
      var queries = terms.map(termToQuerySpec(options));
      var results = queries.map(function(query2) {
        return _this.executeQuerySpec(query2, options);
      });
      return this.combineResults(results, options.combineWith);
    };
    MiniSearch2.prototype.executeQuerySpec = function(query, searchOptions) {
      var e_19, _a3, e_20, _b;
      var options = __assign(__assign({}, this._options.searchOptions), searchOptions);
      var boosts = (options.fields || this._options.fields).reduce(function(boosts2, field) {
        var _a4;
        return __assign(__assign({}, boosts2), (_a4 = {}, _a4[field] = getOwnProperty(options.boost, field) || 1, _a4));
      }, {});
      var boostDocument = options.boostDocument, weights = options.weights, maxFuzzy = options.maxFuzzy, bm25params = options.bm25;
      var _c = __assign(__assign({}, defaultSearchOptions.weights), weights), fuzzyWeight = _c.fuzzy, prefixWeight = _c.prefix;
      var data = this._index.get(query.term);
      var results = this.termResults(query.term, query.term, 1, data, boosts, boostDocument, bm25params);
      var prefixMatches;
      var fuzzyMatches;
      if (query.prefix) {
        prefixMatches = this._index.atPrefix(query.term);
      }
      if (query.fuzzy) {
        var fuzzy = query.fuzzy === true ? 0.2 : query.fuzzy;
        var maxDistance = fuzzy < 1 ? Math.min(maxFuzzy, Math.round(query.term.length * fuzzy)) : fuzzy;
        if (maxDistance)
          fuzzyMatches = this._index.fuzzyGet(query.term, maxDistance);
      }
      if (prefixMatches) {
        try {
          for (var prefixMatches_1 = __values(prefixMatches), prefixMatches_1_1 = prefixMatches_1.next(); !prefixMatches_1_1.done; prefixMatches_1_1 = prefixMatches_1.next()) {
            var _d = __read(prefixMatches_1_1.value, 2), term = _d[0], data_1 = _d[1];
            var distance = term.length - query.term.length;
            if (!distance) {
              continue;
            }
            fuzzyMatches === null || fuzzyMatches === void 0 ? void 0 : fuzzyMatches.delete(term);
            var weight = prefixWeight * term.length / (term.length + 0.3 * distance);
            this.termResults(query.term, term, weight, data_1, boosts, boostDocument, bm25params, results);
          }
        } catch (e_19_1) {
          e_19 = { error: e_19_1 };
        } finally {
          try {
            if (prefixMatches_1_1 && !prefixMatches_1_1.done && (_a3 = prefixMatches_1.return))
              _a3.call(prefixMatches_1);
          } finally {
            if (e_19)
              throw e_19.error;
          }
        }
      }
      if (fuzzyMatches) {
        try {
          for (var _e = __values(fuzzyMatches.keys()), _f = _e.next(); !_f.done; _f = _e.next()) {
            var term = _f.value;
            var _g = __read(fuzzyMatches.get(term), 2), data_2 = _g[0], distance = _g[1];
            if (!distance) {
              continue;
            }
            var weight = fuzzyWeight * term.length / (term.length + distance);
            this.termResults(query.term, term, weight, data_2, boosts, boostDocument, bm25params, results);
          }
        } catch (e_20_1) {
          e_20 = { error: e_20_1 };
        } finally {
          try {
            if (_f && !_f.done && (_b = _e.return))
              _b.call(_e);
          } finally {
            if (e_20)
              throw e_20.error;
          }
        }
      }
      return results;
    };
    MiniSearch2.prototype.executeWildcardQuery = function(searchOptions) {
      var e_21, _a3;
      var results = /* @__PURE__ */ new Map();
      var options = __assign(__assign({}, this._options.searchOptions), searchOptions);
      try {
        for (var _b = __values(this._documentIds), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), shortId = _d[0], id = _d[1];
          var score = options.boostDocument ? options.boostDocument(id, "", this._storedFields.get(shortId)) : 1;
          results.set(shortId, {
            score,
            terms: [],
            match: {}
          });
        }
      } catch (e_21_1) {
        e_21 = { error: e_21_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_21)
            throw e_21.error;
        }
      }
      return results;
    };
    MiniSearch2.prototype.combineResults = function(results, combineWith) {
      if (combineWith === void 0) {
        combineWith = OR;
      }
      if (results.length === 0) {
        return /* @__PURE__ */ new Map();
      }
      var operator = combineWith.toLowerCase();
      return results.reduce(combinators[operator]) || /* @__PURE__ */ new Map();
    };
    MiniSearch2.prototype.toJSON = function() {
      var e_22, _a3, e_23, _b;
      var index = [];
      try {
        for (var _c = __values(this._index), _d = _c.next(); !_d.done; _d = _c.next()) {
          var _e = __read(_d.value, 2), term = _e[0], fieldIndex = _e[1];
          var data = {};
          try {
            for (var fieldIndex_2 = (e_23 = void 0, __values(fieldIndex)), fieldIndex_2_1 = fieldIndex_2.next(); !fieldIndex_2_1.done; fieldIndex_2_1 = fieldIndex_2.next()) {
              var _f = __read(fieldIndex_2_1.value, 2), fieldId = _f[0], freqs = _f[1];
              data[fieldId] = Object.fromEntries(freqs);
            }
          } catch (e_23_1) {
            e_23 = { error: e_23_1 };
          } finally {
            try {
              if (fieldIndex_2_1 && !fieldIndex_2_1.done && (_b = fieldIndex_2.return))
                _b.call(fieldIndex_2);
            } finally {
              if (e_23)
                throw e_23.error;
            }
          }
          index.push([term, data]);
        }
      } catch (e_22_1) {
        e_22 = { error: e_22_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a3 = _c.return))
            _a3.call(_c);
        } finally {
          if (e_22)
            throw e_22.error;
        }
      }
      return {
        documentCount: this._documentCount,
        nextId: this._nextId,
        documentIds: Object.fromEntries(this._documentIds),
        fieldIds: this._fieldIds,
        fieldLength: Object.fromEntries(this._fieldLength),
        averageFieldLength: this._avgFieldLength,
        storedFields: Object.fromEntries(this._storedFields),
        dirtCount: this._dirtCount,
        index,
        serializationVersion: 2
      };
    };
    MiniSearch2.prototype.termResults = function(sourceTerm, derivedTerm, termWeight, fieldTermData, fieldBoosts, boostDocumentFn, bm25params, results) {
      var e_24, _a3, e_25, _b, _c;
      if (results === void 0) {
        results = /* @__PURE__ */ new Map();
      }
      if (fieldTermData == null)
        return results;
      try {
        for (var _d = __values(Object.keys(fieldBoosts)), _e = _d.next(); !_e.done; _e = _d.next()) {
          var field = _e.value;
          var fieldBoost = fieldBoosts[field];
          var fieldId = this._fieldIds[field];
          var fieldTermFreqs = fieldTermData.get(fieldId);
          if (fieldTermFreqs == null)
            continue;
          var matchingFields = fieldTermFreqs.size;
          var avgFieldLength = this._avgFieldLength[fieldId];
          try {
            for (var _f = (e_25 = void 0, __values(fieldTermFreqs.keys())), _g = _f.next(); !_g.done; _g = _f.next()) {
              var docId = _g.value;
              if (!this._documentIds.has(docId)) {
                this.removeTerm(fieldId, docId, derivedTerm);
                matchingFields -= 1;
                continue;
              }
              var docBoost = boostDocumentFn ? boostDocumentFn(this._documentIds.get(docId), derivedTerm, this._storedFields.get(docId)) : 1;
              if (!docBoost)
                continue;
              var termFreq = fieldTermFreqs.get(docId);
              var fieldLength = this._fieldLength.get(docId)[fieldId];
              var rawScore = calcBM25Score(termFreq, matchingFields, this._documentCount, fieldLength, avgFieldLength, bm25params);
              var weightedScore = termWeight * fieldBoost * docBoost * rawScore;
              var result = results.get(docId);
              if (result) {
                result.score += weightedScore;
                assignUniqueTerm(result.terms, sourceTerm);
                var match = getOwnProperty(result.match, derivedTerm);
                if (match) {
                  match.push(field);
                } else {
                  result.match[derivedTerm] = [field];
                }
              } else {
                results.set(docId, {
                  score: weightedScore,
                  terms: [sourceTerm],
                  match: (_c = {}, _c[derivedTerm] = [field], _c)
                });
              }
            }
          } catch (e_25_1) {
            e_25 = { error: e_25_1 };
          } finally {
            try {
              if (_g && !_g.done && (_b = _f.return))
                _b.call(_f);
            } finally {
              if (e_25)
                throw e_25.error;
            }
          }
        }
      } catch (e_24_1) {
        e_24 = { error: e_24_1 };
      } finally {
        try {
          if (_e && !_e.done && (_a3 = _d.return))
            _a3.call(_d);
        } finally {
          if (e_24)
            throw e_24.error;
        }
      }
      return results;
    };
    MiniSearch2.prototype.addTerm = function(fieldId, documentId, term) {
      var indexData = this._index.fetch(term, createMap);
      var fieldIndex = indexData.get(fieldId);
      if (fieldIndex == null) {
        fieldIndex = /* @__PURE__ */ new Map();
        fieldIndex.set(documentId, 1);
        indexData.set(fieldId, fieldIndex);
      } else {
        var docs = fieldIndex.get(documentId);
        fieldIndex.set(documentId, (docs || 0) + 1);
      }
    };
    MiniSearch2.prototype.removeTerm = function(fieldId, documentId, term) {
      if (!this._index.has(term)) {
        this.warnDocumentChanged(documentId, fieldId, term);
        return;
      }
      var indexData = this._index.fetch(term, createMap);
      var fieldIndex = indexData.get(fieldId);
      if (fieldIndex == null || fieldIndex.get(documentId) == null) {
        this.warnDocumentChanged(documentId, fieldId, term);
      } else if (fieldIndex.get(documentId) <= 1) {
        if (fieldIndex.size <= 1) {
          indexData.delete(fieldId);
        } else {
          fieldIndex.delete(documentId);
        }
      } else {
        fieldIndex.set(documentId, fieldIndex.get(documentId) - 1);
      }
      if (this._index.get(term).size === 0) {
        this._index.delete(term);
      }
    };
    MiniSearch2.prototype.warnDocumentChanged = function(shortDocumentId, fieldId, term) {
      var e_26, _a3;
      try {
        for (var _b = __values(Object.keys(this._fieldIds)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var fieldName = _c.value;
          if (this._fieldIds[fieldName] === fieldId) {
            this._options.logger("warn", "MiniSearch: document with ID ".concat(this._documentIds.get(shortDocumentId), ' has changed before removal: term "').concat(term, '" was not present in field "').concat(fieldName, '". Removing a document after it has changed can corrupt the index!'), "version_conflict");
            return;
          }
        }
      } catch (e_26_1) {
        e_26 = { error: e_26_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a3 = _b.return))
            _a3.call(_b);
        } finally {
          if (e_26)
            throw e_26.error;
        }
      }
    };
    MiniSearch2.prototype.addDocumentId = function(documentId) {
      var shortDocumentId = this._nextId;
      this._idToShortId.set(documentId, shortDocumentId);
      this._documentIds.set(shortDocumentId, documentId);
      this._documentCount += 1;
      this._nextId += 1;
      return shortDocumentId;
    };
    MiniSearch2.prototype.addFields = function(fields) {
      for (var i = 0; i < fields.length; i++) {
        this._fieldIds[fields[i]] = i;
      }
    };
    MiniSearch2.prototype.addFieldLength = function(documentId, fieldId, count, length) {
      var fieldLengths = this._fieldLength.get(documentId);
      if (fieldLengths == null)
        this._fieldLength.set(documentId, fieldLengths = []);
      fieldLengths[fieldId] = length;
      var averageFieldLength = this._avgFieldLength[fieldId] || 0;
      var totalFieldLength = averageFieldLength * count + length;
      this._avgFieldLength[fieldId] = totalFieldLength / (count + 1);
    };
    MiniSearch2.prototype.removeFieldLength = function(documentId, fieldId, count, length) {
      if (count === 1) {
        this._avgFieldLength[fieldId] = 0;
        return;
      }
      var totalFieldLength = this._avgFieldLength[fieldId] * count - length;
      this._avgFieldLength[fieldId] = totalFieldLength / (count - 1);
    };
    MiniSearch2.prototype.saveStoredFields = function(documentId, doc) {
      var e_27, _a3;
      var _b = this._options, storeFields = _b.storeFields, extractField = _b.extractField;
      if (storeFields == null || storeFields.length === 0) {
        return;
      }
      var documentFields = this._storedFields.get(documentId);
      if (documentFields == null)
        this._storedFields.set(documentId, documentFields = {});
      try {
        for (var storeFields_1 = __values(storeFields), storeFields_1_1 = storeFields_1.next(); !storeFields_1_1.done; storeFields_1_1 = storeFields_1.next()) {
          var fieldName = storeFields_1_1.value;
          var fieldValue = extractField(doc, fieldName);
          if (fieldValue !== void 0)
            documentFields[fieldName] = fieldValue;
        }
      } catch (e_27_1) {
        e_27 = { error: e_27_1 };
      } finally {
        try {
          if (storeFields_1_1 && !storeFields_1_1.done && (_a3 = storeFields_1.return))
            _a3.call(storeFields_1);
        } finally {
          if (e_27)
            throw e_27.error;
        }
      }
    };
    MiniSearch2.wildcard = Symbol("*");
    return MiniSearch2;
  }()
);
var getOwnProperty = function(object, property) {
  return Object.prototype.hasOwnProperty.call(object, property) ? object[property] : void 0;
};
var combinators = (_a2 = {}, _a2[OR] = function(a, b) {
  var e_28, _a3;
  try {
    for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var docId = _c.value;
      var existing = a.get(docId);
      if (existing == null) {
        a.set(docId, b.get(docId));
      } else {
        var _d = b.get(docId), score = _d.score, terms = _d.terms, match = _d.match;
        existing.score = existing.score + score;
        existing.match = Object.assign(existing.match, match);
        assignUniqueTerms(existing.terms, terms);
      }
    }
  } catch (e_28_1) {
    e_28 = { error: e_28_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a3 = _b.return))
        _a3.call(_b);
    } finally {
      if (e_28)
        throw e_28.error;
    }
  }
  return a;
}, _a2[AND] = function(a, b) {
  var e_29, _a3;
  var combined = /* @__PURE__ */ new Map();
  try {
    for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var docId = _c.value;
      var existing = a.get(docId);
      if (existing == null)
        continue;
      var _d = b.get(docId), score = _d.score, terms = _d.terms, match = _d.match;
      assignUniqueTerms(existing.terms, terms);
      combined.set(docId, {
        score: existing.score + score,
        terms: existing.terms,
        match: Object.assign(existing.match, match)
      });
    }
  } catch (e_29_1) {
    e_29 = { error: e_29_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a3 = _b.return))
        _a3.call(_b);
    } finally {
      if (e_29)
        throw e_29.error;
    }
  }
  return combined;
}, _a2[AND_NOT] = function(a, b) {
  var e_30, _a3;
  try {
    for (var _b = __values(b.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var docId = _c.value;
      a.delete(docId);
    }
  } catch (e_30_1) {
    e_30 = { error: e_30_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a3 = _b.return))
        _a3.call(_b);
    } finally {
      if (e_30)
        throw e_30.error;
    }
  }
  return a;
}, _a2);
var defaultBM25params = { k: 1.2, b: 0.7, d: 0.5 };
var calcBM25Score = function(termFreq, matchingCount, totalCount, fieldLength, avgFieldLength, bm25params) {
  var k = bm25params.k, b = bm25params.b, d = bm25params.d;
  var invDocFreq = Math.log(1 + (totalCount - matchingCount + 0.5) / (matchingCount + 0.5));
  return invDocFreq * (d + termFreq * (k + 1) / (termFreq + k * (1 - b + b * fieldLength / avgFieldLength)));
};
var termToQuerySpec = function(options) {
  return function(term, i, terms) {
    var fuzzy = typeof options.fuzzy === "function" ? options.fuzzy(term, i, terms) : options.fuzzy || false;
    var prefix = typeof options.prefix === "function" ? options.prefix(term, i, terms) : options.prefix === true;
    return { term, fuzzy, prefix };
  };
};
var defaultOptions = {
  idField: "id",
  extractField: function(document, fieldName) {
    return document[fieldName];
  },
  tokenize: function(text) {
    return text.split(SPACE_OR_PUNCTUATION);
  },
  processTerm: function(term) {
    return term.toLowerCase();
  },
  fields: void 0,
  searchOptions: void 0,
  storeFields: [],
  logger: function(level, message) {
    if (typeof (console === null || console === void 0 ? void 0 : console[level]) === "function")
      ;
  },
  autoVacuum: true
};
var defaultSearchOptions = {
  combineWith: OR,
  prefix: false,
  fuzzy: false,
  maxFuzzy: 6,
  boost: {},
  weights: { fuzzy: 0.45, prefix: 0.375 },
  bm25: defaultBM25params
};
var defaultAutoSuggestOptions = {
  combineWith: AND,
  prefix: function(term, i, terms) {
    return i === terms.length - 1;
  }
};
var defaultVacuumOptions = { batchSize: 1e3, batchWait: 10 };
var defaultVacuumConditions = { minDirtFactor: 0.1, minDirtCount: 20 };
var defaultAutoVacuumOptions = __assign(__assign({}, defaultVacuumOptions), defaultVacuumConditions);
var assignUniqueTerm = function(target, term) {
  if (!target.includes(term))
    target.push(term);
};
var assignUniqueTerms = function(target, source) {
  var e_31, _a3;
  try {
    for (var source_1 = __values(source), source_1_1 = source_1.next(); !source_1_1.done; source_1_1 = source_1.next()) {
      var term = source_1_1.value;
      if (!target.includes(term))
        target.push(term);
    }
  } catch (e_31_1) {
    e_31 = { error: e_31_1 };
  } finally {
    try {
      if (source_1_1 && !source_1_1.done && (_a3 = source_1.return))
        _a3.call(source_1);
    } finally {
      if (e_31)
        throw e_31.error;
    }
  }
};
var byScore = function(_a3, _b) {
  var a = _a3.score;
  var b = _b.score;
  return b - a;
};
var createMap = function() {
  return /* @__PURE__ */ new Map();
};
var objectToNumericMap = function(object) {
  var e_32, _a3;
  var map = /* @__PURE__ */ new Map();
  try {
    for (var _b = __values(Object.keys(object)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      map.set(parseInt(key, 10), object[key]);
    }
  } catch (e_32_1) {
    e_32 = { error: e_32_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a3 = _b.return))
        _a3.call(_b);
    } finally {
      if (e_32)
        throw e_32.error;
    }
  }
  return map;
};
var SPACE_OR_PUNCTUATION = /[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u;

// textplain/render/assembly/assembly2website.ts
function reportTemplateError(error, options) {
  const loc = options.loc;
}
import_handlebars6.default.registerHelper("href", function(...args) {
  const options = args.pop();
  const from = options.data["root"];
  if (args.length > 1) {
    reportTemplateError("too many args", options);
  }
  if (options.hash["style"] !== void 0 && options.hash["style"] !== "abs") {
    throw new Error(`"${options.hash["style"]}" href style not implemented`);
  }
  const to = args.length === 0 ? from : args[0];
  const abs = options.hash["style"] === "abs";
  if (typeof to === "string") {
    return "NOT IMPLEMENTED";
  } else {
    return convertFilePathToUriPath(abs ? outPathForNode(to) : relativeOutPath(from, to));
  }
});
import_handlebars6.default.registerHelper("breadcrumbs", function(f) {
  let cur;
  if (f.isOpeningContent()) {
    cur = f.parent;
  } else {
    cur = f;
  }
  let breadcrumbs = cur.title;
  while (cur.parent !== void 0) {
    cur = cur.parent;
    breadcrumbs = `<a href="${relativeOutPath(f, cur)}">${cur.title}</a> / ` + breadcrumbs;
  }
  return breadcrumbs;
});
var Assembly2Website = class {
  renderSTIR;
  dest;
  // resources that aren't part of the TextAssembly, but needed for the rendered website
  webResourceSrcRoot;
  renderCnt = 0;
  copyCnt = 0;
  searchIndex;
  /**
   * Determines the href style used to point to a node in the rendered website.
   *
   * todo[api] the option design below is a first idea. Maybe replace with
   *    low-level switches. See *API Design Resources* below.
   *
   * The current design of this setting offers high level, semantic choices
   * such as `'local'`, rather than low-level switches such as `'include
   * index.html' on directories .
   *
   * `posix`: like the posix standard: files don't have trailing slashes,
   *          slashes denote directories.
   * `local`: use this if you want the links to work if the rendered files
   *          are opened on the local locally rather than served by a
   *          webserver.
   *
   * API Design Resources
   * --------------------
   * See:
   *  - https://www.zachleat.com/web/trailing-slash/ (written by the creator of Eleventy and employee of Netlify)
   *  - https://github.com/slorber/trailing-slash-guide
   *  - https://stackoverflow.com/questions/5948659/when-should-i-use-a-trailing-slash-in-my-url
   *  - https://searchfacts.com/url-trailing-slash/
   *  -
   */
  hrefStyle = "rel";
  constructor(dest, renderSTIR, webResourceSrcRoot, hrefStyle) {
    this.renderSTIR = renderSTIR;
    this.dest = dest;
    this.webResourceSrcRoot = webResourceSrcRoot;
    this.hrefStyle = hrefStyle || "rel";
    this.searchIndex = new MiniSearch(
      {
        fields: ["path", "title", "body"],
        idField: "path",
        storeFields: ["path", "title"]
      }
    );
  }
  prepare(assembly) {
    this.renderCnt = 0;
    this.copyCnt = 0;
    this.searchIndex.removeAll();
    this.prepareFolder(assembly);
    traverse(assembly, (node) => {
      const page = node;
      if (node.isFile()) {
        page.isGeneratedHACK = node.isGenerated();
        page.isOpeningContentHACK = node.isOpeningContent();
      } else {
      }
      page.isFileHACK = node.isFile();
      page.isFolderHACK = node.isFolder();
      page.innerAssemblyPathHACK = node.innerAssemblyPath();
      page.outerAssemblyPathHACK = node.outerAssemblyPath();
      return "continue";
    }, void 0);
    if (this.webResourceSrcRoot !== void 0) {
      this.dest.copySync({ vfs: this.webResourceSrcRoot, path: "/" }, "/", true);
    }
  }
  prepareFolder(folder) {
    folder.outNode = folder.name;
    if (folder.parent !== void 0) {
      this.dest.mkdirSync(outPathForNode(folder), false);
    }
    for (const n of folder.content) {
      if (n.isFolder()) {
        if (n.hasIncludedContent) {
          this.prepareFolder(n);
        }
      } else {
        if (n.status === "sText: waiting" || n.status === "resource: waiting") {
          n.outNode = destForFile(n);
          if (n.outNode === void 0) {
            throw new Error(`unexpected state for ${n.outerAssemblyPath()}`);
          }
        }
      }
    }
    if (folder.openingContent !== void 0) {
      folder.openingContent.outNode = destForFile(folder.openingContent);
    } else {
      throw new Error(`unexpected indexable folder w/o opening content`);
    }
  }
  render(stir) {
    const tStir = stir;
    const file = tStir._tunnel.srcFile;
    const text = resolveCrossReferencesAndExtractText(stir, file, this.hrefStyle);
    this.searchIndex.add({ id: this.renderCnt, path: outPathForNode(file), title: file.title, body: text });
    const html = this.renderSTIR(stir);
    this.dest.writeFileSync(outPathForNode(file), html);
    file.status = "sText: rendered";
    this.renderCnt++;
  }
  copy(file) {
    if (file.status !== "resource: in pipeline") {
      throw new Error(`unexpected status for ${file.outerAssemblyPath()}: ${file.status}`);
    }
    this.dest.copySync({ vfs: file.assemblyRoot().srcFS(), path: file.innerAssemblyPath() }, outPathForNode(file));
    file.status = "resource: copied";
    this.copyCnt++;
  }
  finish() {
    const results = this.searchIndex.search("asynchronous");
    results.forEach((result) => void 0);
    this.publishSearchIndex();
  }
  publishSearchIndex() {
    const jsonIndex = this.searchIndex.toJSON();
    const serializedIndex = JSON.stringify(jsonIndex);
    const indexFilePath = "/_resources/MiniSearch_Index.json";
    if (!this.dest.existsSync("/_resources/")) {
      this.dest.mkdirSync("/_resources/", false);
    }
    this.dest.writeFileSync(indexFilePath, serializedIndex);
  }
  stats() {
    return {
      "pages rendered": this.renderCnt,
      "files copied": this.copyCnt,
      "index generated": {
        "pages": this.searchIndex.documentCount,
        "terms": this.searchIndex.termCount
      }
    };
  }
};
function resolveCrossReferencesAndExtractText(stir, file, hrefStyle) {
  let text = "";
  if (hrefStyle !== "rel" && hrefStyle !== "local") {
    throw new Error(`"${hrefStyle}" href style not implemented`);
  }
  const inlineBodyVisitor = function(inline) {
    if (typeof inline === "string") {
      text += " " + inline;
    }
    if (typeof inline === "object" && (inline.type === "xref" || inline.type === "image")) {
      const referent = inline.referent;
      if (typeof referent === "string" && !referent.startsWith("http:")) {
        const targetNode = file.resolvePath(referent);
        if (targetNode !== void 0) {
          inline.referent = relativeOutPath(file, targetNode);
          if (targetNode.isFolder() && hrefStyle === "local") {
            inline.referent += "/index.html";
          }
        } else {
        }
      }
    }
  };
  if (isBlock(stir)) {
    stir.traverseBodyTree(function(b) {
      if (b.title) {
        traverseInlineBodyTree(b.title, inlineBodyVisitor);
      }
      if (isInlineSequence(b.body)) {
        traverseInlineBodyTree(b.body, inlineBodyVisitor);
      }
      return 0;
    });
  } else {
    traverseInlineBodyTree(stir, inlineBodyVisitor);
  }
  return text;
}
function outPathForNode(n) {
  let op = n.outNode;
  if (op === void 0) {
    throw new Error(`outPath not available for ${n.outerAssemblyPath()}`);
  }
  let p = n.parent;
  while (p !== void 0) {
    op = p.outNode + op;
    p = p.parent;
  }
  return op;
}
function relativeOutPath(from, to) {
  if (from.isFile()) {
    from = from.parent;
  }
  const rel = import_path_browserify5.default.relative(outPathForNode(from), outPathForNode(to));
  return rel.length === 0 ? "." : rel;
}
function destForFile(file) {
  if (file.isOpeningContent()) {
    return "index.html";
  }
  const type = fileTypeByFilename(file.name);
  if (type.name === "TEXT" && file.parent.name === "spec/") {
    return convertNameToWebName(file.nameSansExt()) + ".html";
  }
  if (type.name === "MARKDOWN") {
    return convertNameToWebName(file.nameSansExt()) + ".html";
  } else if (type.name === "HTML") {
    return file.name;
  } else if (type.type === "media" || type.type === "resource") {
    return file.name;
  }
  return void 0;
}
function convertNameToWebName(n) {
  return n.replace(/\s/g, "-");
}
var convertFilePathToUriPath = function(path) {
  try {
    return (0, import_encode2.default)(path, ";/:@&=+$,-_.!~*'()");
  } catch (err) {
    return path;
  }
};
var provider11 = {
  async configure(dest, config) {
    if (config === void 0) {
      throw new Error(`missing AssemblyRendererProvider config`);
    }
    const outletConfig = config.requiredSubConfig("formats.html");
    const renderSTIR = await configRenderSTIRProvider(outletConfig);
    const webResourcesPath = config.resolvedPathValue("webResourcesPath");
    const webResourcesFS = webResourcesPath ? new SandboxFS(webResourcesPath, "readonly") : void 0;
    const hrefStyle = config.value("href_style");
    return new Assembly2Website(dest, renderSTIR, webResourcesFS, hrefStyle);
  }
};
registerAssemblyRenderer("Assembly2Website", provider11);

// textplain/parse.ts
async function configParseProvider(config) {
  const providerName = config.requiredValue("provider");
  if (providerName !== "ptss-parser") {
    throw new Error(`HACK: hardcoded support for ptss-parser only`);
  }
  const providerConfig = config.requiredSubConfig("config");
  const stylesheet = providerConfig.requiredSubConfig("stylesheet");
  const stylesheetName = stylesheet.requiredValue("name");
  const stylesheetOptions = stylesheet.subConfig("options")?.data();
  const parserOptions = config.subConfig("options")?.data();
  const inlet = new Parser(
    loadSheet(stylesheetName, stylesheetOptions),
    parserOptions
  );
  return (input) => {
    const stir = inlet.parse(input);
    return stir;
  };
}

// textplain/render/assembly/AssemblyRenderer.ts
async function configAssemblyRendererProvider(dest, config) {
  const providerName = config.requiredValue("provider");
  const provider12 = lookupAssemblyRenderer(providerName);
  if (provider12 === void 0 || provider12.configure === void 0) {
    throw new Error(`invalid outlet: ${providerName}`);
  }
  const providerConfig = config.subConfig("config");
  const assemblyRenderer2 = await provider12.configure(dest, providerConfig);
  return assemblyRenderer2;
}

// textplain/pipeline.ts
async function configPipes(configs) {
  if (configs === void 0) {
    return [];
  }
  const pipes = [];
  for (const cfg of configs) {
    const pipe = await configPipeProvider(cfg);
    if (pipe !== void 0) {
      pipes.push(pipe);
    }
  }
  return pipes;
}
function simplePipeline(inlet, pipes, outlet) {
  const pump = (input) => {
    let stir;
    if (typeof input === "string") {
      stir = inlet(input);
    } else {
      if (isBlock(input)) {
      } else {
      }
      stir = input;
    }
    for (let i = 0; i < pipes.length; i++) {
      pipes[i](stir);
    }
    const output = outlet(stir);
    return output;
  };
  return { pump, inlet, pipes, outlet };
}
async function simplePipelineFromConfig(config) {
  try {
    const inlet = await configParseProvider(config.requiredSubConfig("inlet"));
    const pipes = await configPipes(config.subConfigs("pipes"));
    const outlet = await configRenderSTIRProvider(config.requiredSubConfig("outlet"));
    return simplePipeline(inlet, pipes, outlet);
  } catch (e) {
    throw Error("Textplain pipeline configuration error", { cause: e });
  }
}
async function simplePipelineFromConfigFile(configPath) {
  const config = newConfigForVfsPath(configPath);
  return await simplePipelineFromConfig(config);
}
function assemblyPipeline(assembly, inlet, pipes, outlet) {
  const pipeAndRenderSTIR = (stir, file) => {
    const tStir = stir;
    tStir._tunnel = {
      srcFile: file,
      srcAssembly: assembly
    };
    for (let i = 0; i < pipes.length; i++) {
      pipes[i](stir);
    }
    outlet.render(stir);
  };
  const pump = (file) => {
    const type = fileTypeByFilename(file.name);
    if (type.name === "MARKDOWN") {
      const input = file.readFileSync();
      const stir = inlet(input);
      pipeAndRenderSTIR(stir, file);
    } else if (file.isGenerated()) {
      const stir = file.stir;
      if (isBlock(stir)) {
      } else {
      }
      pipeAndRenderSTIR(stir, file);
    } else if (type.name === "STIR (JSON)") {
      const stir = JSON.parse(file.readFileSync());
      if (isBlock(stir)) {
      } else {
      }
      pipeAndRenderSTIR(stir, file);
    } else if (type.name === "TEXT" && file.parent.name === "spec/") {
      const input = file.readFileSync();
      const stir = inlet(input);
      pipeAndRenderSTIR(stir, file);
    } else if (type.name === "HTML") {
      file.status = "resource: in pipeline";
      outlet.copy(file);
    } else {
      if (type.type === "media") {
        outlet.copy(file);
      } else {
      }
    }
  };
  const prime = () => {
    outlet.prepare(assembly);
  };
  const flush = () => {
    outlet.finish();
  };
  const stats = () => {
    return outlet.stats();
  };
  return { prime, pump, flush, stats, inlet, pipes, outlet };
}
async function assemblyPipelineFromConfig(assembly, dest, config, parentPipeline) {
  try {
    let inlet;
    if (!config.hasValue("inlet") && parentPipeline?.inlet !== void 0) {
      inlet = parentPipeline.inlet;
    } else {
      inlet = await configParseProvider(config.requiredSubConfig("inlet"));
    }
    const pipes = [];
    if (config.hasValue("pipes")) {
      pipes.push(...await configPipes(config.requiredSubConfigs("pipes")));
    } else {
      if (config.hasValue("prepend_pipes")) {
        pipes.push(...await configPipes(config.requiredSubConfigs("prepend_pipes")));
      }
      if (parentPipeline?.pipes !== void 0) {
        pipes.push(...parentPipeline.pipes);
      }
      if (config.hasValue("append_pipes")) {
        pipes.push(...await configPipes(config.requiredSubConfigs("append_pipes")));
      }
    }
    let outlet;
    if (parentPipeline !== void 0) {
      outlet = parentPipeline.outlet;
    } else {
      const outletConfig = config.requiredSubConfig("outlet");
      outlet = await configAssemblyRendererProvider(dest, outletConfig);
    }
    return assemblyPipeline(assembly, inlet, pipes, outlet);
  } catch (e) {
    throw Error("Textplain pipeline configuration error", { cause: e });
  }
}

// textplain/render/assembly/render.ts
async function renderAssembly(src, dest, configPath) {
  const destFS = new SandboxFS(dest, "empty");
  const assembly = readAssembly(src);
  if (configPath === void 0 && assembly.textplainConfig === void 0) {
    const msg = "missing pipeline config -- zero config not yet implemented";
    process.stderr.write(msg);
    throw new Error(msg);
  }
  prepareFolder(assembly);
  if (configPath !== void 0) {
    const config = newConfigForVfsPath(configPath, assembly);
    assembly.pipeline = await assemblyPipelineFromConfig(assembly, destFS, config);
  }
  await configureBranchSpecificPipelines(assembly, destFS);
  const pipelineMapper = (f) => {
    const r = f.searchUpForProperty("pipeline", true);
    if (r === void 0) {
      throw new Error(`no pipeline config found for ${f.crossAssemblyPath()}.`);
    }
    const pipeline = r.value;
    return pipeline;
  };
  if (assembly.pipeline === void 0) {
    throw Error("internal error: at this point we should have a root pipeline, falling back on a zero-config default");
  }
  assembly.pipeline.prime();
  pumpFolder(assembly, pipelineMapper);
  assembly.pipeline.flush();
  printSummary(assembly.pipeline.stats());
}
function pumpFolder(folder, pipelineMapper) {
  for (const n of folder.content) {
    if (n.isFolder()) {
      if (n.hasIncludedContent) {
        pumpFolder(n, pipelineMapper);
      }
    } else {
      if (n.status === "sText: waiting" || n.status === "resource: waiting") {
        pumpFile(n, pipelineMapper);
      }
    }
  }
  pumpFile(folder.openingContent, pipelineMapper);
}
function pumpFile(file, pipelineMapper) {
  if (file.status !== "sText: waiting" && file.status !== "resource: waiting") {
    throw new Error(`unexpected status for ${file.outerAssemblyPath()}: ${file.status}`);
  }
  if (file.status === "sText: waiting") {
    file.status = "sText: in pipeline";
  } else if (file.status === "resource: waiting") {
    file.status = "resource: in pipeline";
  }
  pipelineMapper(file).pump(file);
}
function prepareFolder(folder) {
  let hasContent = false;
  for (const n of folder.content) {
    if (n.isFolder()) {
      hasContent = prepareFolder(n) || hasContent;
    } else {
      const type = fileTypeByFilename(n.name);
      if (type.name === "MARKDOWN" || type.name === "HTML" || type.name === "TEXT" && folder.name === "spec/") {
        n.status = "sText: waiting";
        n.isIndexable = true;
        n.title = defaultFileTitle(n);
        hasContent = true;
      } else if (type.type === "media") {
        n.status = "resource: waiting";
        n.title = defaultFileTitle(n);
        hasContent = true;
      } else {
        n.status = "excluded";
      }
    }
  }
  if (folder.openingContent !== void 0) {
    hasContent = true;
    folder.openingContent.title = defaultFileTitle(folder.openingContent);
    folder.openingContent.status = "sText: waiting";
  } else if (hasContent) {
    const generated = new File(void 0, folder);
    folder.openingContent = generated;
    generated.title = defaultFileTitle(generated);
    const content = new Block("structured_text_intermediate_representation");
    const section = new Block("section");
    section.level = 1;
    section.title = generated.title;
    content.appendToBody(section);
    generated.stir = content;
    generated.status = "sText: waiting";
    generated.isIndexable = true;
  }
  folder.hasIncludedContent = hasContent;
  if (!hasContent)
    ;
  return hasContent;
}
async function configureBranchSpecificPipelines(assembly, dest) {
  async function configurationVisitor(n) {
    if (n.isFolder()) {
      if (n.textplainConfig !== void 0) {
        let heritablePipeline;
        const r = n.searchUpForProperty("pipeline", true);
        if (r !== void 0) {
          heritablePipeline = r.value;
        }
        n.pipeline = await assemblyPipelineFromConfig(
          assembly,
          dest,
          n.textplainConfig,
          heritablePipeline
        );
      }
    }
    return "continue";
  }
  await traverseAsync(assembly, configurationVisitor, void 0);
}
function printSummary(stats) {
  for (const [key, val] of Object.entries(stats)) {
    if (typeof val === "number") {
    } else {
      printSummary(val);
    }
  }
}
export {
  Assembly,
  Config,
  File,
  MemFS,
  SandboxFS,
  Stir2BootstrapHtml,
  Stir2Html,
  Stir2Markdown,
  Stir2String,
  Subfolder,
  Vpath,
  assemblyPipelineFromConfig,
  configPipeProvider,
  defaultFileTitle,
  getNodeSorter,
  lookupAssemblyRenderer,
  lookupPipe,
  lookupPlugin,
  lookupSTIRRenderer,
  newConfigForVfsPath,
  newConfigFromSimpleOptions,
  ptss_parser_exports as ptssParser,
  readAssembly,
  registerAssemblyRenderer,
  registerPipe,
  registerPlugin,
  registerSTIRRenderer,
  renderAssembly,
  resolvePath,
  simplePipeline,
  simplePipelineFromConfig,
  simplePipelineFromConfigFile,
  stir_exports as stir,
  traverse,
  traverseAsync
};
//! parent is NOT part of the STIR spec, though obviously
//! just ideas
//! should NOT be executed every parse attempt. Instead, call
//! initAndValidate() guarantees valid combinations if isSingleLine, headPattern and tailPattern
//! single-line, head anchored
//! multiline, head anchored
//! multiline, tail anchored, forward matching
//! multiline, tail anchored, backward matching
//! we only support back matching from the current non-lazy container.
//! this implements the spec's unambiguous pathless reference
//! unlike lisp, we don't treat the first item as an expression that could
//! as in Lisp, the `if` operator is a *special form*, with lazily evaluated branch args,
//! For the normal functions, arguments are evaluated in *Applicative order*:
//! same as ListStyle (with the exception of Markdown quirks which we'll need to
//! Unmarked hanging indent requires at least one following,
//! If the raw content is not bound by borders, it is thus only delineated by
//!  With this logic we are including slop rather than
//! //////////    delimLine    //////////////
//! /////// end parse delimiter line ////////
//! type assertion valid given the regex pattern can match empty string
//! for SV table, cell bodies are always an InlineSequence
//! given the match pattern, the ch MUST be a right border
//! handle columnDelim/sideBorder ambiguity
//! we only need to check for gfmQuirks table interruption
//! Remove all trailing NEWLINES and SPACES from the block content
//! PTSS inline parse function 'preserveNewlines' option
//! PTSS inline parse function 'newlineIsHardBreak' option
//! inline parse function 'preserveWhitespace' option
//! inline parse function 'backslashEOCIsHardBreak' option
//! inline parse function 'backslashNewlineIsHardBreak' option
//! 'as string` is a hack/cheat. It might be a BLock or Inline, but
//! disable both bare_links and corresponding GFM "Autolinks (extension)"
//! first case of making node type conditional!
//! we don't include the `^` in the name, because for test-references.ptss, we want a single
//! less efficient that the following, but we want to test marker extraction
//! this would be the `extends` option, and the following construction
//! this would be the `composition` option where instead of
//! most implementations ignore everything other than the first word
//! not in CommonMark, introduced by PTSS IR
//! If you want to see how well Textplain renders many third-party
//! HACK: instead of looking up a registered provider, we are hardcoding
//! even when a config is given, it's inlet and pipes can be overridden by
//# sourceMappingURL=textplain.browser.mjs.map
